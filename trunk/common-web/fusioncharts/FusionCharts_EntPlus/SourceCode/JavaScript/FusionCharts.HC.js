/*global Array: false, FusionCharts, window: false,
    FusionChartsDataFormats: false */

/**!
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts Technologies LLP
 * License Information at <http://www.fusioncharts.com/license>
 *
 * @author FusionCharts Technologies LLP
 * @version fusioncharts/3.2.2-servicerelease1.4200
 */

(function () {

    // Register the module with FusionCharts and also oget access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.highcharts-lib']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var
    // Constants
    BLANKSTRINGPLACEHOLDER = '#BLANK#',
    BLANKSTRING = '',
    COLOR_BLACK = '000000',
    COLOR_WHITE = 'FFFFFF',
    COLOR_TRANSPARENT = 'rgba(0,0,0,0)',
    TESTSTR = 'Ag',
    HASHSTRING = '#',
    BREAKSTRING = '<br />',
    STRINGSTRING = 'string',
    OBJECTSTRING = 'object',
    COMMASTRING = ',',
    ZEROSTRING = '0',
    ONESTRING = '1',
    DECIMALSTRING = ".",
    STRINGUNDEFINED = 'undefined',
    POSITION_TOP = 'top',
    POSITION_RIGHT = 'right',
    POSITION_BOTTOM = 'bottom',
    POSITION_LEFT = 'left',
    POSITION_CENTER = 'center',
    POSITION_MIDDLE = 'middle',
    FC_CONFIG_STRING = '_FCconf',

    // Strings that is being used rapidly
    HUNDREDSTRING = '100',
    BGRATIOSTRING = '0,100',
    PXSTRING = 'px',
    COMMASPACE = ', ',

    hasSVG = !!document.createElementNS &&
    !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,

    isIE = /msie/i.test(navigator.userAgent) && !window.opera,

    // Regular Expressions
    stripWhitespace = /\s+/g,
    dropHash = /^#?/,
    startsRGBA = /^rgba/i,
    cleanColorCode = /[#\s]/ig,
    breakPlaceholder = /\{br\}/ig,
    hexcode = /^#?[0-9a-f]{6}/i,

    mathAbs = Math.abs,

    objectToStrFn = Object.prototype.toString,

    /**
     * Checks if a value sent as argument is 'valid' as per valid input
     * standards.
     * @param {object} arg
     * @param {object} value is the default value returned.
     */
    getValidValue = function (arg, value) {
        return !arg && arg !== false && arg !== 0 ? value : arg;
    },

    /**
     *  Return the defColor if color is undefined
     *  other wise always returns the color even if color is a blank string
     */
    getDefinedColor = function (color, defColor) {
        return (!color && color != 0 && color != false) ? defColor : color;
    },

    /**
     * Returns the first argument that is a 'valid' value or a blank string.
     */
    getFirstValue = function () {
        var arg,
        i,
        l;
        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            return arg;
        }
        return BLANKSTRING;
    },

    /**
     * Returns the first argument that is a 'valid' value or undefined.
     */
    pluck = function () {
        var arg, i, l;
        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            return arg;
        }
        return undefined;
    },

    /**
     * Returns the first number in the argument array.
     *
     * @note
     * The expression here is same as getValidValue with isNaN check
     * added to it.
     */
    pluckNumber = function () {
        var arg,
        i,
        l;

        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            else if (isNaN(arg = Number(arg))) {
                continue;
            }
            return arg;
        }
        return undefined;
    },
    pluckFontSize = function () {
        var arg,
        i,
        l;

        for (i = 0, l = arguments.length; i < l; i += 1) {
            arg = arguments[i];
            if (!arg && arg !== false && arg !== 0) {
                continue;
            }
            else if (isNaN(arg = Number(arg))) {
                continue;
            }
            return arg < 1 ? 1 : arg;
        }
        return 1;
    },

    parsePointValue = function (value, abs) {
        
        value = !value && value !== false && value !== 0 ?
        NaN : Number(value);
        return isNaN(value) ? null : (abs ? mathAbs(value) : value);
    },

    parseUnsafeString = function (str) {
        
        if (typeof str === STRINGSTRING) {
            return str.replace(breakPlaceholder, BREAKSTRING);
        }
        else {
            return BLANKSTRING;
        }
    },

    getFirstColor = function (color) {
        color = color.split(COMMASTRING)[0];
        color = color.replace(stripWhitespace, BLANKSTRING);
        if (color == BLANKSTRING) {
            color = COLOR_BLACK;
        }
        return color.replace(dropHash, HASHSTRING);
    },

    getColorCodeString = function (color, fillString) {
        var returnString = "", colorEntry, len, i = 0, fillArray = fillString.split(COMMASTRING);
        for (len = fillArray.length; i < len; i += 1) {
            colorEntry = fillArray[i].split("-");
            if (colorEntry[0].indexOf("dark") !== "-1") {
                returnString += (getDarkColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMASTRING);
            } else {
                returnString += (getDarkColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMASTRING);
            }
        }
        return returnString.substring(0, returnString.length - 1);
    },

    pluckColor = function (color) {
        if (!getValidValue(color)) {
            return undefined;
        }
        color = color.split(COMMASTRING)[0];
        color = color.replace(stripWhitespace, BLANKSTRING);
        if (color == BLANKSTRING) {
            color = COLOR_BLACK;
        }
        return color.replace(dropHash, HASHSTRING);
    },

    getFirstAlpha = function (alpha) {
        alpha = parseInt(alpha, 10);
        if (isNaN(alpha) || alpha > 100 || alpha < 0) {
            alpha = 100;
        }
        return alpha;
    },

    merge = function (obj1, obj2) {
        var item, str;
        //check whether obj2 is an array
        //if array then iterate through it's index
        //**** MOOTOOLS precution
        if (obj2 instanceof Array) {
            for (item = 0; item < obj2.length; item += 1) {
                if (typeof obj2[item] !== OBJECTSTRING) {
                    obj1[item] = obj2[item];
                } else {
                    if (typeof obj1[item] !== OBJECTSTRING) {
                        obj1[item] = obj2[item] instanceof Array ? [] : {};
                    }
                    merge(obj1[item], obj2[item]);
                }
            }
        }
        else {
            for (item in obj2) {
                if (typeof obj2[item] === OBJECTSTRING) {
                    str = objectToStrFn.call(obj2[item]);
                    if (str === "[object Object]") {
                        if (typeof obj1[item] !== OBJECTSTRING) {
                            obj1[item] = {};
                        }
                        merge(obj1[item], obj2[item]);
                    }
                    else if (str === "[object Array]") {
                        if (!(obj1[item] instanceof Array)) {
                            obj1[item] = [];
                        }
                        merge(obj1[item], obj2[item]);
                    }
                    else {
                        obj1[item] = obj2[item];
                    }
                }
                else {
                    obj1[item] = obj2[item];
                }
            }
        }
        return obj1
    },

    extend2 = function (obj1, obj2) {
        if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {//if none of the arguments are object then return back
            return null;
        }

        if (typeof obj2 !== OBJECTSTRING) {
            obj2 = obj1;
            obj1 = undefined;
        }

        if (typeof obj1 !== OBJECTSTRING) {
            obj1 = obj2 instanceof Array ? [] : {};
        }
        merge(obj1, obj2);
        return obj1;

    },




    getLinkedChartDataJSON = function (linkedDataId, FCDataObj) {
        var linkedDataJSON = {
            "chart":{}
        }, index;
        FcJSON = FCDataObj;
        linkedDataId = linkedDataId.toLowerCase();
        if (FcJSON.linkeddata) {
            for (index = 0; index < FcJSON.linkeddata.length; index += 1) {
                if (FcJSON.linkeddata[index].id.toLowerCase() === linkedDataId) {
                    linkedDataJSON = FcJSON.linkeddata[index].linkedchart;
                }
            }
        }
        return linkedDataJSON;
    },

    getLinkAction = function (FCDataObj, senderChartObj) {
        return function () {
            var dashPos, frameDetails, commaPos, linkURL, delimiter,
            linkType, linkedDataId, linkedData,
            WINDOW = window,
            pointLink = getFirstValue(this.link, BLANKSTRING),
            pointChartLink = (this.series && this.series.chart && this.series.chart.options
                && this.series.chart.options.chart && this.series.chart.options.chart.link) || BLANKSTRING,
            chartLink = (this.options && this.options.chart && this.options.chart.link) || BLANKSTRING,
            strLink = pluck(pointLink, chartLink, pointChartLink);
            //We continue only if the link is not empty
            if (strLink !== undefined) {
                // first we decode the link
                // And we trim the link
                strLink = WINDOW.decodeURIComponent(strLink).replace(/^\s+/, BLANKSTRING).replace(/\s+$/, BLANKSTRING);

                if (strLink.search(/^[a-z]*\s*[\-\:]\s*/i) !== -1) {
                    delimiter = strLink.split(/\s*[\-\:]\s*/)[0].toUpperCase();
                }

                // Now based on what the first character in the link is (N, F, P, S, J)
                // And (NEWCHART, JAVASCRIPT:)
                // we invoke the link.

                switch (delimiter) {
                    case "J":
                        // We remove blank spaces between "j" and "-" if any
                        strLink = strLink.replace(/^j\s*\-/i, "j-");

                        dashPos = strLink.indexOf("-", 2);
                        //If no arguments, just call the link
                        if (dashPos === -1) {
                            try {
                                eval(strLink.slice(2));
                            } catch (err) {

                            }
                        }
                        //There could be multiple parameters. We just pass them as a single string to JS method.
                        else {
                            try {
                                WINDOW[strLink.substr(2, dashPos - 2).replace(/\s/g, BLANKSTRING)](strLink.slice(dashPos + 1))
                            } catch (err) {

                            }
                        }
                        break;

                    case "JAVASCRIPT":
                        strLink = strLink.replace(/^JAVASCRIPT\s*\:/i, "javascript:");
                        try {
                            eval(strLink.slice(11));
                        } catch (err) {

                        }
                        break;

                    case "N":
                        strLink.replace(/^n\s*\-/i, "n-");
                        WINDOW.open(strLink.slice(2));
                        break;

                    case "F":
                        strLink = strLink.replace(/^f\s*\-/i, "f-");

                        //strLink.slice(dashPos+1) indicates arguments if any
                        //strLink.substr(2, dashPos-2) indicates link
                        dashPos = strLink.indexOf("-", 2);
                        //If no arguments, just call the link
                        if (dashPos !== -1) {
                            frameDetails = strLink.substr(2, dashPos - 2);
                            if (frameDetails && WINDOW.frames[frameDetails]) {
                                WINDOW.frames[frameDetails].location = strLink.slice(dashPos + 1);
                            } else {
                                WINDOW.open(strLink.slice(dashPos + 1), frameDetails);
                            }
                        } else {
                            WINDOW.open(strLink.slice(2));
                        }
                        break;

                    case "P":
                        strLink = strLink.replace(/p\s*\-/i, "p-");
                        dashPos = strLink.indexOf ("-", 2);
                        commaPos = strLink.indexOf (COMMASTRING, 2);
                        if (dashPos === -1) {
                            dashPos = 1;
                        }
                        linkURL = strLink.slice (dashPos + 1);
                        WINDOW.open(linkURL,
                            strLink.substr (2, commaPos - 2),
                            strLink.substr (commaPos + 1, dashPos - commaPos - 1))
                        .focus();
                        break;

                    case "NEWCHART":
                        //Linked chart.
                        //Find the second dash position
                        dashPos = strLink.indexOf ("-", 9);
                        //Figure out whether the sub-linked chart is xml or url
                        linkType = strLink.substring(9, dashPos).toUpperCase();

                        //Based on linkType, take appropriate action
                        if (linkType=="XMLURL") {
                            //Extract linked XML URL
                            linkedData = strLink.substring(dashPos+1, strLink.length);
                        //If it's URL, just invoke linked chart event
                        }
                        else if (linkType=="JSONURL") {
                            //Extract linked JSON URL
                            linkedData = strLink.substring(dashPos+1, strLink.length);
                        //If it's URL, just invoke linked chart event
                        } else if (linkType=="XML" || linkType=="JSON") {
                            //Extract linked data identifier
                            linkedDataId = strLink.substring(dashPos+1, strLink.length);
                            //Get the data for the linked chart
                            linkedData = getLinkedChartDataJSON(linkedDataId, FCDataObj);
                            //If linkedData is empty string, it means data identifier or linked data was not found
                            linkType = "JSON";
                        }

                        global.raiseEvent('LinkedChartInvoked', {
                            linkType : linkType,
                            data : linkedData
                        }, senderChartObj);
                        break;

                    default:
                        WINDOW.location.href = strLink;
                        break;
                }
            }
        };
    },




    // GRAPHICS FUNCTION
    getAlpha = function (alpha, multiplyer) {
        alpha = Number(alpha);
        alpha = isNaN(alpha) ? 100 : alpha;
        if (multiplyer !== undefined) {
            alpha = alpha * multiplyer / 100;
        }
        return alpha % 101;
    },

    parseAlpha = function (alpha, length, multiplyer) {
        var alphaArr = alpha.split(COMMASTRING), x;
        if (multiplyer !== undefined) {
            multiplyer = pluckNumber(multiplyer.split(COMMASTRING)[0]);
        }
        alphaArr[0] = getAlpha(alphaArr[0], multiplyer);
        for (x = 1; x < length; x+= 1) {
            alphaArr[x] = alphaArr[0] * getAlpha(alphaArr[x], multiplyer) / 100;
        }
        return alphaArr.join(COMMASTRING);
    },

    //reduce gradient color take only first color
    //converts color to compatable color format
    //**** rgba must be rgbs(r,g,b,a) format
    
    
    convertColor = function (color, alpha, rgba) {
        var R = 0, G = 0, B = 0, colorStr, tempArr;

        if (rgba && rgba.match(startsRGBA)) {
            tempArr = rgba.split(COMMASTRING);
            R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
            G = tempArr[1];
            B = tempArr[2];
            if (!alpha && alpha !== 0) {
                alpha = parseInt((tempArr[3].slice(0, tempArr[3].indexOf(')')) * 100), 10);
            }
        }
        if (color) {
            if (color.match(startsRGBA)) {
                tempArr = color.split(COMMASTRING);
                R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
                G = tempArr[1];
                B = tempArr[2];
            }
            else {
                colorStr = color.replace(cleanColorCode, BLANKSTRING).split(COMMASTRING)[0];
                switch (colorStr.length) {
                    case 3:
                        colorStr = colorStr[0] + colorStr[0] + colorStr[1] + colorStr[1] + colorStr[2] + colorStr[2];
                        break;
                    case 6:
                        break;
                    default:
                        colorStr = (colorStr + COLOR_WHITE).slice(0, 6);
                        break;
                }
                R = parseInt(colorStr.slice(0, 2), 16);
                G = parseInt(colorStr.slice(2, 4), 16);
                B = parseInt(colorStr.slice(4, 6), 16);
            }
        }

        if (!alpha && alpha != 0) {
            alpha = 100;
        }
        if (typeof alpha === STRINGSTRING) {
            alpha = alpha.split(COMMASTRING)[0];
        }
        alpha = parseInt(alpha, 10) / 100;
        return 'rgba(' + R + COMMASTRING + G + COMMASTRING + B + COMMASTRING + alpha + ')';
    },

    // Returns a color code including # before it
    parseColor = function (color) {
        return color.replace(cleanColorCode, BLANKSTRING).replace(dropHash, HASHSTRING);
    },
    /*
     *  Function to generate color shade of a color
     *  one shade to darker and another is the lighter
     */
    getColorOffset = function (arrColorRGB, offsetPercent, isLighter) {
        var R,G,B;
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        if (isLighter) {
            // Creating darker shade in decimal
            // and convert single digit to two digit format
            R = Math.round(arrColorRGB[0] + ((255 - arrColorRGB[0]) * offsetPercent));
            G = Math.round(arrColorRGB[1] + ((255 - arrColorRGB[1]) * offsetPercent));
            B = Math.round(arrColorRGB[2] + ((255 - arrColorRGB[2]) * offsetPercent));
        } else {
            // Creating lighter shade in decimal
            // and convert single digit to two digit format
            R = Math.round(arrColorRGB[0] - (arrColorRGB[0] * offsetPercent));
            G = Math.round(arrColorRGB[1] - (arrColorRGB[1] * offsetPercent));
            B = Math.round(arrColorRGB[2] - (arrColorRGB[2] * offsetPercent));
        }
        return [R, G, B];
    },
    getDarkColor = function (color, offsetPercent) {
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        // Removing spaces and # form color
        color = color.replace(cleanColorCode, BLANKSTRING);
        var sourceclrRGB = parseInt(color, 16),
        // Converting color in R B G
        R = Math.floor(sourceclrRGB/65536),
        G = Math.floor((sourceclrRGB-R*65536)/256),
        B = sourceclrRGB-R*65536-G*256;
        return (COLOR_BLACK + ((R*offsetPercent) << 16 | (G*offsetPercent) <<
            8 | (B*offsetPercent)).toString(16)).slice(-6);
    },
    getLightColor = function (color, offsetPercent) {
        offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
        offsetPercent = offsetPercent / 100;
        // Removing spaces and # form color
        color = color.replace(cleanColorCode, BLANKSTRING);
        var sourceclrRGB = parseInt(color, 16),
        // Converting color in R B G
        R = Math.floor(sourceclrRGB/65536),
        G = Math.floor((sourceclrRGB-R*65536)/256),
        B = sourceclrRGB-R*65536-G*256;
        return (COLOR_BLACK + ((256-((256-R)*offsetPercent)) << 16 | (256-((256-G)*offsetPercent)) <<
            8 | (256-((256-B)*offsetPercent))).toString(16)).slice(-6);
    },

    symbolStr = {
        circle : 'circle',
        triangle : 'triangle',
        square : 'square',
        diamond : 'diamond',
        poly : 'poly_'
    },

    //map FusionCharts anchor sides to HC anchor symbol
    //anchorside > 4 will show the down triangle
    mapSymbolName = function (num) {
        var x = symbolStr.circle;
        num = parsePointValue(num);
        if (num >= 3) {
            switch (num) {
                case 3:
                    x = symbolStr.triangle;
                    break;
                case 4:
                    x = symbolStr.diamond;
                    break;
                default:
                    x = symbolStr.poly + num;
                    break;
            }
        }
        return x;
    },

    // helper fnction for draw3Drect
    getAngle = function (width, height, type) {
        var angle = Math.atan(height / width) * 180 / Math.PI;
        if (type == 2) {
            angle = 180 - angle;
        }
        else if (type == 3) {
            angle += 180;
        }
        else if (type == 4) {
            angle = 360 - angle;
        }
        return angle;
    },

    //this function create the column color depending upon the configuration
    getColumnColor = function (setColor, setAlpha, ratio, angle, isRoundEdges, bdColor, bdAlpha, isBar, is3d) {
        var bgColor, borderColor, colorArr, alphaArr, bdColorArr, color, alpha, bdAlphaArr;
        colorArr = setColor.split(COMMASTRING);
        alphaArr = setAlpha.split(COMMASTRING);
        bdColorArr = bdColor.split(COMMASTRING);
        bdAlphaArr = bdAlpha.split(COMMASTRING);
        if (is3d) {
            bgColor = {
                FCcolor: {
                    color: colorArr[0],
                    alpha: alphaArr[0]
                }
            };
        }
        else if (isRoundEdges) {
            color = colorArr[0];
            alpha = alphaArr[0]
            bgColor = {
                FCcolor: {
                    color: getDarkColor(color, 75) + COMMASTRING + getLightColor(color, 25) + COMMASTRING +
                    getDarkColor(color, 80) + COMMASTRING + getLightColor(color, 65) + COMMASTRING + getDarkColor(color, 80),
                    alpha: alpha + COMMASTRING + alpha + COMMASTRING + alpha +
                    COMMASTRING + alpha + COMMASTRING + alpha,
                    ratio: "0,10,13,57,20",
                    angle: isBar ? "-180" : "0"
                }
            };
            bdColorArr = [getDarkColor(color, 70)];
        }
        else {
            setAlpha = parseAlpha(setAlpha, colorArr.length);
            bgColor = {
                FCcolor: {
                    color: setColor,
                    alpha: setAlpha,
                    ratio: ratio,
                    angle: isBar ? 180 - angle : angle
                }
            };

        }
        borderColor = {
            FCcolor: {
                color: bdColorArr[0],
                alpha: bdAlphaArr[0]
            }
        }


        return [bgColor, borderColor];
    },

    setLineHeight,

    toPrecision = function (obj, value) {
        return obj.toPrecision && obj.toPrecision(value) || obj;
    },

    /**
     * Smart Label Component
     */
    SmartLabelManager = (function () {
        var supportedStyle = {
            font: 'font',
            fontFamily: 'font-family',
            'font-family' : 'font-family',
            fontWeight: 'font-weight',
            'font-weight' : 'font-weight',
            fontSize: 'font-size',
            'font-size' : 'font-size',
            lineHeight: 'line-height',
            'line-height': 'line-height',
            textDecoration: 'text-decoration',
            'text-decoration' : 'text-decoration',
            color: 'color',
            whiteSpace : 'white-space',
            'white-space' : 'white-space',
            padding : 'padding',
            margin : 'margin',
            background : 'background',
            backgroundColor : 'background-color',
            'background-color' : 'background-color',
            backgroundImage : 'background-image',
            'background-image' : 'background-image',
            backgroundPosition : 'background-position',
            'background-position' : 'background-position',
            backgroundPositionLeft : 'background-position-left',
            'background-position-left' : 'background-position-left',
            backgroundPositionTop : 'background-position-top',
            'background-position-top' : 'background-position-top',
            backgroundRepeat : 'background-repeat',
            'background-repeat' : 'background-repeat',
            border : 'border',
            borderColor : 'border-color',
            'border-color' : 'border-color',
            borderStyle : 'border-style',
            'border-style' : 'border-style',
            borderThickness : 'border-thickness',
            'border-thickness' : 'border-thickness',
            borderTop: 'border-top',
            'border-top' : 'border-top',
            borderTopColor : 'border-top-color',
            'border-top-color' : 'border-top-color',
            borderTopStyle : 'border-top-style',
            'border-top-style' : 'border-top-style',
            borderTopThickness : 'border-top-thickness',
            'border-top-thickness' : 'border-top-thickness',
            borderRight : 'border-right',
            'border-right' : 'border-right',
            borderRightColor : 'border-right-color',
            'border-right-color' : 'border-right-color',
            borderRightStyle : 'border-right-style',
            'border-right-style' : 'border-right-style',
            borderRightThickness : 'border-right-thickness',
            'border-right-thickness' : 'border-right-thickness',
            borderBottom : 'border-bottom',
            'border-bottom' : 'border-bottom',
            borderBottomColor : 'border-bottom-color',
            'border-bottom-color' : 'border-bottom-color',
            borderBottomStyle : 'border-bottom-style',
            'border-bottom-style' : 'border-bottom-style',
            borderBottomThickness : 'border-bottom-thickness',
            'border-bottom-thickness' : 'border-bottom-thickness',
            borderLeft : 'border-left',
            'border-left' : 'border-left',
            borderLeftColor : 'border-left-color',
            'border-left-color' : 'border-left-color',
            borderLeftStyle : 'border-left-style',
            'border-left-Style' : 'border-left-style',
            borderLeftThickness: 'border-left-thickness',
            'border-left-thickness' : 'border-left-thickness'
        };


        //create the setLineHeight function which will add the line heighth to a style
        setLineHeight = (function () {
            var container = document.createElement('span'), getLineHeight,
            donotUseStyle = {
                lineHeight : true,
                'line-height' : true
            },
            calculateLH = function () {
                var fontSize = pluckNumber(parseInt(container.style.fontSize, 10), 10);
                return (fontSize * 1.4) + 'px';
            };
            container.innerHTML = 'fy';
            if (window.getComputedStyle) {
                getLineHeight = function () {
                    return window.getComputedStyle(container, null).lineHeight;
                }
            }
            else if (container.currentStyle){
                getLineHeight = function () {
                    return container.currentStyle.lineHeight;
                }
            }
            else {
                getLineHeight = calculateLH;
            }
            return function (styleObj) {
                var key, styleStr = '';
                for (key in styleObj) {
                    if (!donotUseStyle[key] && supportedStyle[key]) {
                        styleStr += supportedStyle[key] + ' : ' + styleObj[key] + ';';
                    }
                }

                if (isIE && !hasSVG) {
                    container.style.setAttribute('cssText', styleStr);
                }
                else {
                    container.setAttribute('style', styleStr);
                }

                var lineHeight = getLineHeight();
                if (!parseFloat(lineHeight)) {
                    lineHeight = calculateLH();
                }
                styleObj.lineHeight = lineHeight;
                return lineHeight;
            };

        }());



        ///style that will be set at the creation of the text container and will
        // not be changed
        var fixedStyle = {
            "position": "absolute",
            "top": "-9999em",
            "whiteSpace": "nowrap"
        },
        //number of dot in ellipces
        ellipsesWidth = 0,
        //class name
        className = '_SmartLabel',
        className2 = '_SmartLabelBR',
        //have to modyfy sothat it can retrive classname among more
        classNameReg = /\b_SmartLabel\b/,
        classNameBrReg = /\b_SmartLabelBR\b/,
        spanAdditionRegx = /(\<[^\<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,
        spanAdditionReplacer = '$1<span class="'+ className + '">$2</span>',
        spanRemovalRegx = new RegExp('\<span[^\>]+?'+ className +'[^\>]+?\>(.*?)\<\/span\>', 'ig'),
        xmlTagRegEx = new RegExp('<[^>][^<]*[^>]+>', 'i'),
        testStrAvg = "WgI",
        lineHeight = 0,
        minWidth = 0,
        avgCharWidth = 0,
        dotWidth = 0,
        containerIdIncriment = 0,
        spanTagString = 'span',
        ChildRetriverFN,
        ChildRetriverSTRING,
        noClassTesting;
        if (document.getElementsByClassName) {
            ChildRetriverFN = 'getElementsByClassName';
            ChildRetriverSTRING = className;
            noClassTesting = true;
        }
        else {
            ChildRetriverFN = 'getElementsByTagName';
            ChildRetriverSTRING = spanTagString;
            noClassTesting = false;
        }

        //this function will create a container
        function createContainer (containerParent) {
            var body, container;

            if (containerParent && containerParent.offsetWidth && containerParent.offsetHeight) {
                if(containerParent.appendChild) {
                    containerParent.appendChild(container = document.createElement('span'));
                    container.className = "_SmartLabel_Container";
                    return container;
                }
            }
            else {
                body = document.getElementsByTagName('body')[0];
                //if body ready then Execuate the function otherwise add it at dom ready

                if (body && body.appendChild) {
                    ////create the text container element
                    container = document.createElement('span');
                    container.className = "_SmartLabel_Container";
                    containerIdIncriment += 1;
                    //append the container element
                    body.appendChild(container);
                    return container;
                }
            }
            return undefined;
        }
        //set container style
        function setContainerStyle (container, styleObj) {
            var key;
            for (key in styleObj) {
                container.style[key] = styleObj[key];
            }

            for (key in fixedStyle) {
                container.style[key] = fixedStyle[key];
            }
        }

        function getNearestChar(text, maxWidth, container) {

            container.innerHTML = text;
            var difference, charLen, increment, oriWidth = container.offsetWidth;

            difference = maxWidth;
            charLen = Math.ceil(maxWidth / avgCharWidth);

            if (oriWidth < maxWidth) {
                return (text.length - 1);
            }

            if (charLen > text.length) {
                difference = maxWidth - oriWidth;
                charLen = text.length;
            }

            while (difference > 0) {
                container.innerHTML = text.substr(0, charLen);
                difference = maxWidth - container.offsetWidth;
                increment = Math.floor(difference / avgCharWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }

            charLen += increment;

            while (difference < 0) {
                container.innerHTML = text.substr(0, charLen);
                difference = maxWidth - container.offsetWidth;
                increment = Math.floor(difference / avgCharWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }
            return charLen;
        }

        function SmartLabelManager (id, container, useEllipses) {

            if (typeof id === "undefined" || typeof id === "object") {
                return;
            }

            this.id = id;

            if (typeof container === "string") {
                container = document.getElementById(container);
            }

            this.parentContainer = container;
            this.container = createContainer (container, id);

            this.showNoEllipses = !useEllipses;
            this.init = true;
            //create the blank style obj
            this.style = {};
        }

        SmartLabelManager.prototype = {
            dispose: function () {
                var label = this,
                    container = label.container,
                    parentNode;

                if (!label.init) {
                    return;
                }

                if (container && (parentNode = container.parentNode)) {
                    parentNode.removeChild(container);
                    delete label.container;
                }

                delete label.id;
                delete label.style;
                delete label.parentContainer;
                delete label.showNoEllipses;
            },
            useEllipsesOnOverflow: function (useEllipses) {
                if (!this.init) {
                    return;
                }
                this.showNoEllipses = !useEllipses;
            },
            getSmartText : function (text, maxWidth, maxHeight, noWrap, containerParent) {
                if (!this.init) {
                    return false;
                }
                //if there has no container then create the container
                if (!this.container) {
                    
                    this.container = createContainer (this.parentContainer);
                    this.setStyle();
                }
                //now smartyfy the string
                ///create smart label object
                var smartLabel = {
                    text : text,
                    maxWidth : maxWidth,
                    maxHeight : maxHeight,
                    width : null,
                    height : null,
                    oriTextWidth : null,
                    oriTextHeight : null,
                    oriText : text,
                    isTruncated : false
                }, hasHTMLTag = false, len, trimStr, tempArr, maxWidthWithEll,
                oriWidth, oriHeight, lastDash = -1, lastSpace = -1, lastIndexBroken = -1, newCharIndex,
                container = this.container, currStr, nearestChar, oriTextArr = [],
                ellipsesStr = this.showNoEllipses ? "" : "...";

                var fastTrim = function (str) {
                    str = str.replace(/^\s\s*/, '');
                    var ws = /\s/, i = str.length;
                    while (ws.test(str.charAt(i -= 1))) {}
                    return str.slice(0, i + 1);
                };

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;

                    //add oriTextWidth & oriTextHeight
                    smartLabel.oriTextWidth = oriWidth = container.offsetWidth;
                    smartLabel.oriTextHeight = oriHeight = container.offsetHeight;

                    if (oriHeight <= maxHeight && oriWidth <= maxWidth) {
                        smartLabel.width = smartLabel.oriTextWidth = oriWidth;
                        smartLabel.height = smartLabel.oriTextHeight = oriHeight;
                        return smartLabel;
                    }

                    

                    if (lineHeight > maxHeight) {
                        smartLabel.text = "";
                        smartLabel.width = smartLabel.oriTextWidth = 0;
                        smartLabel.height = smartLabel.oriTextHeight = 0;
                        return smartLabel;
                    }

                    text = fastTrim(text).replace(/(\s+)/g, " ");

                    hasHTMLTag = xmlTagRegEx.test(text);
                    //hasHTMLTag = false;
                    i = 0;

                    maxWidthWithEll = this.showNoEllipses ? maxWidth : (maxWidth - ellipsesWidth);

                    if (!hasHTMLTag) {

                        oriTextArr = text.split("");
                        len = oriTextArr.length;
                        trimStr = "", tempArr = [];

                        container.innerHTML = oriTextArr[0];
                        minWidth = container.offsetWidth;

                        if (maxWidthWithEll > minWidth) {
                            tempArr = text.substr(0, getNearestChar(text, maxWidthWithEll, container)).split("");
                            i = tempArr.length - 1;
                        } else if (minWidth > maxWidth) {
                            smartLabel.text = "";
                            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        }
                        else if (!this.showNoEllipses) {
                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = "..";
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = ".";
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = "";
                                }
                            }
                        }

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                tempArr[i] = oriTextArr[i];
                                container.innerHTML = currStr = tempArr.join("");
                                if (container.offsetWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = currStr.substr(0, currStr.length - 1);
                                    }
                                    if (container.offsetWidth > maxWidth) {
                                        container.innerHTML = smartLabel.text = '<span title="' + smartLabel.oriText + '">' + fastTrim(trimStr) + ellipsesStr + '</span>';
                                        smartLabel.width = container.offsetWidth;
                                        smartLabel.height = container.offsetHeight;
                                        return smartLabel;
                                    }
                                }
                            }

                            smartLabel.text = container.innerHTML = currStr;
                            smartLabel.width = container.offsetWidth;
                            smartLabel.height = container.offsetHeight;
                            return smartLabel;

                        } else {
                            for (; i < len; i += 1) {

                                tempArr[i] = oriTextArr[i];
                                container.innerHTML = currStr = tempArr.join("");

                                if (container.offsetWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = currStr.substr(0, currStr.length - 1);
                                    }
                                    if (container.offsetWidth > maxWidth) {
                                        lastSpace = text.substr(0, tempArr.length).lastIndexOf(" ");
                                        lastDash = text.substr(0, tempArr.length).lastIndexOf("-");
                                        if (lastSpace > lastIndexBroken) {
                                            tempArr.splice(lastSpace, 1, "<br/>");
                                            lastIndexBroken = lastSpace;
                                            newCharIndex = lastSpace + 1;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === tempArr.length - 1) { // in case the overflowing character itself is the '-'
                                                tempArr.splice(lastDash, 1, "<br/>-");
                                            } else {
                                                tempArr.splice(lastDash, 1, "-<br/>");
                                            }
                                            lastIndexBroken = lastDash;
                                            newCharIndex = lastDash + 1;
                                        }else {
                                            tempArr.splice((tempArr.length - 1), 1, "<br/>" + oriTextArr[i]);
                                            newCharIndex = i;
                                        }
                                        container.innerHTML = currStr = tempArr.join("");
                                        if (container.offsetHeight > maxHeight) {
                                            smartLabel.text = container.innerHTML = "<span title='" + smartLabel.oriText + "'>" + fastTrim(trimStr) + ellipsesStr + "</span>";
                                            smartLabel.width = container.offsetWidth;
                                            smartLabel.height = container.offsetHeight;
                                            return smartLabel;
                                        } else {
                                            trimStr = null;
                                            nearestChar = getNearestChar(text.substr(newCharIndex), maxWidthWithEll, container);
                                            if (tempArr.length < newCharIndex + nearestChar) {
                                                tempArr = tempArr.concat(text.substr(tempArr.length, newCharIndex + nearestChar - tempArr.length).split(""));
                                                i = tempArr.length - 1;
                                            }
                                        }
                                    }
                                }
                            }

                            smartLabel.text = container.innerHTML = currStr;
                            smartLabel.width = container.offsetWidth;
                            smartLabel.height = container.offsetHeight;
                            return smartLabel;
                        }
                    }
                    else {
                        text = text.replace(spanAdditionRegx, spanAdditionReplacer);
                        text = text.replace(/(\<br\s*\/*\>)/g,"<span class='" + [className, " ", className2].join("") + "'>$1</span>");

                        container.innerHTML = text;

                        var spanArr = container[ChildRetriverFN](ChildRetriverSTRING), x, y,
                        elem, chr, elemRightMostPoint, elemLowestPoint,
                        lastBR, removeFromIndex, removeFromIndexForEllipses,
                        characterArr = [], dashIndex = -1, spaceIndex = -1, elem, chr;

                        for (x = 0, y = spanArr.length; x < y; x += 1) {
                            elem = spanArr[x];
                            //chech whether this span is temporary inserted span from it's class
                            if (noClassTesting || classNameReg.test(elem.className)) {
                                chr = elem.innerHTML;
                                if (chr != "") {
                                    if (chr == " ") {
                                        spaceIndex = characterArr.length;
                                    } else if ( chr == "-") {
                                        dashIndex = characterArr.length;
                                    }

                                    characterArr.push({
                                        spaceIdx: spaceIndex,
                                        dashIdx: dashIndex,
                                        elem: elem
                                    });
                                    oriTextArr.push(chr);
                                }
                            }
                        }

                        delete spanArr;
                        i = 0;
                        len = characterArr.length;

                        minWidth = characterArr[0].elem.offsetWidth;

                        if (minWidth > maxWidth) {
                            smartLabel.text = "";
                            smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        } else if (minWidth > maxWidthWithEll && !this.showNoEllipses) {

                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = "..";
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = ".";
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = "";
                                }
                            }
                        }

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemRightMostPoint = elem.offsetLeft + elem.offsetWidth;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }
                                    if (container.offsetWidth > maxWidth) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        } else {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemLowestPoint = elem.offsetHeight + elem.offsetTop;
                                elemRightMostPoint = elem.offsetLeft + elem.offsetWidth;

                                lastBR = null;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }

                                    if (elemRightMostPoint > maxWidth) {
                                        lastSpace = characterArr[i].spaceIdx;
                                        lastDash = characterArr[i].dashIdx;
                                        if (lastSpace > lastIndexBroken) {
                                            characterArr[lastSpace].elem.innerHTML = "<br/>";
                                            lastIndexBroken = lastSpace;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === i) { // in case the overflowing character itself is the '-'
                                                characterArr[lastDash].elem.innerHTML = "<br/>-";
                                            } else {
                                                characterArr[lastDash].elem.innerHTML = "-<br/>";
                                            }
                                            lastIndexBroken = lastDash;
                                        } else {
                                            elem.parentNode.insertBefore(lastBR = document.createElement('br'), elem);
                                        }

                                        //check whether this break made current element outside the area height
                                        if ((elem.offsetHeight + elem.offsetTop) > maxHeight) {
                                            //remove the lastly inserted line break
                                            if (lastBR) {
                                                lastBR.parentNode.removeChild(lastBR);
                                            }
                                            else if (lastIndexBroken === lastDash) {
                                                characterArr[lastDash].elem.innerHTML = "-";
                                            } else {
                                                characterArr[lastSpace].elem.innerHTML = " ";
                                            }
                                            removeFromIndex = i;
                                            //break the looping condition
                                            i = len;
                                        } else {
                                            removeFromIndexForEllipses = null;
                                        }
                                    }

                                } else {
                                    //check whether this break made current element outside the area height
                                    if (elemLowestPoint > maxHeight) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        }

                        if (removeFromIndex < len) {
                            //set the trancated property of the smartlabel
                            smartLabel.isTruncated = true;

                            
                            removeFromIndexForEllipses = removeFromIndexForEllipses ?
                            removeFromIndexForEllipses : removeFromIndex;

                            for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {
                                elem = characterArr[i].elem;
                                //chech whether this span is temporary inserted span from it's class
                                elem.parentNode.removeChild(elem);
                            }

                            for (; i >= 0; i -= 1) {
                                elem = characterArr[i].elem;
                                if (classNameBrReg.test(elem.className)) {
                                    //chech whether this span is temporary inserted span from it's class
                                    elem.parentNode.removeChild(elem);
                                } else {
                                    i = 0;
                                }
                            }
                        }

                        //get the smart text
                        smartLabel.text = container.innerHTML.replace(spanRemovalRegx, '$1');
                        if (smartLabel.isTruncated) {
                            smartLabel.text += ellipsesStr;
                            smartLabel.text = '<span title="' + oriTextArr.join("") + '">' + smartLabel.text + '</span>';
                        }
                    }

                    smartLabel.height = container.offsetHeight;
                    smartLabel.width = container.offsetWidth;

                    return smartLabel;
                }
                else {
                    smartLabel.error = new Error('Body Tag Missing!');
                    return smartLabel;
                }
            },
            setStyle : function (style) {
                if (!this.init) {
                    return false;
                }
                var key;
                if (style === this.style && !this.styleNotSet) {
                    return;
                }

                if (!style) {
                    style = this.style;
                } else {
                    delete this.style;
                    this.style = style;
                }

                // not needed as all styles have to be set using the container.style notation (ie 6 support)
                /* for (key in style) {
                    if (supportedStyle[key]) {
                        this.style[supportedStyle[key]] = style[key];
                    }
                } */
                //if there has container then apply the style
                if (this.container) {
                    setContainerStyle (this.container, this.style);
                    this.container.innerHTML = testStrAvg;
                    avgCharWidth = Math.ceil((this.container.offsetWidth)/3);
                    lineHeight = this.container.offsetHeight;

                    this.container.innerHTML = "...";
                    ellipsesWidth = this.container.offsetWidth;

                    this.container.innerHTML = ".";
                    dotWidth = this.container.offsetWidth;
                    this.styleNotSet = false;
                } else {
                    this.styleNotSet = true;
                }
            },
            getTextSize : function (text, maxWidth, maxHeight, noWrap) {
                if (!this.init) {
                    return false;
                }
                //if there has no container then create the container
                if (!this.container) {
                    this.container = createContainer (this.parentContainer);
                    this.setStyle();
                }
                var smartLabel = {
                    text : text,
                    width : null,
                    height : null,
                    oriTextWidth : null,
                    oriTextHeight : null,
                    isTruncated : false
                }, container = this.container;

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;
                    //add oriTextWidth & oriTextHeight
                    smartLabel.oriTextWidth = container.offsetWidth;
                    smartLabel.oriTextHeight = container.offsetHeight;
                    smartLabel.width = Math.min(smartLabel.oriTextWidth, maxWidth);
                    smartLabel.height = Math.min(smartLabel.oriTextHeight, maxHeight);
                    if (smartLabel.width < smartLabel.oriTextWidth || smartLabel.height < smartLabel.oriTextHeight) {
                        smartLabel.isTruncated = true;
                    }
                }
                return smartLabel;
            },
            getOriSize: function(text) {
                if (!this.init) {
                    return false;
                }
                //if there has no container then create the container
                if (!this.container) {
                    this.container = createContainer (this.parentContainer);
                    this.setStyle();
                }
                var smartLabel = {
                    text : text,
                    width : null,
                    height : null
                }, container = this.container;

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;
                    //add oriTextWidth & oriTextHeight
                    smartLabel.width = container.offsetWidth;
                    smartLabel.height = container.offsetHeight;
                }
                return smartLabel;
            }
        };

        SmartLabelManager.prototype.constructor = SmartLabelManager;
        return SmartLabelManager;
    }()),

    /**
     * BG Image align attribute managing function
     */
    setImageDisplayMode = function (bgImageDisplayMode, bgImageVAlign,
            bgImageHAlign, bgImageScale, chartBorderWidth, chartWidth,
            chartHeight, imageEle) {
        var imageWidth = imageEle.width * (bgImageScale / 100),
        imageHeight = imageEle.height * (bgImageScale / 100),
        alignImage = {},
        imgAspectRatio, cAspectRatio, scaleFactor,
        xCount, yCount,
        //Consider the borderthickness and find out chart width and height
        cWidth = chartWidth - (chartBorderWidth * 2),
        cHeight = chartHeight - (chartBorderWidth * 2),
        // Function to align the image
        // returns x y position of the image
        getImageAlignment = function (bgImageVAlign, bgImageHAlign, imageWidth, imageHeight, chartWidth, chartHeight) {
            var alignObj = {};
            switch (bgImageVAlign) {
                case "top":
                    alignObj.y = chartBorderWidth;
                    break;
                case "bottom":
                    alignObj.y = chartHeight - imageHeight - chartBorderWidth;
                    break;
                case "middle":
                    alignObj.y = (chartHeight - imageHeight) / 2;
                    break;
            }


            switch (bgImageHAlign) {
                case "left":
                    alignObj.x = chartBorderWidth;
                    break;
                case "right":
                    alignObj.x = chartWidth - imageWidth - chartBorderWidth;
                    break;
                case "middle":
                    alignObj.x = (chartWidth - imageWidth) / 2;
                    break;
            }
            return alignObj;
        };


        switch (bgImageDisplayMode) {
            case "center":
                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.y = (chartHeight / 2) - (imageHeight / 2);
                alignImage.x = (chartWidth / 2) - (imageWidth / 2);
                break;

            case "stretch"://Stretch Display Mode
                alignImage.width = (chartWidth - chartBorderWidth * 2);
                alignImage.height = (chartHeight - chartBorderWidth * 2);
                alignImage.y = chartBorderWidth;
                alignImage.x = chartBorderWidth;
                break;

            case "tile"://Tile Display Mode
                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.tileInfo = {};
                alignImage.tileInfo.xCount = xCount = Math.ceil(cWidth / imageWidth);
                alignImage.tileInfo.yCount = yCount =  Math.ceil(cHeight / imageHeight);

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    imageWidth * xCount, imageHeight * yCount, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
                break;

            case "fit"://Fit Display Mode

                //Original image's aspect ratio.
                imgAspectRatio = imageWidth / imageHeight;
                //Chart's background aspect ratio
                cAspectRatio = cWidth / cHeight;
                scaleFactor = (imgAspectRatio > cAspectRatio) ?  cWidth / imageWidth : cHeight / imageHeight;

                alignImage.width = imageWidth * scaleFactor;
                alignImage.height = imageHeight * scaleFactor;

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    alignImage.width, alignImage.height, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
                break;

            case "fill"://Fill Display Mode

                //Original image's aspect ratio.
                imgAspectRatio = imageWidth / imageHeight;
                //Chart's background aspect ratio
                cAspectRatio = cWidth / cHeight;
                //Find out scale factor
                scaleFactor = (imgAspectRatio > cAspectRatio) ?  cHeight / imageHeight : cWidth / imageWidth;

                alignImage.width = imageWidth * scaleFactor;
                alignImage.height = imageHeight * scaleFactor;

                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    alignImage.width, alignImage.height, chartWidth, chartHeight);

                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;

                break;

            default : // None
                //In none mode image only need alignment.
                alignObj = getImageAlignment (bgImageVAlign, bgImageHAlign,
                    imageWidth, imageHeight, chartWidth, chartHeight);

                alignImage.width = imageWidth;
                alignImage.height = imageHeight;
                alignImage.y = alignObj.y;
                alignImage.x = alignObj.x;
        }

        return alignImage;
    },


    /*
     *manager to add axis labels
     */
    axisLabelAdder = (function () {
        var positionTextConf = {
            top : {
                align: 'center',
                verticalAlign: 'top',
                textAlign: 'center'
            },
            right : {
                align: 'right',
                verticalAlign: 'middle',
                textAlign: 'left'
            },
            bottom : {
                align: 'center',
                verticalAlign: 'bottom',
                textAlign: 'center'
            },
            left : {
                align: 'left',
                verticalAlign: 'middle',
                textAlign: 'right'
            }
        },
        alphaRetriveRegx = /([^\,^\s]+)\)$/g,
        labelAdder = function (defaultSeries, FCchartObj) {
            var labelStep;
            
            if (/^(bar|bar3d)$/.test(defaultSeries)) {
                this.isBar = true;
                this.yPos = 'bottom';
                this.yOppPos = 'top';
                this.xPos = 'left';
                this.xOppPos = 'right';
            }
            //steping attr
            labelStep = parseInt(FCchartObj.labelstep, 10);
            this.labelStep = labelStep > 1 ? labelStep : 1;
            this.showLabel = pluckNumber(FCchartObj.showlabels, FCchartObj.shownames, 1);
            this.is3D = /3d$/.test(defaultSeries);

        };
        labelAdder.prototype = {
            isBar : false,
            yPos : 'left',
            yOppPos : 'right',
            xPos : 'bottom',
            xOppPos : 'top',
            //Note: linecolor must be in rgba str
            addAxisGridLine : function (axisObj, value, text, width, dashStyle, lineColor, zIndex, isXxis) {
                var hasText = text === '' ? false : true, hasVisiableLine = width > 0 ||
                lineColor.match(alphaRetriveRegx)[1] > 0 ? true : false, axisPos, textConf, gridLine;
                if (hasText || hasVisiableLine) {
                    if (!hasVisiableLine) {
                        lineColor = COLOR_TRANSPARENT;
                        width = 0.1;
                    }
                    gridLine = {
                        isGrid : true,
                        width: width,
                        dashStyle  : dashStyle,
                        color  : lineColor,
                        value: value,
                        zIndex : zIndex === undefined ? 2 : zIndex
                    };
                    if (hasText) {
                        axisPos = axisObj.opposite ? (isXxis ? this.xOppPos : this.yOppPos) : (isXxis ? this.xPos : this.yPos);
                        textConf = positionTextConf[axisPos];
                        gridLine.label = {
                            text : text,
                            style : axisObj.labels.style,
                            textAlign : textConf.textAlign,
                            align  : textConf.align,
                            verticalAlign : textConf.verticalAlign,
                            rotation : 0,
                            x : 0,
                            y : 0
                        };
                    }
                    axisObj.plotLines.push(gridLine);
                }
            },
            addAxisAltGrid : function (axisObj, currentValue) {
                if (!this.is3D) {
                    var lastValue = pluckNumber(axisObj['_lastValue'], axisObj.min),
                    altGrid = pluck(axisObj['_altGrid'], false);
                    if (altGrid) {
                        axisObj.plotBands.push({
                            isGrid : true,
                            color  : axisObj.alternateGridColor,
                            to : currentValue,
                            from : lastValue,
                            zIndex : 1
                        });
                    }
                    axisObj['_lastValue'] = currentValue;
                    axisObj['_altGrid'] = !altGrid;
                }
            },
            addXaxisCat : function (axisObj, value, index, label) {
                var hasText = label === '' ? false : true,  axisPos, textConf, gridLine;
                if (index % this.labelStep === 0) {
                    axisPos = axisObj.opposite ? this.xOppPos : this.xPos;
                    textConf = positionTextConf[axisPos];
                    gridLine = {
                        isGrid : true,
                        width: 0.1,
                        color  : COLOR_TRANSPARENT,
                        value: value,
                        label : {
                            text : label,
                            style : axisObj.labels.style,
                            textAlign : textConf.textAlign,
                            align  : textConf.align,
                            verticalAlign : textConf.verticalAlign,
                            rotation : 0,
                            x : 0,
                            y : 0
                        }
                    };
                    axisObj.plotLines.push(gridLine);
                }
            },
            addVline : function (axisObj, dataObj, index, hcObj) {
                //Extract attributes
                var conf = hcObj[FC_CONFIG_STRING],
                isBar = conf.isBar,
                plotBorderWidth = hcObj.chart.plotBorderWidth,
                pbwMod2 = (plotBorderWidth % 2),
                divlineStyle = conf.divlineStyle,
                label = parseUnsafeString(dataObj.label),
                showLabelBorder = Boolean(pluckNumber(dataObj.showlabelborder, conf.showVLineLabelBorder, 1)),
                showLabelBackground = Boolean(pluckNumber(dataObj.showlabelbackground, 1)),
                labelHAlign = pluck(dataObj.labelhalign, isBar ? POSITION_LEFT : POSITION_CENTER),
                labelVAlign = pluck(dataObj.labelvalign, isBar ? POSITION_MIDDLE : POSITION_BOTTOM).toLowerCase(),
                labelPosition = pluckNumber(dataObj.labelposition, 0), 
                linePosition = pluckNumber(dataObj.lineposition, 0.5),
                alpha = pluckNumber(dataObj.alpha, conf.vLineAlpha, 80),
                color = pluck(dataObj.color, conf.vLineColor, "333333").replace(/^#?/, "#"),
                bgColor = pluck(dataObj.labelbgcolor, conf.vLineLabelBgColor, "333333").replace(/^#?/, "#"),
                labelColor = color,
                thickness = pluckNumber(dataObj.thickness, conf.vLineThickness, 1),
                halfThickness = thickness * 0.5,
                isDashed = Boolean(Number (pluck (dataObj.dashed, 0))),
                dashLen = pluckNumber(dataObj.dashlen, 5),
                dashGap = pluckNumber(dataObj.dashgap, 2),
                smartLabel = conf.smartLabel,
                fontSizeInt = parseInt(divlineStyle.fontSize, 10),
                y = fontSizeInt + 2,
                x = 0,
                smartText,
                labelRotation = pluckNumber(dataObj.rotatelabel,
                        conf.rotateVLineLabels) ? 270 : 0;

                linePosition = (linePosition < 0 || linePosition > 1) ? 0.5 : linePosition;
                labelPosition = (labelPosition < 0 || labelPosition > 1) ? 0 : labelPosition;
                smartLabel.setStyle(divlineStyle);
                smartText = smartLabel.getOriSize(label);

                color = convertColor(color, alpha);

                if (!isBar) {
                    switch (labelVAlign) {
                        case POSITION_TOP:
                            y -= smartText.height + 2 + (plotBorderWidth || 1) *
                                (1 - labelPosition) + labelPosition;
                            break;
                        case POSITION_MIDDLE:
                            y -= (smartText.height * 0.5) + plotBorderWidth * (1 - labelPosition * 2);
                            break;
                        default:
                            y += (plotBorderWidth - pbwMod2) * labelPosition;

                    }
                    switch (labelHAlign) {
                        case POSITION_LEFT:
                            x += thickness;
                        break;
                        case POSITION_RIGHT:
                            x -= thickness + 1;
                        break;
                    }
                }
                else {
                    switch (labelVAlign) {
                        case POSITION_TOP:
                            y -= smartText.height + halfThickness + 2;
                            break;
                        case POSITION_MIDDLE:
                            y -= (smartText.height * 0.5) + 1;
                            break;
                        default:
                            y += halfThickness;
                    }

                    if (!dataObj.labelhalign) {
                        x -= smartText.width * labelPosition;
                    }
                }

                axisObj.plotLines.push({
                    isVline : true,
                    color: color,
                    width: thickness,
                    value: (index - 1) + linePosition,
                    zIndex : !conf.is3d && dataObj.showontop === '1' ? 5 : 3, // extra for js charts
                    dashStyle : isDashed ? getDashStyle(dashLen, dashGap, thickness) : undefined,
                    label: {
                        text: label,
                        align: isBar ? POSITION_LEFT : POSITION_CENTER,
                        offsetScale : labelPosition,
                        rotation: labelRotation,
                        y: y,
                        x: x,
                        textAlign: labelHAlign,
                        style: {
                            color: labelColor,
                            fontSize : divlineStyle.fontSize,
                            fontFamily : divlineStyle.fontFamily,
                            lineHeight : divlineStyle.lineHeight,
                            border: showLabelBorder ? '1px solid' : undefined,
                            borderColor: showLabelBorder ? labelColor : undefined,
                            backgroundColor: showLabelBackground ? bgColor : undefined,
                            backgroundOpacity: showLabelBackground ?
                                    pluck(dataObj.labelbgalpha, conf.vLineLabelBgAlpha) / 100 : 0
                        }
                    }
                });
            }
        };
        labelAdder.prototype.constructor = labelAdder;
        return labelAdder;
    })(),

    NumberFormatter = (function () {

        
        var TWOSTRING = "2",

        numberFormatDefaults = {
            formatnumber: ONESTRING,
            formatnumberscale: ONESTRING,
            defaultnumberscale: BLANKSTRING,
            numberscaleunit: ['K', 'M'],//'K,M',
            numberscalevalue: [1000, 1000], //'1000,1000',
            numberprefix: BLANKSTRING,
            numbersuffix: BLANKSTRING,
            // Decimals default value is different in different charts
            decimals: BLANKSTRING,
            forcedecimals: ZEROSTRING,
            yaxisvaluedecimals: TWOSTRING,
            decimalseparator: DECIMALSTRING,
            thousandseparator: COMMASTRING,
            indecimalseparator: BLANKSTRING,
            inthousandseparator: BLANKSTRING,
            sformatnumber: ONESTRING,
            sformatnumberscale: ZEROSTRING,
            sdefaultnumberscale: BLANKSTRING,
            snumberscaleunit: ['K','M'],
            snumberscalevalue: [1000, 1000],
            snumberprefix: BLANKSTRING,
            snumbersuffix: BLANKSTRING,
            sdecimals: TWOSTRING,
            sforcedecimals: ZEROSTRING,
            syaxisvaluedecimals: TWOSTRING,

            xFormatNumber : ZEROSTRING,
            xFormatNumberScale : ZEROSTRING,
            xDefaultNumberScale : BLANKSTRING,
            xNumberScaleUnit : ['K','M'],
            xNumberScaleValue : [1000, 1000],
            xNumberPrefix : BLANKSTRING,
            xNumberSuffix : BLANKSTRING
        },

        numberFormatOverrides = {
            mscombidy2d: {
                formatnumberscale: ONESTRING
            }
        },

        /*
         *  NumberFormatter function
         **/
        NumberFormatter = function (chartObj, chartName) {
            var numberscaleunit,
            snumberscaleunit,
            numberscalevalue,
            paramLabels,
            param1,
            snumberscalevalue,
            chartSpecificConf = numberFormatOverrides[chartName];

            if (typeof chartSpecificConf !== OBJECTSTRING) {
                chartSpecificConf = numberFormatDefaults;
            }

            if(getValidValue(chartObj.numberscaleunit)) {
                numberscaleunit = chartObj.numberscaleunit.split(COMMASTRING);
            }
            if(getValidValue(chartObj.snumberscaleunit)) {
                snumberscaleunit = chartObj.snumberscaleunit.split(COMMASTRING);
            }
            if(getValidValue(chartObj.numberscalevalue)) {
                numberscalevalue = chartObj.numberscalevalue.split(COMMASTRING);
            }
            if(getValidValue(chartObj.snumberscalevalue)) {
                snumberscalevalue = chartObj.snumberscalevalue.split(COMMASTRING);
            }

            // Parameters passed with this function
            this.paramLabels = paramLabels = {
                formatnumber        : pluck(chartObj.formatnumber, chartSpecificConf.formatnumber, numberFormatDefaults.formatnumber),
                formatnumberscale   : pluck(chartObj.formatnumberscale, chartSpecificConf.formatnumberscale, numberFormatDefaults.formatnumberscale),
                //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] && numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                defaultnumberscale  : getFirstValue(chartObj.defaultnumberscale, chartSpecificConf.defaultnumberscale, numberFormatDefaults.defaultnumberscale),
                numberscaleunit     : pluck(numberscaleunit, chartSpecificConf.numberscaleunit, numberFormatDefaults.numberscaleunit),
                numberscalevalue    : pluck(numberscalevalue, chartSpecificConf.numberscalevalue, numberFormatDefaults.numberscalevalue),
                numberprefix        : getFirstValue(chartObj.numberprefix, chartSpecificConf.numberprefix, numberFormatDefaults.numberprefix),
                numbersuffix        : getFirstValue(chartObj.numbersuffix, chartSpecificConf.numbersuffix, numberFormatDefaults.numbersuffix),
                decimalprecision    : parseInt(pluck(chartObj.decimals, chartObj.decimalprecision, chartSpecificConf.decimals,
                    numberFormatDefaults.decimals, chartSpecificConf.decimalprecision, numberFormatDefaults.decimalprecision), 10),
                forcedecimals       : pluck(chartObj.forcedecimals, chartSpecificConf.forcedecimals, numberFormatDefaults.forcedecimals),

                decimalseparator    : pluck(chartObj.decimalseparator, chartSpecificConf.decimalseparator, numberFormatDefaults.decimalseparator),
                thousandseparator   : pluck(chartObj.thousandseparator, chartSpecificConf.thousandseparator, numberFormatDefaults.thousandseparator),
                indecimalseparator  : getFirstValue(chartObj.indecimalseparator, chartSpecificConf.indecimalseparator, numberFormatDefaults.indecimalseparator),
                inthousandseparator : getFirstValue(chartObj.inthousandseparator, chartSpecificConf.inthousandseparator, numberFormatDefaults.inthousandseparator)
            };

            this.param1 = param1 = {
                formatnumber        : paramLabels.formatnumber,
                formatnumberscale   : paramLabels.formatnumberscale,
                defaultnumberscale  : paramLabels.defaultnumberscale,
                numberscaleunit     : paramLabels.numberscaleunit,
                numberscalevalue    : paramLabels.numberscalevalue,
                numberprefix        : paramLabels.numberprefix,
                numbersuffix        : paramLabels.numbersuffix,

                decimalprecision    : parseInt(pluck(chartObj.yaxisvaluedecimals, paramLabels.decimalprecision)),
                forcedecimals       : pluck(chartObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),

                decimalseparator    : paramLabels.decimalseparator,
                thousandseparator   : paramLabels.thousandseparator,
                indecimalseparator  : paramLabels.indecimalseparator,
                inthousandseparator : paramLabels.inthousandseparator
            };

            this.paramX = {
                formatnumber : pluck(chartObj.xformatnumber, paramLabels.formatnumber),
                formatnumberscale : pluck(chartObj.xformatnumberscale, paramLabels.formatnumberscale),
                defaultnumberscale : getFirstValue(chartObj.xdefaultnumberscale, paramLabels.defaultnumberscale),
                numberscaleunit : pluck(chartObj.xnumberscaleunit, paramLabels.numberscaleunit),
                numberscalevalue : pluck(chartObj.xnumberscalevalue, paramLabels.numberscalevalue),
                numberprefix : pluck(chartObj.xnumberprefix, paramLabels.numberprefix),
                numbersuffix : pluck(chartObj.xnumbersuffix, paramLabels.numbersuffix),


                decimalprecision    : parseInt(pluck(chartObj.xaxisvaluedecimals, chartObj.xaxisvaluesdecimals, paramLabels.decimalprecision)),
                forcedecimals       : pluck(chartObj.forcexaxisvaluedecimals, 0),

                decimalseparator    : paramLabels.decimalseparator,
                thousandseparator   : paramLabels.thousandseparator,
                indecimalseparator  : paramLabels.indecimalseparator,
                inthousandseparator : paramLabels.inthousandseparator
            };

            this.param2 = {
                formatnumber        : pluck(chartObj.sformatnumber, numberFormatDefaults.sformatnumber),
                formatnumberscale   : pluck(chartObj.sformatnumberscale, numberFormatDefaults.sformatnumberscale),
                defaultnumberscale  : getFirstValue(chartObj.sdefaultnumberscale, numberFormatDefaults.sdefaultnumberscale),
                numberscaleunit     : pluck(snumberscaleunit, numberFormatDefaults.snumberscaleunit),
                numberscalevalue    : pluck(snumberscalevalue, numberFormatDefaults.snumberscalevalue),
                numberprefix        : getFirstValue(chartObj.snumberprefix, numberFormatDefaults.snumberprefix),
                numbersuffix        : getFirstValue(chartObj.snumbersuffix, numberFormatDefaults.snumbersuffix),
                decimalprecision    : parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.sdecimals, numberFormatDefaults.sdecimals), 10),
                forcedecimals       : pluck(chartObj.forcesyaxisvaluedecimals, chartObj.sforcedecimals, numberFormatDefaults.sforcedecimals),

                decimalseparator    : pluck(chartObj.decimalseparator, numberFormatDefaults.decimalseparator),
                thousandseparator   : pluck(chartObj.thousandseparator, numberFormatDefaults.thousandseparator),
                indecimalseparator  : pluck(chartObj.indecimalseparator, numberFormatDefaults.indecimalseparator),
                inthousandseparator : pluck(chartObj.inthousandseparator, numberFormatDefaults.inthousandseparator)
            };

            
            // Adding special attributes for yAxis (scatter and bubble) charts
            if (/^(bubble|scatter|selectscatter)$/.test(chartName)) {
                param1.formatnumber = pluck(chartObj.yformatnumber, param1.formatnumber);
                param1.formatnumberscale  = pluck(chartObj.yformatnumberscale, param1.formatnumberscale);
                param1.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, param1.defaultnumberscale);
                param1.numberscaleunit = pluck(chartObj.ynumberscaleunit, param1.numberscaleunit);
                param1.numberscalevalue = pluck(chartObj.ynumberscalevalue, param1.numberscalevalue);
                param1.numberprefix = pluck(chartObj.ynumberprefix, param1.numberprefix);
                param1.numbersuffix = pluck(chartObj.ynumbersuffix, param1.numbersuffix);
                //
                paramLabels.formatnumber = pluck(chartObj.yformatnumber, paramLabels.formatnumber);
                paramLabels.formatnumberscale  = pluck(chartObj.yformatnumberscale, paramLabels.formatnumberscale);
                paramLabels.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, paramLabels.defaultnumberscale);
                paramLabels.numberscaleunit = pluck(chartObj.ynumberscaleunit, paramLabels.numberscaleunit);
                paramLabels.numberscalevalue = pluck(chartObj.ynumberscalevalue, paramLabels.numberscalevalue);
                paramLabels.numberprefix = pluck(chartObj.ynumberprefix, paramLabels.numberprefix);
                paramLabels.numbersuffix = pluck(chartObj.ynumbersuffix, paramLabels.numbersuffix);
            }

            // Adding special attributes for secondary yAxis
            if (/^(mscombidy2d|mscombidy3d)$/.test(chartName)) {
                this.param2.formatnumberscale = pluckNumber(chartObj.sformatnumberscale, ONESTRING);
            }

            // Fix for some chart decimals default value different
            if (/^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(chartName)) {
                paramLabels.decimalprecision = pluck(chartObj.decimals, TWOSTRING);
            }

        };

        NumberFormatter.prototype = {
            percentValue : function (num) {
                return formatCommas (formatDecimals(num, this.paramLabels.decimalprecision,
                    this.paramLabels.forcedecimals),
                this.paramLabels.decimalseparator,
                this.paramLabels.thousandseparator) + '%'
            },
            getCleanValue: function (num, abs) {
                num = convertNumberSeps(num, this.paramLabels.indecimalseparator,
                    this.paramLabels.inthousandseparator);
                return isNaN(num) ? null : (abs ? mathAbs(num) : num);
            },
            dataLabels: function (num, isSY) {
                return formatNumber(num, isSY ? this.param2 : this.paramLabels);
            },
            yAxis: function (num) {
                return formatNumber(num, this.param1);
            },
            xAxis: function (num) {
                return formatNumber(num, this.paramX);
            },
            sYAxis: function (num) {
                return formatNumber(num, this.param2);
            }
        };

        NumberFormatter.prototype.constructor = NumberFormatter;

        var formatNumber = function (num, attributes) {
            // We convert the number to a valid number
            // If inDecimalsSeparator and in thousandSeparator is given
            // we replace the thousandSeparator and decimalSeparator with
            // proper valid number format
            //num = convertNumberSeps(num, attributes.indecimalseparator, attributes.inthousandseparator);

            // Change for JS Charts:
            // After initial return from getCleanValue, we get either null or a
            // number. So, we validate presence of null only.
            if (num === null) {
                return; //throw TypeError("Not a Valid number");
            }

            // Failsafe conversion of value to proper type.
            num = Number(num);

            //First, if number is to be scaled, scale it
            //Number in String format
            var strNum = num + BLANKSTRING;

            //Number Scale
            var strScale;
            if (attributes.formatnumberscale == 1) {
                strScale = attributes.defaultnumberscale;
            }
            else {
                strScale = BLANKSTRING;
            }

            // Fix to show the decimal place
            // if there is more than 2 decimal place in data
            // Finding the decimal place in value
            var valueArr, decimalPlaceLen;
            valueArr = strNum.split('.')[1];
            decimalPlaceLen = valueArr ? valueArr.length : attributes.forcedecimals ? TWOSTRING : BLANKSTRING;


            // Whether to add K (thousands) and M (millions) to a number
            if (attributes.formatnumberscale == 1) {
                //Get the formatted scale and number
                var objNum = formatNumberScale (num, attributes.defaultnumberscale, attributes.numberscalevalue, attributes.numberscaleunit);
                //Store from return in local primitive variables

                strNum = objNum.value;
                num = objNum.value;
                strScale = objNum.scale;
            }

            //Now, if we've to format the decimals and commas
            if (attributes.formatnumber == 1) {
                //Format decimals
                strNum = formatDecimals (num, pluck(attributes.decimalprecision, decimalPlaceLen), attributes.forcedecimals);
                //Format commas now
                strNum = formatCommas (strNum, attributes.decimalseparator, attributes.thousandseparator);
            }

            //Now, add scale, number prefix and suffix
            //strNum = numberPrefix + strNum + strScale + numberSuffix;
            strNum = (attributes.numberprefix || BLANKSTRING) + strNum + strScale + (attributes.numbersuffix || BLANKSTRING);
            return strNum;
        };

        /**
         * formatNumberScale formats the number as per given scale.
         * For example, if number Scale Values are 1000,1000 and
         * number Scale Units are K,M, this method will divide any
         * value over 1000000 using M and any value over 1000 (less than 1M) using K
         * so as to give abbreviated figures.
         * Number scaling lets you define your own scales for numbers.
         * To clarify further, let's consider an example. Say you're plotting
         * a chart which indicates the time taken by a list of automated
         * processes. Each process in the list can take time ranging from a
         * few seconds to few days. And you've the data for each process in
         * seconds itself. Now, if you were to show all the data on the chart
         * in seconds only, it won't appear too legible. What you can do is
         * build a scale of yours and then specify it to the chart. A scale,
         * in human terms, would look something as under:
         * 60 seconds = 1 minute
         * 60 minute = 1 hr
         * 24 hrs = 1 day
         * 7 days = 1 week
         * First you would need to define the unit of the data which you're providing.
         * Like, in this example, you're providing all data in seconds. So, default
         * number scale would be represented in seconds. You can represent it as under:
         * <graph defaultNumberScale='s' ...>
         * Next, the scale for the chart is defined as under:
         * <graph numberScaleValue='60,60,24,7' numberScaleUnit='min,hr,day,wk' >
         * If you carefully see this and match it with our range, whatever numeric
         * figure was present on the left hand side of the range is put in
         * numberScaleValue and whatever unit was present on the right side of
         * the scale has been put under numberScaleUnit - all separated by commas.
         * @param intNum The number to be scaled.
         * @param defaultNumberScale Scale of the number provided.
         * @param numScaleValues Incremental list of values (divisors) on
         * which the number will be scaled.
         * @param
         */
        function formatNumberScale (intNum, defaultNumberScale, numScaleValues, numScaleUnits) {
            //Create an object, which will be returned
            var objRtn = {};
            //Scale Unit to be stored (assume default)
            var strScale = defaultNumberScale;
            var i = 0;
            //If the scale unit or values have something fed in them
            //we manipulate the scales.
            if (numScaleValues.length === numScaleUnits.length) {
                for (i = 0; i < numScaleValues.length; i ++) {
                    if (numScaleValues[i] && Math.abs (Number (intNum)) >= numScaleValues[i]) {
                        strScale = numScaleUnits[i] || BLANKSTRING;
                        intNum = Number (intNum) / numScaleValues[i];
                    }
                    else {
                        break;
                    }
                }
            }
            //Set the values as properties of objRtn
            objRtn.value = intNum;
            objRtn.scale = strScale;
            return objRtn;
        }

        /**
         * formatDecimals method formats the decimal places of a number.
         * Requires the following to be defined:
         * params.decimalSeparator
         * params.thousandSeparator
         * @param intNum Number on which we've to work.
         * @param decimalPrecision Number of decimal places to which we've
         * to format the number to.
         * @param forceDecimals Boolean value indicating whether to add decimal
         * padding to numbers which are falling as whole
         * numbers?
         * @return A number with the required number of decimal places
         * in String format. If we return as Number, Flash will remove
         * our decimal padding or un-wanted decimals.
         */
        function formatDecimals (intNum, decimalPrecision, forceDecimals) {
            var tenToPower, strRounded;

            // if negative decimal precision is sent, we set it to 0, as per
            // FusionCharts Policy
            if(decimalPrecision <= 0) {
                return String(Math.round (intNum));
            //decimalPrecision = 0;
            }
            //If no decimal places are needed, just round the number and return
            if (isNaN(decimalPrecision)) {
                intNum = intNum.toString();
                if (intNum.length > 12 && intNum.indexOf(DECIMALSTRING) != -1) {
                    decimalPrecision = 12 - intNum.split(DECIMALSTRING)[0].length;
                    tenToPower = Math.pow (10, decimalPrecision);
                    strRounded = String (Math.round (intNum * tenToPower) / tenToPower);
                    intNum = strRounded;
                }
                return intNum;
            //return Math.round (intNum) + BLANKSTRING;
            }
            //Round the number to specified decimal places
            //e.g. 12.3456 to 3 digits (12.346)
            //Step 1: Multiply by 10^decimalPrecision - 12345.6
            //Step 2: Round it - i.e., 12346
            //Step 3: Divide by 10^decimalPrecision - 12.346
            tenToPower = Math.pow (10, decimalPrecision);
            strRounded = String (Math.round (intNum * tenToPower) / tenToPower);

            //Now, strRounded might have a whole number or a number with required
            //decimal places. Our next job is to check if we've to force Decimals.
            //If yes, we add decimal padding by adding 0s at the end.
            if (forceDecimals == 1) {
                //Add a decimal point if missing
                //At least one decimal place is required (as we split later on .)
                //10 -> 10.0
                if (strRounded.indexOf (DECIMALSTRING) == - 1) {
                    strRounded += ".0";
                }
                //Finally, we start add padding of 0s.
                //Split the number into two parts - pre & post decimal
                var parts = strRounded.split (DECIMALSTRING);
                //Get the numbers falling right of the decimal
                //Compare digits in right half of string to digits wanted
                var paddingNeeded = decimalPrecision - parts [1].length;
                //Number of zeros to add
                for (var i = 1; i <= paddingNeeded; i ++) {
                    //Add them
                    strRounded += ZEROSTRING;
                }
            }
            return (strRounded);
        }

        /**
         * formatCommas method adds proper commas to a number in blocks of 3
         * i.e., 123456 would be formatted as 123,456
         * @param strNum The number to be formatted (as string).
         * Why are numbers taken in string format?
         * Here, we are asking for numbers in string format
         * to preserve the leading and padding 0s of decimals
         * Like as in -20.00, if number is just passed as number,
         * Flash automatically reduces it to -20. But, we've to
         * make sure that we do not disturb the original number.
         * @return Formatted number with commas.
         */
        function formatCommas (strNum, decimalseparator, thousandseparator) {

            //intNum would represent the number in number format
            var intNum = Number (strNum);

            //If the number is invalid, return an empty value
            if (isNaN (intNum)){
                return BLANKSTRING;
            }
            var strDecimalPart = BLANKSTRING;
            var boolIsNegative = false;
            var strNumberFloor = BLANKSTRING;
            var formattedNumber = BLANKSTRING;
            var startPos = 0;
            var endPos = 0;
            //Define startPos and endPos
            startPos = 0;
            endPos = strNum.length;

            //Extract the decimal part
            if (strNum.indexOf (DECIMALSTRING) != - 1) {
                strDecimalPart = strNum.substring (strNum.indexOf (DECIMALSTRING) + 1, strNum.length);
                endPos = strNum.indexOf (DECIMALSTRING);
            }
            //Now, if the number is negative, get the value into the flag
            if (intNum < 0) {
                boolIsNegative = true;
                startPos = 1;
            }
            //Now, extract the floor of the number
            strNumberFloor = strNum.substring (startPos, endPos);
            //Now, strNumberFloor contains the actual number to be formatted with commas
            // If it's length is greater than 3, then format it
            if (strNumberFloor.length > 3) {
                // Get the length of the number
                var lenNumber = strNumberFloor.length;
                for (var i = 0; i <= lenNumber; i ++) {
                    //Append proper commans
                    if ((i > 2) && ((i - 1) % 3 == 0)) {
                        formattedNumber = strNumberFloor.charAt (lenNumber - i) + thousandseparator + formattedNumber;
                    }
                    else {
                        formattedNumber = strNumberFloor.charAt (lenNumber - i) + formattedNumber;
                    }
                }
            }
            else {
                formattedNumber = strNumberFloor;
            }

            // Now, append the decimal part back
            if (strDecimalPart != BLANKSTRING) {
                formattedNumber = formattedNumber + decimalseparator + strDecimalPart;
            }
            //Now, if neg num
            if (boolIsNegative == true) {
                formattedNumber = "-" + formattedNumber;
            }

            //Return
            return formattedNumber;
        }

        /**
         * convertNumberSeps method helps us convert the separator (thousands and decimal)
         * character from the user specified input separator characters to normal numeric
         * values that Flash can handle. In some european countries, commas are used as
         * decimal separators and dots as thousand separators. In XML, if the user specifies
         * such values, it will give a error while converting to number. So, we accept the
         * input decimal and thousand separator from user, so thatwe can covert it accordingly
         * into the required format.
         * If the number is still not a valid number after converting the characters, we log
         * the error and return 0.
         * @param num Number in string format containing user defined separator characters.
         * @return Number in numeric format.
         */
        function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
            // Replace the indecimalseparator value with decimal to perform numeric operations
            num = indecimalseparator !== BLANKSTRING ?
            num.toString().replace(indecimalseparator, DECIMALSTRING) : num;

            if (inthousandseparator && inthousandseparator.toString) {
                inthousandseparator = inthousandseparator.toString().replace(/(\W)/ig, '\\$1')
            }

            // Replace the inthousandseparator value with decimal to perform numeric operations
            var re = new RegExp(inthousandseparator, "g");
            num = inthousandseparator !== BLANKSTRING ?
            num.toString().replace(re, BLANKSTRING) : num;

            /* old code: intNum = !strNum && strNum !== false && strNum !== 0 ?
            NaN : Number(strNum); */

            return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
        }
        return NumberFormatter;

    })(),


    ///////// *********Linear Axis Min Max module****** ////////////


    getAxisLimits =(function (){

        var getDivisibleRange =  function  (yMin, yMax, numDivLines, interval, interceptRange)
        {
            //Get the range division for current yMin, yMax and numDivLines
            var range = Math.abs (yMax - yMin);
            var rangeDiv = range / (numDivLines + 1);
            //Now, the range is not divisible
            if ( ! isRangeDivisible (range, numDivLines, interval))
            {
                //We need to get new rangeDiv which can be equally distributed.
                //If intercept range is set to true
                if (interceptRange)
                {
                    //Re-adjust interval so that gap is not much (conditional)
                    //Condition check limit based on value
                    var checkLimit = (interval > 1) ? 2 : 0.5;
                    if ((Number (rangeDiv) / Number (interval)) < checkLimit)
                    {
                        //Decrease power of ten to get closer rounding
                        interval = interval / 10;
                    }
                }
                //Adjust range division based on new interval
                rangeDiv = (Math.floor (rangeDiv / interval) + 1) * interval;
                //Get new range
                range = rangeDiv * (numDivLines + 1);
            }
            //Return range
            return range;
        },

        /**
         * isRangeDivisible method helps us judge whether the given range is
         * perfectly divisible for specified y-interval, numDivLines, yMin and yMax.
         * To check that, we divide the given range into (numDivLines+1) section.
         * If the decimal places of this division value is <= that of interval,
         * that means, this range fits in our purpose. We return a boolean value
         * accordingly.
         *	@param	range		Range of y-axis (Max - Min). Absolute value
         *	@param	numDivLines	Number of div lines to be plotted.
         *	@param	interval	Y-axis Interval (power of ten).
         *	@return			Boolean value indicating whether this range is divisible
         *						by the given number of div lines.
         */
        isRangeDivisible = function (range, numDivLines, interval)
        {
            //Get range division
            var rangeDiv = range / (numDivLines + 1);
            //Now, if the decimal places of rangeDiv and interval do not match,
            //it's not divisible, else it's divisible
            if (numDecimals (rangeDiv) > numDecimals (interval))
            {
                return false;
            } else {
                return true;
            }
        },

        /**
         * numDecimals method returns the number of decimal places provided
         * in the given number.
         *	@param	num	Number for which we've to find the decimal places.
         *	@returns	Number of decimal places found.
         */
        numDecimals = function (num) {
            //Absolute value (to avoid floor disparity for negative num)
            num = Math.abs(num);
            //Convert to string and find the position of dot.
            var strNum = String(num);
            var decimals = 0;
            var dotPos = strNum.indexOf(DECIMALSTRING);
            //See if the number has decimal at all
            if (dotPos!=-1){
                //Find the position of decimal.
                decimals = strNum.length - dotPos - 1;
            }
            //Return the number of decimal digits
            return decimals;
        };



        /**
         * getAxisLimits method helps calculate the axis limits based
         * on the given maximum and minimum value.
         *       @param	maxValue		Maximum numerical value present in data
         *	@param	minValue		Minimum numerical value present in data
         *	@param	stopMaxAtZero	Flag indicating whether maximum value can
         *							be less than 0.
         *	@param	setMinAsZero	Whether to set the lower limit as 0 or a greater
         *	appropriate value (when dealing with positive numbers)
         */

        return function  (maxValue, minValue, yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv) {
            //write the variable which are added as an param in as object
            var yMaxGiven, yMinGiven, yMax, yMin, range, interval;
            //First check if both maxValue and minValue are proper numbers.
            //Else, set defaults as 90,0
            maxValue = (isNaN (maxValue) == true || maxValue == undefined) ? 0.1 : maxValue;
            minValue = (isNaN (minValue) == true || minValue == undefined) ? 0 : minValue;
            //Or, if only 0 data is supplied
            if ((maxValue == minValue) && (maxValue == 0))
            {
                maxValue = 0.1;
            }
            //Defaults for stopMaxAtZero and setMinAsZero
            stopMaxAtZero = typeof stopMaxAtZero === undefined ? true : stopMaxAtZero;
            setMinAsZero = typeof setMinAsZero === undefined ? true : setMinAsZero;
            //Get the maximum power of 10 that is applicable to maxvalue
            //The Number = 10 to the power maxPowerOfTen + x (where x is another number)
            //For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
            //And for 102, it will be 2 = 10^2 + 2
            var maxPowerOfTen = Math.floor (Math.log (Math.abs (maxValue)) / Math.LN10);
            //Get the minimum power of 10 that is applicable to maxvalue
            var minPowerOfTen = Math.floor (Math.log (Math.abs (minValue)) / Math.LN10);
            //Find which powerOfTen (the max power or the min power) is bigger
            //It is this which will be multiplied to get the y-interval
            var powerOfTen = Math.max (minPowerOfTen, maxPowerOfTen);
            var y_interval = Math.pow (10, powerOfTen);
            //For accomodating smaller range values (so that scale doesn't represent too large an interval
            if (Math.abs (maxValue) / y_interval < 2 && Math.abs (minValue) / y_interval < 2)
            {
                powerOfTen --;
                y_interval = Math.pow (10, powerOfTen);
            }
            //If the y_interval of min and max is way more than that of range.
            //We need to reset the y-interval as per range
            var rangePowerOfTen = Math.floor (Math.log (maxValue - minValue) / Math.LN10);
            var rangeInterval = Math.pow (10, rangePowerOfTen);
            //Now, if rangeInterval is 10 times less than y_interval, we need to re-set
            //the limits, as the range is too less to adjust the axis for max,min.
            //We do this only if range is greater than 0 (in case of 1 data on chart).
            if (((maxValue - minValue) > 0) && ((y_interval / rangeInterval) >= 10))
            {
                y_interval = rangeInterval;
                powerOfTen = rangePowerOfTen;
            }
            //Calculate the y-axis upper limit
            var y_topBound = (Math.floor (maxValue / y_interval) + 1) * y_interval;
            //Calculate the y-axis lower limit
            var y_lowerBound;
            //If the min value is less than 0
            if (minValue < 0)
            {
                //Then calculate by multiplying negative numbers with y-axis interval
                y_lowerBound = - 1 * ((Math.floor (Math.abs (minValue / y_interval)) + 1) * y_interval);
            } else {
                //Else, simply set it to 0.
                if (setMinAsZero)
                {
                    y_lowerBound = 0;
                }
                else {
                    y_lowerBound = Math.floor (Math.abs (minValue / y_interval) - 1) * y_interval;
                    //Now, if minValue>=0, we keep x_lowerBound to 0 - as for values like minValue 2
                    //lower bound goes negative, which is not required.
                    y_lowerBound = (y_lowerBound < 0) ?0 : y_lowerBound;
                }
            }
            //MaxValue cannot be less than 0 if stopMaxAtZero is set to true
            if (stopMaxAtZero && maxValue <= 0) {
                y_topBound = 0;
            }
            //Now, we need to make a check as to whether the user has provided an upper limit
            //and lower limit.
            if (yAxisMaxValue == null || yAxisMaxValue == undefined || yAxisMaxValue == BLANKSTRING)
            {
                yMaxGiven = false;
            } else {
                yMaxGiven = true;
            }
            if (yAxisMinValue == null || yAxisMinValue == undefined || yAxisMinValue == BLANKSTRING || isNaN(Number (yAxisMinValue))) {
                yMinGiven = false;
            } else {
                yMinGiven = true;
            }
            //If he has provided it and it is valid, we leave it as the upper limit
            //Else, we enforced the value calculate by us as the upper limit.
            if (yMaxGiven == false || (yMaxGiven == true && Number (yAxisMaxValue) < maxValue))
            {
                yMax = y_topBound;
            } else {
                yMax = Number (yAxisMaxValue);
            }
            //Now, we do the same for y-axis lower limit
            if (yMinGiven == false || (yMinGiven == true && Number (yAxisMinValue) > minValue))
            {
                yMin = y_lowerBound;
            } else {
                yMin = Number (yAxisMinValue);
            }
            //Store axis range
            range = Math.abs (yMax - yMin);
            //Store interval
            interval = y_interval;
            //}




            /**
             * calcDivs method calculates the best div line interval for the given/calculated
             * yMin, yMax, specified numDivLines and adjustDiv.
             * We re-set the y axis min and max value, if both were calculated by our
             * us, so that we get a best value according to numDivLines. The idea is to have equal
             * intervals on the axis, based on numDivLines specified. We do so, only if both yMin and
             * yMax have been calculated as per our values. Else, we adjust the numDiv Lines.
             */
            //function calcDivs ()
            //{
            /**
             * There can be four cases of yMin, yMax.
             * 1. User doesn't specify either. (our program calculates it).
             * 2. User specifies both in XML. (which our program still validates)
             * 3. User specifies only yMin. (we provide missing data)
             * 4. User specifies only yMax. (we provide missing data)
             *
             * Apart from this, the user can specify numDivLines (which if not specified takes a
             * default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
             * adjustDiv works in all four cases (1,2,3,4).
             * Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
             * and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
             * yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
             * is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
             * calculated yMin,yMax so that the given number of div lines can be well adjusted within.
             *
             * In case 2,3,4, we adjust numDivLines so that they space up equally based on the interval
             * and decimals required.
             *
             * So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
             * to accomodate specified number of div lines. In Case 2,3,4, we adjust numDivLines to
             * accomodate within the given limits (y-axis range).
             *
             * numDivLines is always our primary focus when calculating them in all cases. In Case 1,
             * it's kept constant as center of calculation. In Case 2, it's modified to get a best
             * value.
             *
             * Now, for case 1, we can have three sub cases:
             * 1.1. yMax, yMin >=0
             * 1.2. yMin, yMax <=0
             * 1.3. yMax > 0 and yMin <0.
             * Case 1.1 and 1.2 are simple, as we just need to adjust the range between two positive
             * or two negative numbers such that the range can be equally divided into (numDivLines+1)
             * division.
             * Case 1.3 is tricky, as here, we additionally need to make sure that 0 plane is included
             * as a division.
             * We use two different methods to solved Case 1.1,1.2 and Case 1.3.
             * Note that in all Cases (1.1, 1.2 & 1.3), we adjust the auto-calculated yMax and yMin
             * to get best div line value. We do NOT adjust numDivLines here.
             */
            //Check condition for case 1 first - limits not specified and adjustDiv is true
            if (yMinGiven == false && yMaxGiven == false && adjustDiv == true)
            {
                //Means neither chart max value nor min value has been specified and adjustDiv is true
                //Now, if it's case 1.3 (yMax > 0 & yMin <0)
                if (yMax > 0 && yMin < 0)
                {
                    //Case 1.3
                    /**
                     * Here, in this case, we start by generating the best fit range
                     * for the given yMin, yMax, numDivLines and interval. We generate
                     * range by adding sequential increments (rangeDiv * (ND+1) * interval).
                     * Interval has been adjusted to smaller interval for larger values.
                     * Now, for each divisible range generated by the program, we adjust the
                     * yMin and yMax to check if 0 can land as a division in between them on
                     * a proper distance.
                     * We divide the y-axis range into two parts - small arm and big arm.
                     * Say y-axis range is from 1 to -5. So, small arm is 1 and big arm is -5.
                     * Or, if its from 16 to -3, small arm is -3 and big arm is 16.
                     * Now, we try and get a value for extended small arm, which is multiple
                     * of rangeDiv. Say chart min,max is 16,-3. So range becomes 19.
                     * Let's assume numDivLines to be 2. So for 2 numDivLines, we get closest
                     * adjusted range value as 21. Delta range = 21 - 19 (original range) = 2
                     * Also, range division value = 21 / (ND + 1) = 21 / 3 = 7
                     * We now get values for extended small arm as i*range division, where i
                     * runs from 1 to (numDivLines+1)/2. We go only halfway as it's the smaller
                     * arm and so cannot extend to a division beyond half way - else it would have
                     * been the bigger arm.
                     * So, first extended small arm = -7 * 1 = -7.
                     * We get the difference between extended small arm and original small arm.
                     * In this case it's 7 - 3 = 4 (all absolute values now - to avoid sign disparities).
                     * We see that delta arm > delta range. So, we ignore this range and get a new range.
                     * So, next range comes as = prev Range (21) + (numDivLines + 1)*interval
                     * = 21 + (2+1)*1 = 24
                     * Since the increment is sequential as a multiplication factor of
                     * (numDivLines + 1)*interval, it is also a valid divisible range.
                     * So we again check whether 0 can appear as a division. In this case, we
                     * get rangeDiv as 8 and extended smaller arm as 8. For this extended smaller
                     * arm, we get bigger arm as 16. Both of these are divisible by rangeDiv. That
                     * means, this range can include 0 as division line. So, we store it and proceed.
                     */
                    //Flag to indicate whether we've found the perfect range or not.
                    var found = false;
                    //We re-calculate the interval to get smaller increments for large values.
                    //For example, for 300 to -100 (with ND as 2), if we do not adjust interval, the min
                    //max come as -200, 400. But with adjusted intervals, it comes as -150, 300, which is
                    //more appropriate.
                    var adjInterval = (interval > 10) ? (interval / 10) : interval;
                    //Get the first divisible range for the given yMin, yMax, numDivLines and interval.
                    //We do not intercept and adjust interval for this calculation here.
                    var rangeD = getDivisibleRange (yMin, yMax, numDivLines, adjInterval, false);
                    //Now, deduct delta range from nextRange initially, so that in while loop,
                    //there's a unified statement for increment instead of 2 checks.
                    var nextRange = rangeD - (numDivLines + 1) * (adjInterval);
                    //Range division
                    var rangeDiv;
                    //Delta in range
                    var deltaRange;
                    //Multiplication factor
                    var mf;
                    //Smaller and bigger arm of y-axis
                    var smallArm, bigArm;
                    //Exntended small and big arm
                    var extSmallArm, extBigArm;
                    //Loop variable
                    var i;
                    //Now, we need to search for a range which is divisible in (numDivLines+1)
                    //segments including 0. Run a while loop till that is found.
                    while (found == false)
                    {
                        //Get range
                        nextRange = nextRange + (numDivLines + 1) * (adjInterval);
                        //If it's divisible for the given range and adjusted interval, proceed
                        if (isRangeDivisible (nextRange, numDivLines, adjInterval))
                        {
                            //Delta Range
                            deltaRange = nextRange - range;
                            //Range division
                            rangeDiv = nextRange / (numDivLines + 1);
                            //Get the smaller arm of axis
                            smallArm = Math.min (Math.abs (yMin) , yMax);
                            //Bigger arm of axis.
                            bigArm = range - smallArm;
                            //Get the multiplication factor (if smaller arm is negative, set -1);
                            mf = (smallArm == Math.abs (yMin)) ? - 1 : 1;
                            //If num div lines ==0, we do not calculate anything
                            if (numDivLines == 0)
                            {
                                //Set flag to true to exit loop
                                found = true;
                            } else {
                                //Now, we need to make sure that the smaller arm of axis is a multiple
                                //of rangeDiv and the multiplied result is greater than smallArm.
                                for (i = 1; i <= Math.floor ((numDivLines + 1) / 2); i ++)
                                {
                                    //Get extended small arm
                                    extSmallArm = rangeDiv * i;
                                    //If extension is more than original intended delta, we move to next
                                    //value of loop as this range is smaller than our intended range
                                    if ((extSmallArm - smallArm) > deltaRange)
                                    {
                                        //Iterate to next loop value
                                        continue;
                                    }
                                    //Else if extended arm is greater than smallArm, we do the 0 div test
                                    if (extSmallArm > smallArm)
                                    {
                                        //Get extended big arm
                                        extBigArm = nextRange - extSmallArm;
                                        //Check whether for this range, 0 can come as a div
                                        //By checking whether both extBigArm and extSmallArm
                                        //are perfectly divisible by rangeDiv
                                        if (((extBigArm / rangeDiv) == (Math.floor (extBigArm / rangeDiv))) && ((extSmallArm / rangeDiv) == (Math.floor (extSmallArm / rangeDiv))))
                                        {
                                            //Store in global containers
                                            range = nextRange;
                                            yMax = (mf == - 1) ? extBigArm : extSmallArm;
                                            yMin = (mf == - 1) ? ( - extSmallArm) : ( - extBigArm);
                                            //Set found flag to true to exit loop
                                            found = true;
                                        }
                                    } else {
                                        //Iterate to next loop value, as we need the arm to be greater
                                        //than original value.
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    //Case 1.1 or 1.2
                    /**
                     * In this case, we first get apt divisible range based on yMin, yMax,
                     * numDivLines and the calculated interval. Thereby, get the difference
                     * between original range and new range and store as delta.
                     * If yMax>0, add this delta to yMax. Else substract from yMin.
                     */
                    //Get the adjusted divisible range
                    var adjRange = getDivisibleRange (yMin, yMax, numDivLines, interval, true);
                    //Get delta (Calculated range minus original range)
                    var deltaRange = adjRange - range;
                    //Update global range storage
                    range = adjRange;
                    //Now, add the change in range to yMax, if yMax > 0, else deduct from yMin
                    if (yMax > 0)
                    {
                        yMax = yMax + deltaRange;
                    } else {
                        yMin = yMin - deltaRange;
                    }
                }
            } else {
                /**
                 * Here, we've to handle the following cases
                 * 2. User specifies both yMin, yMax in XML. (which our program still validates)
                 * 3. User specifies only yMin. (we provide yMax)
                 * 4. User specifies only yMax. (we provide yMin)
                 * Now, for each of these, there can be two cases. If the user has opted to
                 * adjust div lines or not. If he has opted to adjustDiv, we calculate the best
                 * possible number of div lines for the given range. If not, we simply divide
                 * the given (or semi-calculated) axis limits by the number of div lines.
                 */
                if (adjustDiv == true)
                {
                    //We iterate from given numDivLines to 0,
                    //Count helps us keep a counter of how many div lines we've checked
                    //For the sake of optimization, we check only 25 div lines values
                    //From (numDivLines to 0) and (numDivLines to (25-numDivLines))
                    //We do it in a yoyo order - i.e., if numDivLines is set as 5,
                    //we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
                    //(11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
                    //17,18,19,20. So, in this way, we check for 25 possible numDivLines and
                    //see if any one them fit in. If yes, we store that value. Else, we set it
                    //as 0 (indicating no div line feasible for the given value).
                    //Perform only if numDivLines>0
                    if (numDivLines > 0)
                    {
                        var counter = 0;
                        var multiplyFactor = 1;
                        var divLines;
                        while (1)
                        {
                            //Increment,Decrement numDivLines
                            divLines = numDivLines + (counter * multiplyFactor);
                            //Cannot be 0
                            divLines = (divLines == 0) ? 1 : divLines;
                            //Check whether this number of numDivLines satisfy our requirement
                            if (isRangeDivisible (range, divLines, interval))
                            {
                                //Exit loop
                                break;
                            }
                            //Each counter comes twice: one for + count, one for - count
                            counter = (multiplyFactor == - 1 || (counter > numDivLines)) ? ( ++ counter) : (counter);
                            if (counter > 25)
                            {
                                //We do not go beyond 25 count to optimize.
                                //If the loop comes here, it means that divlines
                                //counter is not able to achieve the target.
                                //So, we assume no div lines are possible and exit.
                                divLines = 0;
                                break;
                            }
                            //Switch to increment/decrement mode. If counter
                            multiplyFactor = (counter <= numDivLines) ? (multiplyFactor * - 1) : (1);
                        }
                        //Store the value in params
                        numDivLines = divLines;
                    }
                } else
{
            //Div lines intevals need to formatted to the given precision.
            }
            }
            /*	//Set flags pertinent to zero plane
                    if (yMax > 0 && yMin < 0)
                    {
                            zeroPRequired = true;
                    } else
                    {
                            zeroPRequired = false;
                    }*/
            //Div interval
            var divInterval = (yMax - yMin) / (numDivLines + 1);
            /*	//Flag to keep a track whether zero plane is included
                    zeroPIncluded = false;
                    //We now need to store all the div line segments in the array this.divLines
                    //We include yMin and yMax too in div lines to render in a single loop
                    var divLineValue = yMin - divInterval;
                    //Keeping a count of div lines
                    var count = 0;
                    while (count <= (numDivLines + 1))
                    {
                            //Converting to string and back to number to avoid Flash's rounding problems.
                            divLineValue = Number (String (divLineValue + divInterval));
                            //Check whether zero plane is included
                            zeroPIncluded = (divLineValue == 0) ? true : zeroPIncluded;
                            //Add the div line to this.divLines
                            this.divLines [count] = this.returnDataAsDivLine (divLineValue);
                            //Based on yAxisValueStep, we need to hide required div line values
                            if (count % yAxisValuesStep == 0)
                            {
                                    divLines [count].showValue = true;
                            } else
                            {
                                    divLines [count].showValue = false;
                            }
                            //Increment counter
                            count ++;
                    }
                    //Now, the array this.divLines contains all the divisional values. But, it might
                    //not contain 0 value in Case 2,3,4 (i.e., when the user manually sets things).
                    //So, if zero plane is required but not included, we include it.
                    if (zeroPRequired == true && zeroPIncluded == false)
                    {
                            //Include zero plane at the right place in the array.
                            divLines.push (returnDataAsDivLine (0));
                            //Now, sort on value so that 0 automatically appears at right place
                            divLines.sortOn ("value", Array.NUMERIC);
                            //Also increase numDivLines
                            numDivLines ++;
                    }
                    //We finally have the sorted div lines in this.divLines		*/

            //////fix of error in highcharts for infinite loop
            divInterval = divInterval;

            return {
                Max: yMax,
                Min: yMin,
                Range: range,
                interval: interval,
                divGap: divInterval
            };

        };
    })(),

    //HC compatiable JSON to Show a message in Chart
    //store blank Chart to show message
    ///special configuration
    
    //then we have to implement the font style also
    createDialog =  (function () {

        var api = function (container, text) {
            this.title.y = container.offsetHeight / 2;
            if (text !== undefined) {
                this.title.text = text;
            }
        };

        api.prototype = {//jsonstructutr for a blank chart which will be used to show a messege
            chart: {
                events: {},
                margin: [0, 0, 0, 0]
            },
            credits: {
                href: 'http://www.fusioncharts.com?BS=FCHSEvalMark',
                text: 'FusionCharts',
                enabled: true
            },
            legend: {
                enabled: false
            },
            title: {
                text: 'Chart Placeholder',
                style: {
                    fontFamily: 'Verdana',
                    fontSize:  '10px',
                    color: '#666666'
                }
            },
            plotOptions: {
                series: {}
            },
            series : [],
            exporting: {
                enabled: false
            }
        };

        return api.prototype.constructor = api;
    })(),



    /**
     * This object allows to make decision as to where to position the label
     * based on certain decisions. This pre-decision saves on a small amount
     * of computation time per trenline.
     * @example
     * trendLineLabelPosition[startValue > endValue][!!isOnOppositeAxis]
     */
    trendLineLabelPosition = {
        // Relative value position: start > end
        'true': {
            // Axis oppositality
            'true': POSITION_BOTTOM,
            'false': POSITION_TOP
        },
        'false': {
            // Axis oppositality
            'true': POSITION_TOP,
            'false': POSITION_BOTTOM
        }
    },



    //Function to insart trend Line
    
    
    
    //NOTE: valueonright & parentyaxis booth will work for all chart
    createTrendLine = (function () {
        var regStringStest = /^s$/i,
        diffTrendCOLOR_SRT = '333333',
        getLabelConfig = function() {
            var point = this;
            return {
                x: point.category,
                y: point.y,
                series: point.series,
                point: point,
                percentage: point.percentage,
                total: point.total || point.stackTotal
            };
        },
        getTooltipEvent = function (toolText) {
            var toolTipPointObj, toolTextEvent;
            toolTipPointObj = {
                series : {},
                chart : this.chart,
                id : this.id,
                label : this.label,
                options : this.options,
                svgElm : this.svgElm,
                toolText: toolText,
                getLabelConfig : getLabelConfig
            };
            toolTextEvent = {
                mouseover: function(e) {
                    var plotLeft = this.chart.plotLeft,
                    plotTop = this.chart.plotTop;
                    toolTipPointObj.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                    //show the tooltext
                    this.chart.tooltip.refresh(toolTipPointObj);
                },
                mousemove: function(e) {
                    var plotLeft = this.chart.plotLeft,
                    plotTop = this.chart.plotTop;
                    toolTipPointObj.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                    //show the tooltext
                    this.chart.tooltip.refresh(toolTipPointObj);
                },
                mouseout: function (e) {
                    //hide the tooltip
                    this.chart.tooltip.hide();
                }
            }
            return toolTextEvent;
        };
        return function (trendObj, axis, hcConf, isDY, isBar, isVtrend) {
            var x,
            trendStyle = hcConf.trendStyle,
            z,
            l,
            m,
            trendLineObj,
            isOpp,
            isZone,
            displayvalue,
            trendLabelObj,
            toolTextEvent,
            toolText,
            labelColor,
            axisObj,
            width,
            trendStartValue,
            trendEndValue,
            max, min,
            toolTipPointObj,
            halfFontSize = (parseInt(trendStyle.fontSize, 10) / 2) + 2;//a tolerance of 2 pixel present in HC

            for (x = 0, l = trendObj.length; x < l; x += 1) {
                if (trendObj[x].line) {
                    for (z = 0, m = trendObj[x].line.length; z < m; z += 1) {

                        trendLineObj = trendObj[x].line[z];
                        trendStartValue = pluckNumber(trendLineObj.startvalue,
                            trendLineObj.value, 0);
                        trendEndValue = pluckNumber(trendLineObj.endvalue,
                            trendStartValue);

                        //check which axis object will be added
                        if (isVtrend) {
                            axisObj = axis;
                        }
                        else if (isDY && trendLineObj.parentyaxis && regStringStest.test(trendLineObj.parentyaxis)) {
                            axisObj = axis[1];
                        }
                        else {
                            axisObj = axis[0];
                        }
                        max = axisObj.max;
                        min = axisObj.min;
                        if (max >= trendStartValue && max >= trendEndValue && min <= trendStartValue && min <= trendEndValue) {

                            if (trendLineObj.parentyaxis && regStringStest.test(trendLineObj.parentyaxis)) {
                                isOpp = trendLineObj.valueonleft !== ONESTRING;
                            }
                            else {
                                isOpp = trendLineObj.valueonright === ONESTRING;
                            }
                            /*isOpp = (trendLineObj.valueonright === ONESTRING ||
                                (trendLineObj.parentyaxis && regStringStest.test(trendLineObj.parentyaxis))) ? true : false;*/

                            // Calculate from input values whether the object would
                            // be trendline or trendzone
                            isZone = Boolean(pluckNumber(trendLineObj.istrendzone, isVtrend ? 1 : 0));

                            //if there has a display value the create it
                            displayvalue = parseUnsafeString(pluck(trendLineObj.displayvalue,
                                hcConf.numberFormatter[isVtrend ? 'xAxis' : 'dataLabels'](trendStartValue)));

                            if (displayvalue) {
                                trendLabelObj = {
                                    text: displayvalue,
                                    textAlign: isBar ? POSITION_CENTER : (isOpp ? POSITION_LEFT : POSITION_RIGHT),
                                    align: isBar ? (isZone ? POSITION_CENTER :
                                        (trendStartValue < trendEndValue ? POSITION_RIGHT : POSITION_LEFT)) :
                                        (isOpp ? POSITION_RIGHT : POSITION_LEFT),
                                    verticalAlign: isBar ? POSITION_BOTTOM : (isZone ? POSITION_MIDDLE :
                                    (trendLineLabelPosition[trendStartValue > trendEndValue][isOpp])),
                                    rotation: 0,
                                    x: 0,
                                    y: isBar ? halfFontSize : 2,
                                    style: extend2(trendStyle)
                                }
                                labelColor = pluck(trendLineObj.color, diffTrendCOLOR_SRT);
                                trendLineObj.alwaysVisible = isZone; // always show zones (even if 0 width)
                                if (labelColor) {
                                    trendLabelObj.style.color  = labelColor.replace(dropHash, HASHSTRING);
                                }
                            }
                            else {
                                trendLabelObj = undefined;
                            }
                            //add options for tooltext
                            toolText = pluck(trendLineObj.tooltext)
                            if (toolText !== undefined) {
                                toolTextEvent = getTooltipEvent(toolText);
                            }
                            else {
                                toolTextEvent = undefined;
                            }

                            width = pluckNumber(trendLineObj.thickness, 1)

                            if (isZone) {
                                axisObj.plotBands.push({
                                    isTrend : true,
                                    color: convertColor(pluck(trendLineObj.color, diffTrendCOLOR_SRT), pluck(trendLineObj.alpha, 40)),
                                    from: trendStartValue,
                                    to: trendEndValue,
                                    label: trendLabelObj,
                                    //for 3d series never will be on top
                                    zIndex : !hcConf.is3d && trendLineObj.showontop === ONESTRING ? 5 : 3,
                                    events: toolTextEvent,
                                    tooltext : toolText,
                                    alwaysVisible: trendLineObj.alwaysVisible
                                });
                            }
                            else {
                                axisObj.plotLines.push({
                                    isTrend : true,
                                    color: convertColor(pluck(trendLineObj.color, diffTrendCOLOR_SRT), pluck(trendLineObj.alpha, 99)),
                                    value: trendStartValue,
                                    to: trendEndValue,
                                    width: width,
                                    dashStyle : trendLineObj.dashed == ONESTRING ? getDashStyle(pluckNumber(trendLineObj.dashlen, 5), pluckNumber(trendLineObj.dashgap, 2), width) : undefined,
                                    label: trendLabelObj,
                                    //for 3d series never will be on top
                                    zIndex : !hcConf.is3d && trendLineObj.showontop === ONESTRING ? 5 : 3,
                                    events: toolTextEvent,
                                    tooltext : toolText
                                });
                            }
                        }
                    }
                }
            }
        }
    })(),


    //Function to convert FC dash style to HC dash style
    
    getDashStyle = function (dashLen, dashGap, thickness, lineDashed) {
        if (lineDashed || lineDashed === undefined) {
            thickness = thickness ? thickness : 1;
            return (pluckNumber(dashLen, 5) / thickness) + COMMASTRING + (pluckNumber(dashGap, 3) / thickness);
        }
        else {
            return undefined;
        }
    },



    /**
     * Internally used to create a chart api store. Creating chart api store in
     * this way (instead of just creating a new object,) allows us to easily
     * identify whether an object is part of chartAPI or not.
     * @constructor
     * @private
     */
    ChartAPIItem = function () { },

    /**
     * Function to define chart-api and configuration. This has to be used to
     * define the configuration of various chart types.
     *
     * @param {string} type specifies the name of the chart/series for which
     * the API has to be set.
     *
     * @paran {object} api is the key-value pair that defines various object.
     *
     * @param {ChartAPIItem} parent refers to the possibility of inheriting this
     * new chart from an existing chart.
     *
     * @type object
     * @return The chartAPI created from the mapping api provided.
     *
     * @code
     * chartAPI('column', {
     *     series: {
     *         sample: function () { return 'column.series.sample'; }
     *     },
     *     point: function () {};
     * });
     * var column2d = chartAPI('column2d', {
     *     series: 'column'
     * });
     *
     * column2d.series.sample2 = function () {
     *     return 'column2d.series.sample2';
     * };
     *
     * // Also be accessed as:
     * chartAPI.column.point();
     */
    chartAPI = function (type, api, parent) {
        var item,
        typeAPI = chartAPI[type],
        newTypeAPI,
        IAPIInterface;

        // If the object that holds the chart API is not already defined,
        // then we set the api to a blank object.
        if (!typeAPI) {
            IAPIInterface = function () { };
            // If a parent APIItem is specified, we set the prototype of the new
            // item as the parent.
            IAPIInterface.prototype = parent instanceof ChartAPIItem ?
            parent : new ChartAPIItem();
            IAPIInterface.prototype.constructor = IAPIInterface;
            typeAPI = chartAPI[type] = new IAPIInterface();
        }

        // Set the base api
        if (parent) {
            typeAPI.base = parent;
        }
        // Set the type name
        typeAPI.name = type;

        // Now we loop through the entire set of groups (immediate sibling)
        // in the API and depending upon its type, we perform various actions.
        for (item in api) {
            switch (typeof api[item]) {
                // If the value is string, we know it is an instruction to
                // inherit the object from the typeName specified as value.
                case OBJECTSTRING:
                    if (api[item] instanceof ChartAPIItem) {
                        typeAPI[item] = api[item][item];
                        break;
                    }

                // Otherwise we know that we are to simply set the API as
                // provided.
                default:
                    typeAPI[item] = api[item];
                    break;

                // In case the value is undefined, we know that the instruction
                // is to delete that API item.
                case STRINGUNDEFINED:
                    delete typeAPI[item];
                    break;

            }
        }

        // If a new instance is wanted, create one and return
        if (this instanceof chartAPI) {
            newTypeAPI = function () { };
            newTypeAPI.prototype = typeAPI;
            newTypeAPI.prototype.constructor = newTypeAPI;
            return new newTypeAPI();
        }
        else {
            // Return the resultant chart API created from the above algorithm.
            return typeAPI;
        }
    };

    // Add HighCharts global library
    global.extend(global.hcLib, {
        BLANKSTRINGPLACEHOLDER: BLANKSTRINGPLACEHOLDER,
        BLANKSTRING: BLANKSTRING,
        COLOR_BLACK: COLOR_BLACK,
        COLOR_WHITE: COLOR_WHITE,
        COLOR_TRANSPARENT : COLOR_TRANSPARENT,
        HASHSTRING: HASHSTRING,
        BREAKSTRING: BREAKSTRING,
        STRINGSTRING: STRINGSTRING,
        OBJECTSTRING: OBJECTSTRING,
        COMMASTRING: COMMASTRING,
        ZEROSTRING : ZEROSTRING,
        SAMPLESTRING : 'Ay0',
        TESTSTR : TESTSTR,
        ONESTRING : ONESTRING,
        DECIMALSTRING : DECIMALSTRING,
        STRINGUNDEFINED: STRINGUNDEFINED,
        POSITION_TOP  : POSITION_TOP,
        POSITION_RIGHT  : POSITION_RIGHT,
        POSITION_BOTTOM  : POSITION_BOTTOM,
        POSITION_LEFT  : POSITION_LEFT,
        POSITION_CENTER : POSITION_CENTER,
        POSITION_MIDDLE : POSITION_MIDDLE,
        FC_CONFIG_STRING : FC_CONFIG_STRING,
        HUNDREDSTRING : HUNDREDSTRING,
        PXSTRING : PXSTRING,
        COMMASPACE : COMMASPACE,

        regex: {
            stripWhitespace: stripWhitespace,
            dropHash: dropHash,
            startsRGBA: startsRGBA,
            cleanColorCode: cleanColorCode,
            breakPlaceholder: breakPlaceholder,
            hexcode : hexcode
        },

        extend2: extend2,

        pluck: pluck,
        pluckNumber: pluckNumber,
        pluckFontSize: pluckFontSize,
        getValidValue: getValidValue,
        getDefinedColor: getDefinedColor,
        getFirstValue: getFirstValue,
        getFirstColor: getFirstColor,
        getColorCodeString: getColorCodeString,
        pluckColor: pluckColor,
        getFirstAlpha: getFirstAlpha,
        parsePointValue: parsePointValue,
        parseUnsafeString: parseUnsafeString,
        toPrecision: toPrecision,
        stubFN : function () {},
        falseFN : function () {
            return false
        },
        hasSVG : hasSVG,

        getLinkAction : getLinkAction,


        graphics: {
            parseAlpha: parseAlpha,
            convertColor: convertColor,
            getDarkColor : getDarkColor,
            getLightColor : getLightColor,
            mapSymbolName: mapSymbolName,
            getColumnColor : getColumnColor,
            getAngle : getAngle,
            parseColor: parseColor
        },

        setImageDisplayMode: setImageDisplayMode,
        SmartLabelManager: SmartLabelManager,
        setLineHeight : setLineHeight,
        NumberFormatter: NumberFormatter,
        getAxisLimits : getAxisLimits,
        createTrendLine : createTrendLine,
        getDashStyle : getDashStyle,
        axisLabelAdder : axisLabelAdder,

        chartAPI: chartAPI,
        createDialog: createDialog,


        defaultPaletteOptions: {
            //Palette color arrays
            // ------------- For 2D Chart ---------------//
            bgColor : ["CBCBCB,E9E9E9", "CFD4BE,F3F5DD", "C5DADD,EDFBFE", "A86402,FDC16D", "FF7CA0,FFD1DD"],
            bgAngle : [270, 270, 270, 270, 270],
            bgRatio : [BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING],
            bgAlpha : ["50,50", "60,50", "40,20", "20,10", "30,30"],
            canvasBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            canvasBgAngle : [0, 0, 0, 0, 0],
            canvasBgAlpha : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            canvasBgRatio : [BLANKSTRING, BLANKSTRING, BLANKSTRING, BLANKSTRING, BLANKSTRING],
            canvasBorderColor : ["545454", "545454", "415D6F", "845001", "68001B"],
            canvasBorderAlpha : [100, 100, 100, 90, 100],
            showShadow : [0, 1, 1, 1, 1],
            divLineColor : ["717170", "7B7D6D", "92CDD6", "965B01", "68001B"],
            divLineAlpha : [40, 45, 65, 40, 30],
            altHGridColor : ["EEEEEE", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            altHGridAlpha : [50, 35, 10, 20, 15],
            altVGridColor : ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            altVGridAlpha : [10, 20, 10, 15, 10],
            anchorBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor : ["545454", "545454", "415D6F", "845001", "68001B"],
            baseFontColor : ["555555", "60634E", "025B6A", "A15E01", "68001B"],
            borderColor : ["767575", "545454", "415D6F", "845001", "68001B"],
            borderAlpha : [50, 50, 50, 50, 50],
            legendBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            legendBorderColor : ["545454", "545454", "415D6F", "845001", "D55979"],
            plotGradientColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotBorderColor : ["333333", "8A8A8A", COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotFillColor : ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"],
            // -------------- For 3D Chart --------------//
            bgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            bgAlpha3D : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            bgAngle3D : [90, 90, 90, 90, 90],
            bgRatio3D : [BLANKSTRING, BLANKSTRING, BLANKSTRING, BLANKSTRING, BLANKSTRING],
            canvasBgColor3D : ["DDE3D5", "D8D8D7", "EEDFCA", "CFD2D8", "FEE8E0"],
            canvasBaseColor3D : ["ACBB99", "BCBCBD", "C8A06C", "96A4AF", "FAC7BC"],
            divLineColor3D : ["ACBB99", "A4A4A4", "BE9B6B", "7C8995", "D49B8B"],
            divLineAlpha3D : [100, 100, 100, 100, 100],
            legendBgColor3D : ["F0F3ED", "F3F3F3", "F7F0E8", "EEF0F2", "FEF8F5"],
            legendBorderColor3D : ["C6CFB8", "C8C8C8", "DFC29C", "CFD5DA", "FAD1C7"],
            toolTipbgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor3D : ["49563A", "666666", "49351D", "576373", "681C09"],
            baseFontColor3D : ["49563A", "4A4A4A", "49351D", "48505A", "681C09"],
            anchorBgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE]
        }
    });
}());


/**
 * Modified version of jQuery.event.drag from original code by FusionCharts.
 * All third-party attributions implied.
 */
(function( $ ){

    // add the jquery instance method
    $.fn.drag = function( str, arg, opts ){
        // figure out the event type
        var type = typeof str == "string" ? str : "",
        // figure out the event handler...
        fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
        // fix the event type
        if ( type.indexOf("drag") !== 0 )
            type = "drag"+ type;
        // were options passed
        opts = ( str == fn ? arg : opts ) || {};
        // trigger or bind event handler
        return fn ? this.bind( type, opts, fn ) : this.trigger( type );
    };

    // local refs (increase compression)
    var $event = $.event,
    hasTouch = 'ontouchstart' in document.documentElement,
    initBindings = hasTouch ? 'touchstart' : 'mousedown',
    dragBindings = hasTouch ? 'touchmove touchend' : 'mousemove mouseup',
    touchEventXY = function (event, dd) {
        if (!dd.touchXY || !event.originalEvent) {
            return event;
        }

        // check whether mouse click or screentap
        var touches = event.originalEvent.changedTouches ||
        event.originalEvent.touches;
        if (touches && touches.length) {
            $.extend(event, touches[0]);
        }
        return event;
    },

    $special = $event.special,
    // configure the drag special event
    drag = $special.drag = {

        // these are the default settings
        defaults: {
            which: 1, // mouse button pressed to start drag sequence
            distance: 0, // distance dragged before dragstart
            not: ':input', // selector to suppress dragging on target elements
            handle: null, // selector to match handle target elements
            relative: false, // true to use "position", false to use "offset"
            drop: false, // false to suppress drop events, true or selector to allow
            click: false, // false to suppress click events after dragend (no proxy)
            touchXY: true // Make touch XY match event XY
        },

        // the key name for stored drag data
        datakey: "dragdata",

        // the namespace for internal live events
        livekey: "livedrag",

        // count bound related events
        add: function( obj ){
            // read the interaction data
            var data = $.data( this, drag.datakey ),
            // read any passed options
            opts = obj.data || {};
            // count another realted event
            data.related += 1;
            // bind the live "draginit" delegator
            if ( !data.live && obj.selector ){
                data.live = true;
                $event.add( this, "draginit."+ drag.livekey, drag.delegate );
            }
            // extend data options bound with this event
            // don't iterate "opts" in case it is a node
            $.each( drag.defaults, function( key, def ){
                if ( opts[ key ] !== undefined )
                    data[ key ] = opts[ key ];
            });
        },

        // forget unbound related events
        remove: function(){
            $.data( this, drag.datakey ).related -= 1;
        },

        // configure interaction, capture settings
        setup: function(){
            // check for related events
            if ( $.data( this, drag.datakey ) )
                return;
            // initialize the drag data with copied defaults
            var data = $.extend({
                related:0
            }, drag.defaults );
            // store the interaction data
            $.data( this, drag.datakey, data );
            // bind the mousedown event, which starts drag interactions
            $event.add( this, initBindings, drag.init, data );
            // prevent image dragging in IE...
            if ( this.attachEvent )
                this.attachEvent("ondragstart", drag.dontstart );
        },

        // destroy configured interaction
        teardown: function(){
            // check for related events
            if ( $.data( this, drag.datakey ).related )
                return;
            // remove the stored data
            $.removeData( this, drag.datakey );
            // remove the mousedown event
            $event.remove( this, initBindings, drag.init );
            // remove the "live" delegation
            $event.remove( this, "draginit", drag.delegate );
            // enable text selection
            drag.textselect( true );
            // un-prevent image dragging in IE...
            if ( this.detachEvent )
                this.detachEvent("ondragstart", drag.dontstart );
        },

        // initialize the interaction
        init: function( event ){
            // the drag/drop interaction data
            var dd = event.data, results,
            touches = event.originalEvent ? event.originalEvent.changedTouches ||
            event.originalEvent.touches : [];

            // check whether mouse click or screentap
            if (touches && touches.length) {
                // let the system handle multitouch operations like two finger scroll
                // and pinching
                if (touches.length > 1) {
                    return;
                }
            }
            else {
                // check the which directive
                if ( dd.which > 0 && event.which != dd.which ) {
                    return;
                }
            }

            // check for suppressed selector
            if ( $( event.target ).is( dd.not ) )
                return;
            // check for handle selector
            if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length )
                return;
            // store/reset some initial attributes
            dd.propagates = 1;
            dd.interactions = [ drag.interaction( this, dd ) ];
            dd.target = event.target;
            dd.pageX = event.pageX;
            dd.pageY = event.pageY;
            dd.dragging = null;
            // handle draginit event...
            results = drag.hijack( event, "draginit", dd );
            //if ()
            // early cancel
            if ( !dd.propagates )
                return;
            // flatten the result set
            results = drag.flatten( results );
            // insert new interaction elements
            if ( results && results.length ){
                dd.interactions = [];
                $.each( results, function(){
                    dd.interactions.push( drag.interaction( this, dd ) );
                });
            }
            // remember how many interactions are propagating
            dd.propagates = dd.interactions.length;
            // locate and init the drop targets
            if ( dd.drop !== false && $special.drop )
                $special.drop.handler( event, dd );
            // disable text selection
            drag.textselect( false );
            // bind additional events...
            $event.add( document, dragBindings, drag.handler, dd );
            // helps prevent text selection
            if (!hasTouch) {
                return false;
            }
        },
        // returns an interaction object
        interaction: function( elem, dd ){
            return {
                drag: elem,
                callback: new drag.callback(),
                droppable: [],
                offset: $( elem )[ dd.relative ? "position" : "offset" ]() || {
                    top:0,
                    left:0
                }
            };
        },
        // handle drag-releatd DOM events
        handler: function( event ){
            // read the data before hijacking anything
            var dd = event.data;
            // mousemove, check distance, start dragging
            if (!dd.dragging && (event.type === 'mousemove' || event.type === 'touchmove')) {
                //  drag tolerance, x + y = distance
                if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) )
                    return; // distance tolerance not reached
                event.target = dd.target; // force target from "mousedown" event (fix distance issue)
                drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
                if ( dd.propagates ) // "dragstart" not rejected
                    dd.dragging = true; // activate interaction
            }
            // handle various events
            switch ( event.type ){
                // mousemove, dragging
                case 'touchmove':
                    // prevent touch device screen scrolling.
                    if (dd.dragging) {
                        event.preventDefault();
                        touchEventXY(event, dd);
                    }

                case 'mousemove':
                    if ( dd.dragging ){
                        // trigger "drag"
                        drag.hijack( event, "drag", dd );
                        if ( dd.propagates ){
                            // manage drop events
                            if ( dd.drop !== false && $special.drop )
                                $special.drop.handler( event, dd ); // "dropstart", "dropend"
                            break; // "drag" not rejected, stop
                        }
                        event.type = "mouseup"; // helps "drop" handler behave
                    }
                // mouseup, stop dragging
                case 'mouseup':
                case 'touchend':
                    $event.remove( document, dragBindings, drag.handler ); // remove page events
                    if ( dd.dragging ){
                        if ( dd.drop !== false && $special.drop )
                            $special.drop.handler( event, dd ); // "drop"
                        drag.hijack( event, "dragend", dd ); // trigger "dragend"
                    }
                    drag.textselect( true ); // enable text selection

                    // if suppressing click events...
                    if ( dd.click === false && dd.dragging ){
                        jQuery.event.triggered = true;
                        setTimeout(function(){
                            jQuery.event.triggered = false;
                        }, 20 );
                        dd.dragging = false; // deactivate element
                    }
                    break;
            }
        },

        // identify potential delegate elements
        delegate: function( event ){
            // local refs
            var elems = [], target,
            // element event structure
            events = $.data( this, "events" ) || {};
            // query live events
            $.each( events.live || [], function( i, obj ){
                // no event type matches
                if ( obj.preType.indexOf("drag") !== 0 )
                    return;
                // locate the element to delegate
                target = $( event.target ).closest( obj.selector, event.currentTarget )[0];
                // no element found
                if ( !target )
                    return;
                // add an event handler
                $event.add( target, obj.origType+'.'+drag.livekey, obj.origHandler, obj.data );
                // remember new elements
                if ( $.inArray( target, elems ) < 0 )
                    elems.push( target );
            });
            // if there are no elements, break
            if ( !elems.length )
                return false;
            // return the matched results, and clenup when complete
            return $( elems ).bind("dragend."+ drag.livekey, function(){
                $event.remove( this, "."+ drag.livekey ); // cleanup delegation
            });
        },

        // re-use event object for custom events
        hijack: function( event, type, dd, x, elem ){
            // not configured
            if ( !dd )
                return;
            // remember the original event and type
            var orig = {
                event:event.originalEvent,
                type: event.type
            },
            // is the event drag related or drog related?
            mode = type.indexOf("drop") ? "drag" : "drop",
            // iteration vars
            result, i = x || 0, ia, $elems, callback,
            len = !isNaN( x ) ? x : dd.interactions.length;
            // modify the event type
            event.type = type;
            // copy the originalEvent as 'source event'
            event.sourceEvent = orig.event;
            // remove the original event
            event.originalEvent = null;
            // initialize the results
            dd.results = [];
            // handle each interacted element
            do if ( ia = dd.interactions[ i ] ){
                // validate the interaction
                if ( type !== "dragend" && ia.cancelled )
                    continue;
                // set the dragdrop properties on the event object
                callback = drag.properties( event, dd, ia );

                // prepare for more results
                ia.results = [];
                // handle each element
                $( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
                    // identify drag or drop targets individually
                    callback.target = subject;
                    // handle the event
                    result = subject ? $event.handle.call( subject, event, callback ) : null;
                    // stop the drag interaction for this element
                    if ( result === false ){
                        if ( mode == "drag" ){
                            ia.cancelled = true;
                            dd.propagates -= 1;
                        }
                        if ( type == "drop" ){
                            ia[ mode ][p] = null;
                        }
                    }
                    // assign any dropinit elements
                    else if ( type == "dropinit" )
                        ia.droppable.push( drag.element( result ) || subject );
                    // accept a returned proxy element
                    if ( type == "dragstart" )
                        ia.proxy = $( drag.element( result ) || ia.drag )[0];
                    // remember this result
                    ia.results.push( result );
                    // forget the event result, for recycling
                    delete event.result;
                    // break on cancelled handler
                    if ( type !== "dropinit" )
                        return result;
                });
                // flatten the results
                dd.results[ i ] = drag.flatten( ia.results );
                // accept a set of valid drop targets
                if ( type == "dropinit" )
                    ia.droppable = drag.flatten( ia.droppable );
                // locate drop targets
                if ( type == "dragstart" && !ia.cancelled )
                    callback.update();
            }
            while ( ++i < len )
            // restore the original event & type
            event.type = orig.type;
            event.originalEvent = orig.event;
            // return all handler results
            return drag.flatten( dd.results );
        },

        // extend the callback object with drag/drop properties...
        properties: function( event, dd, ia ){
            var obj = ia.callback;
            // elements
            obj.drag = ia.drag;
            obj.proxy = ia.proxy || ia.drag;
            // starting mouse position
            obj.startX = dd.pageX;
            obj.startY = dd.pageY;
            // current distance dragged
            obj.deltaX = event.pageX - dd.pageX;
            obj.deltaY = event.pageY - dd.pageY;
            // original element position
            obj.originalX = ia.offset.left;
            obj.originalY = ia.offset.top;
            // adjusted element position
            obj.offsetX = event.pageX - ( dd.pageX - obj.originalX );
            obj.offsetY = event.pageY - ( dd.pageY - obj.originalY );
            // assign the drop targets information
            obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
            obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
            return obj;
        },

        // determine is the argument is an element or jquery instance
        element: function( arg ){
            if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
                return arg;
        },

        // flatten nested jquery objects and arrays into a single dimension array
        flatten: function( arr ){
            return $.map( arr, function( member ){
                return member && member.jquery ? $.makeArray( member ) :
                member && member.length ? drag.flatten( member ) : member;
            });
        },

        // toggles text selection attributes ON (true) or OFF (false)
        textselect: function( bool ){
            $( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
            .attr("unselectable", bool ? "off" : "on" )
            .css("MozUserSelect", bool ? "" : "none" );
        },

        // suppress "selectstart" and "ondragstart" events
        dontstart: function(){
            return false;
        },

        // a callback instance contructor
        callback: function(){}

    };

    // callback methods
    drag.callback.prototype = {
        update: function(){
            if ( $special.drop && this.available.length )
                $.each( this.available, function( i ){
                    $special.drop.locate( this, i );
                });
        }
    };

    // share the same special event configuration with related events...
    $special.draginit = $special.dragstart = $special.dragend = drag;
})( jQuery );

/**
 * Mouse Wheel event normalization support.
 * All third-party attributions implied.
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

$.event.special.wheelchange = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },

    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    wheelchange: function(fn) {
        return fn ? this.bind("wheelchange", fn) : this.trigger("wheelchange");
    },

    unwheelchange: function(fn) {
        return this.unbind("wheelchange", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "wheelchange";

    // Old school scrollwheel delta
    if ( event.wheelDelta ) {delta = event.wheelDelta/120;}
    if ( event.detail     ) {delta = -event.detail/3;}

    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;

    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }

    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) {deltaY = orgEvent.wheelDeltaY/120;}
    if ( orgEvent.wheelDeltaX !== undefined ) {deltaX = -1*orgEvent.wheelDeltaX/120;}

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    return $.event.handle.apply(this, args);
}

})(jQuery);(function () {
    // Register the module with FusionCharts and also get access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.highcharts-interface']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var

    STUB = 'stub',

    /**
     * Get a reference to the Highcharts specific global library store.
     */
    lib = global.hcLib,
    /**
     * Get a reference to the JavaScript renderer.
     */
    renderer = global.renderer.getRenderer('javascript'),
    hasModule = lib.hasModule,
    loadModule = lib.loadModule,
    moduleCmdQueue = lib.moduleCmdQueue,
    executeWaitingCommands = lib.executeWaitingCommands,

    /**
     * List of chart types that are dependent on each module. There has to be
     * a one-to-one mapping to ensure that module is requested for loading
     * when it is rendered.
     */
    moduleDependencies = lib.moduleDependencies,

    /**
     * Find the relevant required module names from a given chart type.
     *
     * @param {string} type depermines the chart type (alias) that needs to
     * be looked up for dependent module names
     *
     * @type Array
     */
    getDependentModuleName = lib.getDependentModuleName,

    /**
     * List of events that has an equivalent legacy event. Used by the
     * raiseEvent method to check whether a particular event raised
     * has any corresponding legacy event.
     *
     * @type object
     */
    eventList = lib.eventList = {
        loaded: 'FC_Loaded',
        dataloaded: 'FC_DataLoaded',
        rendered: 'FC_Rendered',
        drawcomplete: 'FC_DrawComplete',
        resized: 'FC_Resized',
        dataxmlinvalid: 'FC_DataXMLInvalid',
        nodatatodisplay: 'FC_NoDataToDisplay'
    },

    /**
     * This method allows to uniformly raise events of FusionCharts
     * Framework.
     *
     * @param {string} name specifies the name of the event to be raised.
     * @param {object} args allows to provide an arguments object to be
     * passed on to the event listeners.
     * @param {FusionCharts} obj is the FusionCharts instance object on
     * behalf of which the event would be raised.
     * @param {Array} legacyArgs is an array of arguments to be passed on
     * to the equivalent legacy event.
     *
     * @type undefined
     */
    raiseEvent = lib.raiseEvent = function (name, args, obj, legacyArgs) {
        var legacy = eventList[name];
        global.raiseEvent(name, args, obj);
        if (legacy && typeof window[legacy] === 'function') {
            setTimeout(function () {
                window[legacy].apply(window, legacyArgs);
            }, 0);
        }
    };

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "charts" group.
     *
     * @type object
     */
    moduleDependencies.charts = global.extend(moduleDependencies.charts || {}, {
        column2d: 0,
        column3d: 0,
        pie2d: 0,
        pie3d: 0,
        line: 0,
        bar2d: 0,
        area2d: 0,
        doughnut2d: 0,
        doughnut3d: 0,
        pareto2d: 0,
        pareto3d: 0,
        mscolumn2d: 0,
        mscolumn3d: 0,
        msline: 0,
        msarea: 0,
        msbar2d: 0,
        msbar3d: 0,
        stackedcolumn2d: 0,
        marimekko: 0,
        stackedcolumn3d: 0,
        stackedarea2d: 0,
        stackedcolumn2dline: 0,
        stackedcolumn3dline: 0,
        stackedbar2d: 0,
        stackedbar3d: 0,
        msstackedcolumn2d: 0,
        mscombi2d: 0,
        mscombi3d: 0,
        mscolumnline3d: 0,
        mscombidy2d: 0,
        mscolumn3dlinedy: 0,
        stackedcolumn3dlinedy: 0,
        msstackedcolumn2dlinedy: 0,
        scatter: 0,
        bubble: 0,
        ssgrid: 0,
        scrollcolumn2d: 0,
        scrollcolumn3d: 0,
        scrollline2d: 0,
        scrollarea2d: 0,
        scrollstackedcolumn2d: 0,
        scrollcombi2d: 0,
        scrollcombidy2d: 0,
        zoomline: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "powercharts" group.
     *
     * @type object
     */
    moduleDependencies.powercharts = global.extend(moduleDependencies.powercharts || {}, {
        spline: 0,
        splinearea: 0,
        msspline: 0,
        mssplinearea: 0,
        multiaxisline: 0,
        multilevelpie: 0,
        waterfall2d: 0,
        msstepline: 0,
        inversemsline: 0,
        inversemscolumn2d: 0,
        inversemsarea: 0,
        errorbar2d: 0,
        horizontalerrorbar2d: 0, // custom
        errorscatter: 0,
        errorline: 0,
        logmsline: 0,
        logmscolumn2d: 0,
        radar: 0,
        dragnode: 0,
        candlestick: 0,
        selectscatter: 0,
        dragcolumn2d: 0,
        dragline: 0,
        dragarea: 0,
        kagi: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "widgets" group.
     *
     * @type object
     */
    moduleDependencies.widgets = global.extend(moduleDependencies.widgets || {}, {
        angulargauge: 0,
        bulb: 0,
        cylinder: 0,
        drawingpad: 0,
        funnel: 0,
        hbullet: 0,
        hled: 0,
        hlineargauge: 0,
        pyramid: 0,
        realtimearea: 0,
        realtimecolumn: 0,
        realtimeline: 0,
        realtimelinedy: 0,
        realtimestackedarea: 0,
        realtimestackedcolumn: 0,
        sparkcolumn: 0,
        sparkline: 0,
        sparkwinloss: 0,
        thermometer: 0,
        vbullet: 0,
        vled: 0
    });

    // Update renderer functions with functions that are intended to
    global.extend(renderer, {

        render: function (container, callback) {
            /* algorithm:
             * 1. If JS Renderer is not ready then queue the chart.
             * 2. Prepare the chart DOM element
             * 3. Send the chart for rendering if JS Renderer is ready
             */

            var chartType = this.chartType(),
            vars = this.jsVars,
            objModuleNames = getDependentModuleName(chartType);

            // Check whether this is a valid chart type
            if (!objModuleNames.length) {
                global.hcLib.createChart(this, container, STUB, undefined,
                    vars.msgStore.ChartNotSupported);

                return;
            }

            if (!lib.chartAPI[chartType]) { // check presence of API
                moduleCmdQueue[objModuleNames[objModuleNames.length - 1]].push({
                    cmd: 'render',
                    obj: this,
                    args: arguments
                });

                if (!vars.waitingModule) {
                    // Call Highcharts library to generate FusionCharts.
                    global.hcLib.createChart(this, container, STUB, undefined,
                        vars.msgStore.LoadingText);
                    renderer.load.apply(this);
                }
                return;
            }

            // Store a copy of the currently rendered src value for later
            // use while comparing during update.
            this.__state.lastRenderedSrc = this.src;
            delete vars.waitingModule;

            // Call Highcharts library to generate FusionCharts.
            global.hcLib.createChart(this, container, chartType, callback);

            // Call render completion.
            lib.raiseEvent('rendered', {}, vars.fcObj, [vars.fcObj.id]);
        },

        update: function (param) {
            var chart = this.ref, vars = this.jsVars;

            // Check whether there was an error or not.
            if (param.error === undefined) {
                delete vars.stallLoad;
                delete vars.loadError;
                // Call ExternalInterface method and update the data
                if (this.isActive()) {
                    if (this.src !== this.__state.lastRenderedSrc) {
                        this.render();
                    }
                    else {
                        // Call Highcharts library to generate FusionCharts.
                        global.hcLib.createChart(this, vars.container, vars.type);
                    }
                }
            }
            // Show error message.
            else {
                // Call ExternalInterface method to show message
                if (this.isActive() && typeof chart.showChartMessage === 'function') {
                    chart.showChartMessage('InvalidXMLText');
                }
                delete vars.loadError;
            }
        },

        resize: function (size) {
            var container = this.ref,
            cssSize,
            vars = this.jsVars;

            // Set the sizes of the DOM elements for the resize and fire related
            // commands needed for resize.
            if (!(container && container.resize)) {
                return;
            }

            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // resize chart async so that consecutive resizes can be blocked
            vars.isResizing = setTimeout(function () {
                cssSize = global.normalizeCSSDimension(size.width, size.height,
                    container);
                if (size.width !== undefined) {
                    container.style.width = cssSize.width;
                }
                if (size.height !== undefined) {
                    container.style.height = cssSize.height;
                }

                container.resize();
                delete vars.isResizing;
            }, 0);
        },

        dispose: function () {
            var container,
            vars = this.jsVars,
            hcObj = vars.hcObj || {};

            // do chartAPI instance cleanup
            vars.instanceAPI.dispose && vars.instanceAPI.dispose();

            // Proceed with disposal only when the HTML element exists.
            if ((container = this.ref)) {
                // Delete DOM element
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                }
            }

            return hcObj && hcObj.destroy && hcObj.destroy();
        },

        load: function () {
            var vars = this.jsVars,
                type = this.chartType(),
                api = global.hcLib.chartAPI[type],
                modules = getDependentModuleName(type),
                terminalModule = modules[modules.length - 1];

            if (api || !modules || (modules && modules.length === 0)) {
                delete vars.waitingModule;
                return;
            }

            // Request load of the specific chart module
            if (!vars.waitingModule) {
                // Mark the object that it is waiting for module load.
                vars.waitingModule = true;
                loadModule(modules, function () {
                    delete vars.waitingModule;
                    executeWaitingCommands(lib.moduleCmdQueue[terminalModule] || []);
                }, function (key) {
                    global.raiseError(this, 11171116151, 'run', 'HC-interface~renderer.load',
                        'Unable to load required modules and resources: ' + key)
                });
                vars.moduleLoadRequested = true;
            }
        },

        config: function (items) {
            var item,
            vars = this.jsVars,
            msgs = vars.msgStore,
            cfg = vars.cfgStore;
            // store data at respective places.
            for (item in items) {
                // if the config is part of chart messages, we store it there.
                if (msgs[item]) {
                    msgs[item] = items[item];
                }
                // otherwise we store it to the config store.
                else {
                    cfg[item.toLowerCase()] = items[item]
                }
            }
        }
    });


})();

/*jslint forin: true */
/*global document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $ */

(function() {
    // Register the module with FusionCharts and also get access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.highcharts-src']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var lib = global.hcLib,
    // Add the tools thats are required.
    pluck = lib.pluck,
    pluckNumber = lib.pluckNumber,
    getDarkColor = lib.graphics.getDarkColor,
    getLightColor = lib.graphics.getLightColor,
    convertColor = lib.graphics.convertColor,
    getColorCodeString = lib.getColorCodeString,
    getAngle = lib.graphics.getAngle,
    dropHash = lib.regex.dropHash,
    startsRGBA = lib.regex.startsRGBA,
    hexcode = lib.regex.hexcode,
    HASHSTRING = lib.HASHSTRING,
    BLANKSTRING = lib.BLANKSTRING,
    setImageDisplayMode = lib.setImageDisplayMode,
    POSITION_TOP = lib.POSITION_TOP,
    POSITION_RIGHT = lib.POSITION_RIGHT,
    POSITION_BOTTOM = lib.POSITION_BOTTOM,
    POSITION_LEFT = lib.POSITION_LEFT,
    POSITION_MIDDLE = lib.POSITION_MIDDLE,
    BGRATIOSTRING = lib.BGRATIOSTRING,
    HUNDREDSTRING = lib.HUNDREDSTRING,
    ZEROSTRING = lib.ZEROSTRING,
    extend2 = lib.extend2,
    getFirstValue = lib.getFirstValue,

    /**
     * @constant
     * @type string
     */
    COLOR_TRANSPARENT = lib.COLOR_TRANSPARENT,
    getFirstColor = lib.getFirstColor,
    COMMASTRING = lib.COMMASTRING,

    zOrderLils3D = {
        column : ['column3d', 'bar3d', 'area3d', 'line3d'],//column will be drawn first
        area : ['area3d', 'column3d', 'bar3d', 'line3d']//area will be drawn first
    },
    series3Drenderer = {
        column3d : function (seriesArr, chart) {
            var x, length, maxDataLength = 0, y, series, stacking,
            point, negativeStackedArr = [];
            //get the max no of data.
            for (x = 0, length = seriesArr.length; x < length; x +=1) {
                maxDataLength = mathMax(seriesArr[x].data.length, maxDataLength);
            }
            if (maxDataLength > 0) {
                series = seriesArr[0];
                chart = series.chart;

                //create the groups for all series
                series.initGroup();
                //set the stacking condition for thr chart if any
                stacking = chart.column3DStacked = pluck(series.options.stacking, chart.options.plotOptions.column3d
                    && chart.options.plotOptions.column3d.stacking, chart.options.plotOptions.series.stacking) !==
                undefined ? true : false


                //draw the points for ony by one x position
                for(x = 0; x < maxDataLength; x += 1) {
                    //for data x position x draw all series's points'
                    for (y = 0, length = seriesArr.length; y < length; y +=1) {
                        series = seriesArr[y];
                        point = series.data[x];
                        if (point && point.y !== null) {
                            if (point.y <= 0 && stacking) {//STORE THE NEGATIVE POINTS IN A STACK
                                negativeStackedArr.push(y);
                            }
                            else {
                                seriesArr[y].drawNthPoint(x);
                            }
                        }
                    }
                    //for stacked negative loop draw from last
                    if (stacking) {
                        for (length = negativeStackedArr.length - 1; length >= 0; length -= 1) {
                            //draw the series from the last series first for negative value
                            seriesArr[negativeStackedArr.pop()].drawNthPoint(x)
                        }
                    }
                }
                //
                for (y = 0, length = seriesArr.length; y < length; y +=1) {
                    seriesArr[y].render();
                }
            }

        },
        bar3d : function (seriesArr, chart) {
            var x, length, maxDataLength = 0, y, series, stacking,
            point, negativeStackedArr = [];
            //get the max no of data.
            for (x = 0, length = seriesArr.length; x < length; x +=1) {
                maxDataLength = mathMax(seriesArr[x].data.length, maxDataLength);
            }
            if (maxDataLength > 0) {
                series = seriesArr[0];
                chart = series.chart;

                //create the groups for all series
                series.initGroup();
                //set the stacking condition for thr chart if any
                stacking = chart.column3DStacked = pluck(series.options.stacking, chart.options.plotOptions.column3d
                    && chart.options.plotOptions.column3d.stacking, chart.options.plotOptions.series.stacking) !==
                undefined ? true : false


                //draw the points for ony by one x position
                for(x = maxDataLength - 1; x >= 0; x -= 1) {
                    //for data x position x draw all series's points'
                    for (y = 0, length = seriesArr.length; y < length; y +=1) {
                        series = seriesArr[y];
                        point = series.data[x];
                        if (point && point.y !== null) {
                            if (point.y <= 0 && stacking) {//STORE THE NEGATIVE POINTS IN A STACK
                                negativeStackedArr.push(y);
                            }
                            else {
                                seriesArr[y].drawNthPoint(x);
                            }
                        }
                    }
                    //for stacked negative loop draw from last
                    if (stacking) {
                        for (length = negativeStackedArr.length - 1; length >= 0; length -= 1) {
                            //draw the series from the last series first for negative value
                            seriesArr[negativeStackedArr.pop()].drawNthPoint(x)
                        }
                    }
                }
                //
                for (y = 0, length = seriesArr.length; y < length; y +=1) {
                    seriesArr[y].render();
                }
            }

        },
        common : function (seriesArr, chart) {
        }
    },
    get3DSeriesRendering = function (seriesType) {
        if (series3Drenderer[seriesType]) {
            return series3Drenderer[seriesType];
        }
        else {
            return series3Drenderer.common;
        }

    },
    series3DList = {
        column3d : true,
        bar3d : true,
        area3d : true,
        line3d : true
    },
    
    
    zOrderSetter = function (chart, seriesArr, isStacked) {
        var column3D = 0, area3D = 0, line3D = 0, bar3D = 0, noofzSegment = 0, zOrder = 0,
        seriesType, length, xDepth = chart.xDepth, yDepth = chart.yDepth,
        xTranslate2D, yTranslate2D, newClipRect,
        series2D3Dshift = chart.options.chart.series2D3Dshift,
        perSeriesXDepth, perSeriesYDepth, willMSPlacedOnZ, y, length2, series,
        depthXDisplacement = 0, depthYDisplacement = 0, seriesRendering, seriesTypeArr;
        if (seriesArr.column3d) {
            column3D = seriesArr.column3d.length;
        }
        if (seriesArr.bar3d) {
            bar3D = seriesArr.bar3d.length;
        }
        if (seriesArr.area3d) {
            area3D = seriesArr.area3d.length;
        }
        if (seriesArr.line3d) {
            line3D = seriesArr.line3d.length;
        }
        if (isStacked) {//if stacked then there will be 1 segment for every type
            noofzSegment = (column3D ? 1 : 0) + (bar3D ? 1 : 0) + (area3D ? 1 : 0) + (line3D ? 1 : 0);
        }
        else {
            //if not stacked then there will be 1 segment for only column3d
            // else every series will be placed on z axis
            noofzSegment = (column3D ? 1 : 0) + (bar3D ? 1 : 0) + area3D + line3D;
        }
        chart.num3dSeriesType = noofzSegment;
        depthXDisplacement = 0;
        depthYDisplacement = 0;
        perSeriesYDepth = yDepth / noofzSegment;
        perSeriesXDepth = xDepth / noofzSegment;
        //draw the 3D series first
        for (seriesType in seriesArr) {
            //if 3D
            if (series3DList[seriesType]) {
                seriesTypeArr = seriesArr[seriesType];
                willMSPlacedOnZ = (seriesType === 'column3d' || seriesType === 'bar3d' || isStacked) ? false : true;
                //for 3d increase the displacement
                depthXDisplacement += perSeriesXDepth;
                depthYDisplacement += perSeriesYDepth;
                for (y = 0, length2 = seriesTypeArr.length; y < length2; y += 1) {
                    series = seriesTypeArr[y];
                    series.depthXDisplacement = -depthXDisplacement;// x displacement negative
                    series.depthYDisplacement = depthYDisplacement;
                    if (willMSPlacedOnZ) {
                        depthXDisplacement += series.xDepth = perSeriesXDepth;
                        depthYDisplacement += series.yDepth = perSeriesYDepth;
                    }
                    else {
                        series.xDepth = perSeriesXDepth;
                        series.yDepth = perSeriesYDepth;
                    }
                }
                seriesRendering = get3DSeriesRendering(seriesType);
                seriesRendering(seriesTypeArr, chart);
                delete seriesArr[seriesType];
            }
        }
        //draw the 2D series then
        for (seriesType in seriesArr) {
            xTranslate2D = chart.plotLeft - depthXDisplacement;
            //redefine the cliprect and reposition the series with the 3D depth
            if (series2D3Dshift) {
                yTranslate2D = chart.plotTop + depthYDisplacement;
            }
            else {
                yTranslate2D = chart.plotTop;
            }
            for (y = 0, length = seriesArr[seriesType].length; y < length; y += 1) {
                //fix for VML z Index issue
                //ass all are absolute and the 3d data has zindex=3
                seriesArr[seriesType][y].options.zIndex = 4;
                seriesArr[seriesType][y].render();
                seriesArr[seriesType][y].group.translate(xTranslate2D, yTranslate2D)
            }
        }
    };

    //few extre function that are required.
    //function that will create ta symbol path for a legend icon.
    function getSymbolPath (x, y, width, height, seriesType, item, renderer) {
        
        var path = [M], colorStr = getFirstColor(typeof item.color === "string" ? item.color : item.color.FCcolor.color),
        color, width1, width2, height1, height2, height3, x1, x2, y1, y2, r1,
        isVmlRenderer = renderer.box.tagName && renderer.box.tagName.toLowerCase() === 'div',
        Z = 'Z', A = 'A', AT = 'at', lightColor, strokeWidth = 0.5, strokeColor;

        color = colorStr.replace(dropHash, '');
        lightColor = getLightColor(color, 40);
        strokeColor = getDarkColor(color, 60).replace(dropHash, HASHSTRING);
        color = {
            FCcolor : {
                color : color + ',' + color + ',' + lightColor + ',' + color + ',' + color,
                ratio : '0,30,30,30,10',
                angle : 0,
                alpha : '100,100,100,100,100'
            }
        };

        switch (seriesType) {
            case 'column':
            case 'column3d':
                width1 = parseInt((width * 0.25) * 100) /100;
                width2 = parseInt((width1 * 0.5) * 100) / 100;
                height1 = parseInt((height * 0.3) * 100) / 100;
                height2 = parseInt((height * 0.6) * 100) / 100;

                path = path.concat([x, y + height, L, x, y + height1, x + width1, y + height1,
                    x + width1, y + height, x + width1 + width2, y + height, x + width1 + width2, y,
                    x + width1 + width1 + width2, y, x + width1 + width1 + width2, y + height,
                    x + width1 + width1 + width2 + width2, y + height, x + width1 + width1 + width2 + width2, y + height2,
                    x + width, y + height2, x + width, y + height, Z]);
                color.FCcolor.angle = 270;
                break;

            case 'bar':
            case 'bar3d':
                width1 = width * 0.3;
                width2 = width * 0.6;
                height1 = height / 4;
                height2 = height1 / 2;
                path = path.concat([x, y, L, x + width2, y, x + width2, y + height1,
                    x, y + height1, x, y + height1 + height2, x + width, y + height1 + height2,
                    x + width, y + height1 + height2 + height1, x,  y + (2 * height1) + height2,
                    x, y + 2 * (height1 + height2), x + width1, y + 2 * (height1 + height2),
                    x + width1, y + height, x, y + height, Z]);
                break;

            case 'area':
            case 'area3d':
                width1 = width * 0.3;
                width2 = width * 0.6;
                height1 = height * 0.6;
                height2 = height * 0.2;
                height3 = height * 0.8;
                path = path.concat([x, y + height3, L, x, y+ height1, x + width1, y + height2,
                    x + width2, y + height1, x + width, y + height2, x + width, y + height3, Z])
                color.FCcolor.angle = 270;
                break;

            case 'pie':
            case 'pie3d':
                width = width;
                height = height;
                width1 = width / 2;
                width2 = width * 0.7;
                height1 = height / 2;
                height2 = height * 0.7;
                x1 = x, x2 = x, y1 = y, y2 = y;
                if (!isVmlRenderer) {//HC dose not have arc mapping
                    path = path.concat([x2 + width1, y2 + height1, L, x + width2, y2,
                        A,  width1, height1, 0, 0, 0,  x2, y2 + height1, L, x2 + width1, y2 + height1,
                        M, x2 + width1, y1 + height1, L, x2, y1 + height1,
                        A,  width1, height1, 0, 0, 0,  x2 + width2, y1 + height, L, x2 + width1, y1 + height1,
                        M, x1 + width1, y + height1, L, x1 + width2, y1 + height,
                        A, width1 + 1, height1 + 1, 0, 0, 0, x1 + width2, y2, Z]);
                }
                else {
                    path = path.concat([x2 + width1, y2 + height1, L, x + width2, y2,
                        AT, x, y, x + width, y + height, x + width2, y2,  x2, y2 + height1, L, x2 + width1, y2 + height1,
                        M, x2 + width1, y1 + height1, L, x2, y1 + height1,
                        AT, x, y, x + width, y + height, x2, y1 + height1,  x2 + width2, y1 + height, L, x2 + width1, y1 + height1,
                        M, x1 + width1, y + height1, L, x1 + width2, y1 + height,
                        AT, x, y, x + width, y + height, x1 + width2, y1 + height, x1 + width2, y2, Z]);
                }
                break;

            // A square line for every other request.
            default:
                path = path.concat([x, y, L, x + width, y, x + width, y + height, x, y + height, Z])
                color.FCcolor.angle = 270;
                color.FCcolor.ratio = '0,70,30';
        }
        return {
            path : path,
            color : color,
            strokeWidth : strokeWidth,
            strokeColor : strokeColor
        };
    }

/*******************************************************************************
 * FusionCharts-Highcharts JS v2.1.4 (2011-03-02)
 *
 * (c) 2010-2011 FusionCharts Technologies LLP.
 * (c) 2009-2010 Torstein Hnsi
 *
 * License: www.fusioncharts.com/license/, www.highcharts.com/license
 ******************************************************************************/

    // encapsulated variables
    // encapsulated variables
    var doc = document,
    win = window,
    math = Math,
    mathRound = math.round,
    mathFloor = math.floor,
    mathCeil = math.ceil,
    mathMax = math.max,
    mathMin = math.min,
    mathAbs = math.abs,
    mathCos = math.cos,
    mathSin = math.sin,
    mathPI = math.PI,
    deg2rad = mathPI / 180,
    /**^
     * Updated global variables.
     * @source 28/2.1.4-6
	 */
    mathATan2 = math.atan2,
    // used in pie labels calculation
    mathHalfPI = mathPI / 2, // PI / 2 to determine bottom right quarter
    quarterPI = mathPI * 1.5, // to determine bottom left quarter
    math2PI = mathPI * 2,
    /* EOP 28/2.1.4 ^*/

    // some variables
    userAgent = navigator.userAgent,
    isIE = /msie/i.test(userAgent) && !win.opera,
    docMode8 = doc.documentMode === 8,
    isWebKit = /AppleWebKit/.test(userAgent),
    isFirefox = /Firefox/.test(userAgent),
    //hasSVG = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
    hasSVG = !!doc.createElementNS && !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
    SVG_NS = 'http://www.w3.org/2000/svg',
    Renderer,
    hasTouch = doc.documentElement.ontouchstart !== undefined,
    symbolSizes = {},
    idCounter = 0,
    timeFactor = 1, // 1 = JavaScript time, 1000 = Unix time
    garbageBin,
    defaultOptions,
    dateFormat, // function
    globalAnimation,
    pathAnim,


    // some constants for frequently used strings
    UNDEFINED,
    DIV = 'div',
    ABSOLUTE = 'absolute',
    RELATIVE = 'relative',
    HIDDEN = 'hidden',
    PREFIX = 'highcharts-',
    VISIBLE = isIE && !hasSVG ? 'visible' : '',
    PX = 'px',
    NONE = 'none',
    M = 'M',
    L = 'L',
    A = 'A',
    AT = 'AT',
    WA = 'WA',
    Z = 'Z',
    /*
     * Empirical lowest possible opacities for TRACKER_FILL
     * IE6: 0.002
     * IE7: 0.002
     * IE8: 0.002
     * IE9: 0.00000000001 (unlimited)
     * FF: 0.00000000001 (unlimited)
     * Chrome: 0.000001
     * Safari: 0.000001
     * Opera: 0.00000000001 (unlimited)
     */
    TRACKER_FILL = 'rgba(192,192,192,'+ (hasSVG ? 0.000001 : 0.002) +')', // invisible but clickable
    NORMAL_STATE = '',
    HOVER_STATE = 'hover',
    SELECT_STATE = 'select',

    // time methods, changed based on whether or not UTC is used
    makeTime,
    getMinutes,
    getHours,
    getDay,
    getDate,
    getMonth,
    getFullYear,
    setMinutes,
    setHours,
    setDate,
    setMonth,
    setFullYear,

    // check for a custom HighchartsAdapter defined prior to this file
    globalAdapter = win.HighchartsAdapter,
    adapter = globalAdapter || {},

    // Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
    // and all the utility functions will be null. In that case they are populated by the
    // default adapters below.
    each = adapter.each,
    grep = adapter.grep,
    map = adapter.map,
    merge = adapter.merge,
    addEvent = adapter.addEvent,
    removeEvent = adapter.removeEvent,
    fireEvent = adapter.fireEvent,
    animate = adapter.animate,
    stop = adapter.stop,

    // lookup over the types and the associated classes
    seriesTypes = lib.seriesTypes = {},
    hoverChart;

    /**
     * Extend an object with the members of another
     * @param {Object} a The object to be extended
     * @param {Object} b The object to add to the first one
     */
    function extend(a, b) {
        var n;
        if (!a) {
            a = {};
        }
        for (n in b) {
            a[n] = b[n];
        }
        return a;
    }

    /**
     * Shortcut for parseInt
     * @param {Object} s
     */
    function pInt(s, mag) {
        return parseInt(s, mag || 10);
    }

    /**
     * Check for string
     * @param {Object} s
     */
    function isString(s) {
        return typeof s === 'string';
    }

    /**
     * Check for object
     * @param {Object} obj
     */
    function isObject(obj) {
        return typeof obj === 'object';
    }

    /**
     * Check for number
     * @param {Object} n
     */
    function isNumber(n) {
        return typeof n === 'number';
    }

    function log2lin(num) {
        return math.log(num) / math.LN10;
    }
    function lin2log(num) {
        return math.pow(10, num);
    }

    /**
     * Remove last occurence of an item from an array
     * @param {Array} arr
     * @param {Mixed} item
     */
    function erase(arr, item) {
        var i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
    //return arr;
    }

    /**
     * Returns true if the object is not null or undefined. Like MooTools' $.defined.
     * @param {Object} obj
     */
    function defined (obj) {
        return obj !== UNDEFINED && obj !== null;
    }

    /**
     * Set or get an attribute or an object of attributes. Can't use jQuery attr because
     * it attempts to set expando properties on the SVG element, which is not allowed.
     *
     * @param {Object} elem The DOM element to receive the attribute(s)
     * @param {String|Object} prop The property or an abject of key-value pairs
     * @param {String} value The value if a single property is set
     */
    function attr(elem, prop, value) {
        var key,
        setAttribute = 'setAttribute',
        ret;

        // if the prop is a string
        if (isString(prop)) {
            // set the value
            if (defined(value)) {

                elem[setAttribute](prop, value);

            // get the value
            } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                ret = elem.getAttribute(prop);
            }

        // else if prop is defined, it is a hash of key/value pairs
        } else if (defined(prop) && isObject(prop)) {
            for (key in prop) {
                elem[setAttribute](key, prop[key]);
            }
        }
        return ret;
    }
    /**
     * Check if an element is an array, and if not, make it into an array. Like
     * MooTools' $.splat.
     */
    function splat(obj) {
        if (!obj || obj.constructor !== Array) {
            obj = [obj];
        }
        return obj;
    }



    /**
     * Return the first value that is defined. Like MooTools' $.pick.
     */
    function pick() {
        var args = arguments,
        i,
        arg,
        length = args.length;
        for (i = 0; i < length; i++) {
            arg = args[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
    }

    /**
     * Set CSS on a given element
     * @param {Object} el
     * @param {Object} styles Style object with camel case property names
     */
    function css (el, styles) {
        if (isIE) {
            if (styles && styles.opacity !== UNDEFINED) {
                styles.filter = 'alpha(opacity='+ (styles.opacity * 100) +')';
            }
        }
        extend(el.style, styles);
    }

    /**
     * Get CSS value on a given element
     * @param {Object} el DOM object
     * @param {String} styleProp Camel cased CSS propery
     * /
function getStyle (el, styleProp) {
	var ret,
		CURRENT_STYLE = 'currentStyle',
		GET_COMPUTED_STYLE = 'getComputedStyle';
	if (el[CURRENT_STYLE]) {
		ret = el[CURRENT_STYLE][styleProp];
	} else if (win[GET_COMPUTED_STYLE]) {
		ret = win[GET_COMPUTED_STYLE](el, null).getPropertyValue(hyphenate(styleProp));
	}
	return ret;
}*/

    /**
     * Utility function to create element with attributes and styles
     * @param {Object} tag
     * @param {Object} attribs
     * @param {Object} styles
     * @param {Object} parent
     * @param {Object} nopad
     */
    function createElement (tag, attribs, styles, parent, nopad) {
        var el = doc.createElement(tag);
        if (attribs) {
            extend(el, attribs);
        }
        if (nopad) {
            css(el, {
                padding: 0,
                border: NONE,
                margin: 0
            });
        }
        if (styles) {
            css(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }

    /**
     * Extend a prototyped class by new members
     * @param {Object} parent
     * @param {Object} members
     */
    function extendClass(parent, members) {
        var object = function(){};
        object.prototype = new parent();
        extend(object.prototype, members);
        return object;
    }

    /**
     * Format a number and return a string based on input settings
     * @param {Number} number The input number to format
     * @param {Number} decimals The amount of decimals
     * @param {String} decPoint The decimal point, defaults to the one given in the lang options
     * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
     */
    function numberFormat (number, decimals, decPoint, thousandsSep) {
        var lang = defaultOptions.lang,
        // http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
        n = number, c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
        d = decPoint === undefined ? lang.decimalPoint : decPoint,
        t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "",
        i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
        j = i.length > 3 ? i.length % 3 : 0;

        return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
        (c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
    }

    /**
     * Based on http://www.php.net/manual/en/function.strftime.php
     * @param {String} format
     * @param {Number} timestamp
     * @param {Boolean} capitalize
     */
    dateFormat = function (format, timestamp, capitalize) {
        function pad (number) {
            return number.toString().replace(/^([0-9])$/, '0$1');
        }

        if (!defined(timestamp) || isNaN(timestamp)) {
            return 'Invalid date';
        }
        format = pick(format, '%Y-%m-%d %H:%M:%S');

        var date = new Date(timestamp * timeFactor),
        key, // used in for constuct below
        // get the basic time values
        hours = date[getHours](),
        day = date[getDay](),
        dayOfMonth = date[getDate](),
        month = date[getMonth](),
        fullYear = date[getFullYear](),
        lang = defaultOptions.lang,
        langWeekdays = lang.weekdays,
        langMonths = lang.months,
        /* // uncomment this and the 'W' format key below to enable week numbers
		weekNumber = function() {
			var clone = new Date(date.valueOf()),
				day = clone[getDay]() == 0 ? 7 : clone[getDay](),
				dayNumber;
			clone.setDate(clone[getDate]() + 4 - day);
			dayNumber = mathFloor((clone.getTime() - new Date(clone[getFullYear](), 0, 1, -6)) / 86400000);
			return 1 + mathFloor(dayNumber / 7);
		},
		*/

        // list all format keys
        replacements = {

            // Day
            'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
            'A': langWeekdays[day], // Long weekday, like 'Monday'
            'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
            'e': dayOfMonth, // Day of the month, 1 through 31

            // Week (none implemented)
            //'W': weekNumber(),

            // Month
            'b': langMonths[month].substr(0, 3), // Short month, like 'Jan'
            'B': langMonths[month], // Long month, like 'January'
            'm': pad(month + 1), // Two digit month number, 01 through 12

            // Year
            'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
            'Y': fullYear, // Four digits year, like 2009

            // Time
            'H': pad(hours), // Two digits hours in 24h format, 00 through 23
            'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
            'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
            'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
            'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
            'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
            'S': pad(date.getSeconds()) // Two digits seconds, 00 through  59

        };


        // do the replaces
        for (key in replacements) {
            format = format.replace('%'+ key, replacements[key]);
        }

        // Optionally capitalize the string and return
        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
    };

    /**
     * Loop up the node tree and add offsetWidth and offsetHeight to get the
     * total page offset for a given element. Used by Opera and iOS on hover and
     * all browsers on point click.
     *
     * @param {Object} el
     *
     */
    function getPosition (el) {
        var p = {
            left: el.offsetLeft,
            top: el.offsetTop
        };
        el = el.offsetParent;
        while (el) {
            p.left += el.offsetLeft;
            p.top += el.offsetTop;
            if (el !== doc.body && el !== doc.documentElement) {
                p.left -= el.scrollLeft;
                p.top -= el.scrollTop;
            }
            el = el.offsetParent;
        }
        return p;
    }

    /**
     * Helper class that contains variuos counters that are local to the chart.
     */
    function ChartCounters() {
        this.color = 0;
        this.symbol = 0;
    }

    ChartCounters.prototype =  {
        /**
	 * Wraps the color counter if it reaches the specified length.
	 */
        wrapColor: function(length) {
            if (this.color >= length) {
                this.color = 0;
            }
        },

        /**
	 * Wraps the symbol counter if it reaches the specified length.
	 */
        wrapSymbol: function(length) {
            if (this.symbol >= length) {
                this.symbol = 0;
            }
        }
    };

    /**
     * Set the global animation to either a given value, or fall back to the
     * given chart's animation option
     * @param {Object} animation
     * @param {Object} chart
     */
    function setAnimation(animation, chart) {
        globalAnimation = pick(animation, chart.animation);
    }

    /*
     * Define the adapter for frameworks. If an external adapter is not defined,
     * Highcharts reverts to the built-in jQuery adapter.
     */
    if (globalAdapter && globalAdapter.init) {
        globalAdapter.init();
    }
    if (!globalAdapter && win.jQuery) {
        var jQ = jQuery;

        /**
	 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
	 * @param {Array} arr
	 * @param {Function} fn
	 */
        each = lib.each = function(arr, fn) {
            var i = 0,
            len = arr.length;
            for (; i < len; i++) {
                if (fn.call(arr[i], arr[i], i, arr) === false) {
                    return i;
                }
            }
        };

        /**
	 * Filter an array
	 */
        grep = jQ.grep;

        /**
	 * Map an array
	 * @param {Array} arr
	 * @param {Function} fn
	 */
        map = function(arr, fn){
            //return jQuery.map(arr, fn);
            var results = [],
            i = 0, len = arr.length;
            for (; i < len; i++) {
                results[i] = fn.call(arr[i], arr[i], i, arr);
            }
            return results;

        };

        /**
	 * Deep merge two objects and return a third object
	 */
        merge =lib.merge= function(){
            var args = arguments;
            return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
        };

        /**^
	 * Added ability for event to pass event.data as arguments
	 * @source 379/2.1.4-6
	 */
        /**
	 * Add an event listener
	 * @param {Object} el A HTML element or custom object
	 * @param {String} event The event type
	 * @param {Function} fn The event handler
	 * @param {Object} data Optional event arguments
	 */
        addEvent = function (el, event, fn, data){
            jQ(el).bind(event, data, fn);
        };
        /* EOP 379/2.1.4 ^*/

        /**
	 * Remove event added with addEvent
	 * @param {Object} el The object
	 * @param {String} eventType The event type. Leave blank to remove all events.
	 * @param {Function} handler The function to remove
	 */
        removeEvent = function(el, eventType, handler) {
            // workaround for jQuery issue with unbinding custom events:
            // http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
            var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
            if (doc[func] && !el[func]) {
                el[func] = function() {};
            }

            jQ(el).unbind(eventType, handler);
        };

        /**
	 * Fire an event on a custom object
	 * @param {Object} el
	 * @param {String} type
	 * @param {Object} eventArguments
	 * @param {Function} defaultFunction
	 */
        fireEvent = function(el, type, eventArguments, defaultFunction) {
            var event = jQ.Event(type),
            detachedType = 'detached'+ type;
            extend(event, eventArguments);

            // Prevent jQuery from triggering the object method that is named the
            // same as the event. For example, if the event is 'select', jQuery
            // attempts calling el.select and it goes into a loop.
            if (el[type]) {
                el[detachedType] = el[type];
                el[type] = null;
            }

            // trigger it
            jQ(el).trigger(event);

            // attach the method
            if (el[detachedType]) {
                el[type] = el[detachedType];
                el[detachedType] = null;
            }

            if (defaultFunction && !event.isDefaultPrevented()) {
                defaultFunction(event);
            }
        };

        /**
	 * Animate a HTML element or SVG element wrapper
	 * @param {Object} el
	 * @param {Object} params
	 * @param {Object} options jQuery-like animation options: duration, easing, callback
	 */
        animate = function (el, params, options) {
            var $el = jQ(el);
            if (params.d) {
                el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
                params.d = 1; // because in jQuery, animating to an array has a different meaning
            }

            $el.stop();
            $el.animate(params, options);

        };
        /**
	 * Stop running animation
	 */
        stop = function (el) {
            jQ(el).stop();
        };


        // extend jQuery
        jQ.extend( jQ.easing, {
            easeOutQuad: function (x, t, b, c, d) {
                return -c *(t/=d)*(t-2) + b;
            }
        });

        // extend the animate function to allow SVG animations
        var oldStepDefault = jQuery.fx.step._default,
        oldCur = jQuery.fx.prototype.cur;

        // do the step
        jQ.fx.step._default = function(fx){
            var elem = fx.elem;
            if (elem.attr) { // is SVG element wrapper
                elem.attr(fx.prop, fx.now);
            } else {
                oldStepDefault.apply(this, arguments);
            }
        };
        // animate paths
        jQ.fx.step.d = function(fx) {
            var elem = fx.elem;


            // Normally start and end should be set in state == 0, but sometimes,
            // for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
            // in these cases
            if (!fx.started) {
                var ends = pathAnim.init(elem, elem.d, elem.toD);
                fx.start = ends[0];
                fx.end = ends[1];
                fx.started = true;
            }


            // interpolate each value of the path
            elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));

        };
        // get the current value
        jQ.fx.prototype.cur = function() {
            var elem = this.elem,
            r;
            if (elem.attr) { // is SVG element wrapper
                r = elem.attr(this.prop);
            } else {
                r = oldCur.apply(this, arguments);
            }
            return r;
        };
    }


    /**
     * Add a global listener for mousemove events
     */
    /*addEvent(doc, 'mousemove', function(e) {
	if (globalMouseMove) {
		globalMouseMove(e);
	}
});*/

    /**
     * Path interpolation algorithm used across adapters
     */
    pathAnim = {
        /**
	 * Prepare start and end values so that the path can be animated one to one
	 */
        init: function(elem, fromD, toD) {
            fromD = fromD || '';
            var shift = elem.shift,
            bezier = fromD.indexOf('C') > -1,
            numParams = bezier ? 7 : 3,
            endLength,
            slice,
            i,
            start = fromD.split(' '),
            end = [].concat(toD), // copy
            startBaseLine,
            endBaseLine,
            sixify = function(arr) { // in splines make move points have six parameters like bezier curves
                i = arr.length;
                while (i--) {
                    if (arr[i] === M) {
                        arr.splice(i + 1, 0, arr[i+1], arr[i+2], arr[i+1], arr[i+2]);
                    }
                }
            };

            if (bezier) {
                sixify(start);
                sixify(end);
            }

            // pull out the base lines before padding
            if (elem.isArea) {
                startBaseLine = start.splice(start.length - 6, 6);
                endBaseLine = end.splice(end.length - 6, 6);
            }

            // if shifting points, prepend a dummy point to the end path
            if (shift) {

                end = [].concat(end).splice(0, numParams).concat(end);
                elem.shift = false; // reset for following animations
            }

            // copy and append last point until the length matches the end length
            if (start.length) {
                endLength = end.length;
                while (start.length < endLength) {

                    //bezier && sixify(start);
                    slice = [].concat(start).splice(start.length - numParams, numParams);
                    if (bezier) { // disable first control point
                        slice[numParams - 6] = slice[numParams - 2];
                        slice[numParams - 5] = slice[numParams - 1];
                    }
                    start = start.concat(slice);
                }
            }

            if (startBaseLine) { // append the base lines for areas
                start = start.concat(startBaseLine);
                end = end.concat(endBaseLine);
            }
            return [start, end];
        },

        /**
	 * Interpolate each value of the path and return the array
	 */
        step: function(start, end, pos, complete) {
            var ret = [],
            i = start.length,
            startVal;

            if (pos === 1) { // land on the final path without adjustment points appended in the ends
                ret = complete;

            } else if (i === end.length && pos < 1) {
                while (i--) {
                    startVal = parseFloat(start[i]);
                    ret[i] =
                    isNaN(startVal) ? // a letter instruction like M or L
                    start[i] :
                    pos * (parseFloat(end[i] - startVal)) + startVal;

                }
            } else { // if animation is finished or length not matching, land on right value
                ret = end;
            }
            return ret;
        }
    };

    /**
     * Set the time methods globally based on the useUTC option. Time method can be either
     * local time or UTC (default).
     */
    function setTimeMethods() {
        var useUTC = defaultOptions.global.useUTC;

        makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
            return new Date(
                year,
                month,
                pick(date, 1),
                pick(hours, 0),
                pick(minutes, 0),
                pick(seconds, 0)
                ).getTime();
        };
        getMinutes = useUTC ? 'getUTCMinutes' : 'getMinutes';
        getHours = useUTC ? 'getUTCHours' : 'getHours';
        getDay = useUTC ? 'getUTCDay' : 'getDay';
        getDate = useUTC ? 'getUTCDate' : 'getDate';
        getMonth = useUTC ? 'getUTCMonth' : 'getMonth';
        getFullYear = useUTC ? 'getUTCFullYear' : 'getFullYear';
        setMinutes = useUTC ? 'setUTCMinutes' : 'setMinutes';
        setHours = useUTC ? 'setUTCHours' : 'setHours';
        setDate = useUTC ? 'setUTCDate' : 'setDate';
        setMonth = useUTC ? 'setUTCMonth' : 'setMonth';
        setFullYear = useUTC ? 'setUTCFullYear' : 'setFullYear';

    }

    /**
     * Merge the default options with custom options and return the new options structure
     * @param {Object} options The new custom options
     */
    function setOptions(options) {
        defaultOptions = merge(defaultOptions, options);
        defaultPlotOptions = defaultOptions.plotOptions;
        // apply UTC
        setTimeMethods();

        return defaultOptions;
    }

    /**
     * Get the updated default options. Merely exposing defaultOptions for outside modules
     * isn't enough because the setOptions method creates a new object.
     */
    function getOptions() {
        return defaultOptions;
    }

    /**
     * Discard an element by moving it to the bin and delete
     * @param {Object} The HTML node to discard
     */
    function discardElement(element) {
        // create a garbage bin element, not part of the DOM
        if (!garbageBin) {
            garbageBin = createElement(DIV);
        }

        // move the node and empty bin
        if (element) {
            garbageBin.appendChild(element);
        }
        garbageBin.innerHTML = '';
    }

/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
    var

    defaultLabelOptions = {
        enabled: true,
        // rotation: 0,
        align: 'center',
        x: 0,
        y: 15,
        /*formatter: function() {
		return this.value;
	},*/
        style: {
            color: '#666',
            fontSize: '11px',
            lineHeight: '14px'
        }
    };

    defaultOptions = {
        colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
        '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
        lang: {
            loading: 'Loading...',
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
            'August', 'September', 'October', 'November', 'December'],
            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            decimalPoint: '.',
            resetZoom: 'Reset zoom',
            resetZoomTitle: 'Reset zoom level 1:1',
            thousandsSep: ','
        },
        global: {
            useUTC: true
        },
        chart: {
            //animation: true,
            //alignTicks: false,
            //reflow: true,
            //className: null,
            //events: { load, selection },
            //margin: [null],
            //marginTop: null,
            //marginRight: null,
            //marginBottom: null,
            //marginLeft: null,
            borderColor: '#4572A7',
            //borderWidth: 0,
            borderRadius: 5,
            defaultSeriesType: 'line',
            ignoreHiddenSeries: true,
            //inverted: false,
            //shadow: false,
            spacingTop: 10,
            spacingRight: 10,
            spacingBottom: 15,
            spacingLeft: 10,
            style: {
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
                fontSize: '12px'
            },
            backgroundColor: '#FFFFFF',
            //plotBackgroundColor: null,
            plotBorderColor: '#C0C0C0'
        //plotBorderWidth: 0,
        //plotShadow: false,
        //zoomType: ''
        },
        title: {
            text: 'Chart title',
            align: 'center',
            // floating: false,
            // margin: 15,
            // x: 0,
            // verticalAlign: 'top',
            y: 15, // docs
            style: {
                color: '#3E576F',
                fontSize: '16px'
            }

        },
        subtitle: {
            text: '',
            align: 'center',
            // floating: false
            // x: 0,
            // verticalAlign: 'top',
            y: 30, // docs
            style: {
                color: '#6D869F'
            }
        },

        plotOptions: {
            line: { // base series options
                allowPointSelect: false,
                showCheckbox: false,
                animation: {
                    duration: 1000
                },
                // connectNulls: false, // docs
                //cursor: 'default',
                //dashStyle: null,
                //enableMouseTracking: true,
                events: {},
                //legendIndex: 0, // docs (+ pie points)
                lineWidth: 2,
                shadow: true,
                // stacking: null,
                marker: {
                    enabled: true,
                    //symbol: null,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: '#FFFFFF',
                    //fillColor: null,
                    states: { // states for a single point
                        hover: {
                        //radius: base + 2
                        },
                        select: {
                            fillColor: '#FFFFFF',
                            lineColor: '#000000',
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: merge(defaultLabelOptions, {
                    enabled: false,
                    y: -6,
                    formatter: function() {
                        return this.y;
                    }
                }),

                //pointStart: 0,
                //pointInterval: 1,
                showInLegend: true,
                states: { // states for the entire series
                    hover: {
                        //enabled: false,
                        //lineWidth: base + 1,
                        marker: {
                    // lineWidth: base + 1,
                    // radius: base + 1
                    }
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: true
            //zIndex: null
            }
        },
        labels: {
            //items: [],
            style: {
                //font: defaultFont,
                position: ABSOLUTE,
                color: '#3E576F'
            }
        },
        legend: {
            enabled: true,
            align: 'center',
            //floating: false,
            layout: 'horizontal',
            labelFormatter: function() {
                return this.name;
            },
            // lineHeight: 16, // docs: deprecated
            borderWidth: 1,
            borderColor: '#909090',
            borderRadius: 5,
            // margin: 10,
            // reversed: false,
            shadow: false,
            // backgroundColor: null,
            style: {
                padding: '5px'
            },
            itemStyle: {
                cursor: 'pointer',
                color: '#3E576F'
            },
            itemHoverStyle: {
                cursor: 'pointer'//, /**^ Patch removed hover style ^*/
            //color: '#000000'
            },
            itemHiddenStyle: {
                color: '#C0C0C0'
            },
            itemCheckboxStyle: {
                position: ABSOLUTE,
                width: '13px', // for IE precision
                height: '13px'
            },
            // itemWidth: undefined,
            symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: 'bottom',
            // width: undefined,
            x: 0, // docs
            y: 0 // docs
        },

        loading: {
            hideDuration: 100,
            labelStyle: { /**^ Sleeker fonts ^*/
                position: RELATIVE,
                fontFamily: 'Verdana',
                fontSize:  '10px',
                color: '#ffffff'
            },
            showDuration: 100,
            style: {
                position: ABSOLUTE,
                backgroundColor: 'black',
                opacity: 0.2,
                textAlign: 'center'
            }
        },

        tooltip: {
            enabled: true,
            //crosshairs: null,
            backgroundColor: 'rgba(255, 255, 255, .85)',
            borderWidth: 2,
            borderRadius: 5,
            //formatter: defaultFormatter,
            shadow: true,
            //shared: false,
            snap: hasTouch ? 25 : 10,
            style: {
                color: '#333333',
                fontSize: '12px',
                padding: '5px',
                whiteSpace: 'nowrap'
            }
        },

        toolbar: {
            itemStyle: {
                color: '#4572A7',
                cursor: 'pointer'
            }
        },

        credits: {
            enabled: true,
            text: 'Highcharts.com',
            href: 'http://www.highcharts.com',
            position: {
                align: 'right',
                x: -10,
                verticalAlign: 'bottom',
                y: -5
            },
            style: {
                cursor: 'pointer',
                color: '#909090',
                fontSize: '10px'
            }
        }
    };

    // Axis defaults
    var defaultXAxisOptions =  {
        // allowDecimals: null,
        // alternateGridColor: null,
        // categories: [],
        dateTimeLabelFormats: {
            second: '%H:%M:%S',
            minute: '%H:%M',
            hour: '%H:%M',
            day: '%e. %b',
            week: '%e. %b',
            month: '%b \'%y',
            year: '%Y'
        },
        endOnTick: false,
        gridLineColor: '#C0C0C0',
        // gridLineDashStyle: 'solid', // docs
        // gridLineWidth: 0,
        // reversed: false,

        labels: defaultLabelOptions,
        // { step: null },
        lineColor: '#C0D0E0',
        lineWidth: 1,
        //linkedTo: null,
        max: null,
        min: null,
        minPadding: 0.01,
        maxPadding: 0.01,
        //maxZoom: null,
        minorGridLineColor: '#E0E0E0',
        // minorGridLineDashStyle: null,
        minorGridLineWidth: 1,
        minorTickColor: '#A0A0A0',
        //minorTickInterval: null,
        minorTickLength: 2,
        minorTickPosition: 'outside', // inside or outside
        //minorTickWidth: 0,
        //opposite: false,
        //offset: 0,
        //plotBands: [{
        //	events: {},
        //	zIndex: 1,
        //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
        //}],
        //plotLines: [{
        //	events: {}
        //  dashStyle: {}
        //	zIndex:
        //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
        //}],
        //reversed: false,
        // showFirstLabel: true,
        // showLastLabel: false,
        startOfWeek: 1,
        startOnTick: false,
        tickColor: '#C0D0E0',
        //tickInterval: null,
        tickLength: 5,
        tickmarkPlacement: 'between', // on or between
        tickPixelInterval: 100,
        tickPosition: 'outside',
        tickWidth: 1,
        title: {
            //text: null,
            align: 'middle', // low, middle or high
            //margin: 0 for horizontal, 10 for vertical axes,
            //rotation: 0,
            //side: 'outside',
            style: {
                color: '#6D869F',
                //font: defaultFont.replace('normal', 'bold')
                fontWeight: 'bold'
            }
        //x: 0,
        //y: 0
        },
        type: 'linear' // linear, logarithmic or datetime // docs
    },

    defaultYAxisOptions = merge(defaultXAxisOptions, {
        endOnTick: true,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        showLastLabel: true,
        labels: {
            align: 'right',
            x: -8,
            y: 3
        },
        lineWidth: 0,
        maxPadding: 0.05,
        minPadding: 0.05,
        startOnTick: true,
        tickWidth: 0,
        title: {
            rotation: 270,
            text: 'Y-values'
        },
        stackLabels: {
            enabled: false,
            //align: dynamic,
            //y: dynamic,
            //x: dynamic,
            //verticalAlign: dynamic,
            //textAlign: dynamic,
            //rotation: 0,
            formatter: function() {
                return this.total;
            },
            style: defaultLabelOptions.style
        }
    }),

    defaultLeftAxisOptions = {
        labels: {
            align: 'right',
            x: -8,
            y: null // docs
        },
        title: {
            rotation: 270
        }
    },
    defaultRightAxisOptions = {
        labels: {
            align: 'left',
            x: 8,
            y: null // docs
        },
        title: {
            rotation: 90
        }
    },
    defaultBottomAxisOptions = { // horizontal axis
        labels: {
            align: 'center',
            x: 0,
            y: 14
        // staggerLines: null
        },
        title: {
            rotation: 0
        }
    },
    defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
        labels: {
            y: -5
        // staggerLines: null
        }
    });




    // Series defaults
    var defaultPlotOptions = lib.defaultPlotOptions = defaultOptions.plotOptions,
    defaultSeriesOptions = defaultPlotOptions.line;
    //defaultPlotOptions.line = merge(defaultSeriesOptions);
    defaultPlotOptions.spline = merge(defaultSeriesOptions);
    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
        lineWidth: 0,
        states: {
            hover: {
                lineWidth: 0
            }
        }
    });
    defaultPlotOptions.area = merge(defaultSeriesOptions, {
        // threshold: 0,
        // lineColor: null, // overrides color, but lets fillColor be unaltered
        // fillOpacity: 0.75,
        // fillColor: null

        });
    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
    defaultPlotOptions.column = merge(defaultSeriesOptions, {
        borderColor: '#FFFFFF',
        borderWidth: 1,
        borderRadius: 0,
        //colorByPoint: undefined,
        groupPadding: 0.2,
        marker: null, // point options are specified in the base options
        pointPadding: 0.1,
        //pointWidth: null,
        minPointLength: 0,
        states: {
            hover: {
                brightness: 0.1,
                shadow: false
            },
            select: {
                color: '#C0C0C0',
                borderColor: '#000000',
                shadow: false
            }
        },
        dataLabels: {
            y: null,
            verticalAlign: null
        }
    });
    defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
        dataLabels: {
            align: 'left',
            x: 5,
            y: 0
        }
    });
    defaultPlotOptions.pie = merge(defaultSeriesOptions, {
        //dragType: '', // n/a
        borderColor: '#FFFFFF',
        borderWidth: 1,
        center: ['50%', '50%'],
        colorByPoint: true, // always true for pies
        dataLabels: {
            // align: null,
            // connectorWidth: 1,
            // connectorColor: '#606060',
            // connectorPadding: 5,
            distance: 30,
            enabled: true,
            formatter: function() {
                return this.point.name;
            },
            y: 5
        },
        //innerSize: 0,
        legendType: 'point',
        marker: null, // point options are specified in the base options
        size: '75%',
        showInLegend: false,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: 0.1,
                shadow: false
            }
        }

    });

    // set the default time methods
    setTimeMethods();


    /**
     * Handle color operations. The object methods are chainable.
     * @param {String} input The input color in either rbga or hex format
     */
    var Color = function(input) {
        // declare variables
        var rgba = [], result;

        /**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
        function init(input) {

            // rgba
            result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
            if (result) {
                rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
            }

            // hex
            else {
                result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
                if (result) {
                    rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
                }
            }

        }
        /**
	 * Return the color a specified format
	 * @param {String} format
	 */
        function get(format) {
            var ret;

            // it's NaN if gradient colors on a column chart
            if (rgba && !isNaN(rgba[0])) {
                if (format === 'rgb') {
                    ret = 'rgb('+ rgba[0] +','+ rgba[1] +','+ rgba[2] +')';
                /**^
                     * capability to return hex code
                     */
                } else if (format === 'hex') {
                    ret = '#' + ('000000' + (rgba[0] << 16 | rgba[1] << 8 | rgba[2]).toString(16)).slice(-6)
                } else if (format === 'a') {
                    /*EOP^*/
                    ret = rgba[3];
                } else {
                    ret = 'rgba('+ rgba.join(',') +')';
                }
            } else {
                ret = input;
            }
            return ret;
        }

        /**
	 * Brighten the color
	 * @param {Number} alpha
	 */
        function brighten(alpha) {
            if (isNumber(alpha) && alpha !== 0) {
                var i;
                for (i = 0; i < 3; i++) {
                    rgba[i] += pInt(alpha * 255);

                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        }
        /**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
        function setOpacity(alpha) {
            rgba[3] = alpha;
            return this;
        }

        // initialize: parse the input
        init(input);

        // public methods
        return {
            get: get,
            brighten: brighten,
            setOpacity: setOpacity
        };
    };

    /**
     * A wrapper object for SVG elements
     */
    function SVGElement () {}

    SVGElement.prototype = {
        /**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
        init: function(renderer, nodeName) {
            this.element = doc.createElementNS(SVG_NS, nodeName);
            this.renderer = renderer;
        },
        /**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
        animate: function(params, options, complete) {
            var animOptions = pick(options, globalAnimation, true);
            if (animOptions) {
                animOptions = merge(animOptions);
                if (complete) { // allows using a callback with the global animation without overwriting it
                    animOptions.complete = complete;
                }
                animate(this, params, animOptions);
            } else {
                this.attr(params);
                if (complete) {
                    complete();
                }
            }
        },
        /**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
        attr: function(hash, val) {
            var key,
            value,
            i,
            /**^
             * Extra function scope variables
             */
            l,
            shadowStrength,
            /* EOP ^*/
            child,
            element = this.element,
            nodeName = element.nodeName,
            renderer = this.renderer,
            skipAttr,
            shadows = this.shadows,
            hasSetSymbolSize,
            ret = this;

            // single key-value pair
            if (isString(hash) && defined(val)) {
                key = hash;
                hash = {};
                hash[key] = val;
            }

            // used as a getter: first argument is a string, second is undefined
            if (isString(hash)) {
                key = hash;
                if (nodeName === 'circle') {
                    key = {
                        x: 'cx',
                        y: 'cy'
                    }
                    [key] || key;
                } else if (key === 'strokeWidth') {
                    key = 'stroke-width';
                }
                ret = attr(element, key) || this[key] || 0;

                if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
                    ret = parseFloat(ret);
                }

            // setter
            } else {

                for (key in hash) {
                    skipAttr = false; // reset
                    value = hash[key];

                    // paths
                    if (key === 'd') {
                        if (value && value.join) { // join path
                            value = value.join(' ');
                        }
                        if (/(NaN| {2}|^$)/.test(value)) {
                            value = 'M 0 0';
                        }
                        this.d = value; // shortcut for animations

                    // update child tspans x values
                    } else if (key === 'x' && nodeName === 'text') {
                        for (i = 0; i < element.childNodes.length; i++ ) {
                            child = element.childNodes[i];
                            // if the x values are equal, the tspan represents a linebreak
                            if (attr(child, 'x') === attr(element, 'x')) {
                                //child.setAttribute('x', value);
                                attr(child, 'x', value);
                            }
                        }

                        if (this.rotation) {
                            attr(element, 'transform', 'rotate('+ this.rotation +' '+ value +' '+
                                pInt(hash.y || attr(element, 'y')) +')');
                        }

                    // apply gradients
                    } else if (key === 'fill') {
                        value = renderer.color(value, element, key);

                    // circle x and y
                    } else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
                        key = {
                            x: 'cx',
                            y: 'cy'
                        }
                        [key] || key;

                    // translation and text rotation
                    } else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
                        this[key] = value;
                        this.updateTransform();
                        skipAttr = true;

                    // apply opacity as subnode (required by legacy WebKit and Batik)
                    } else if (key === 'stroke') {
                        value = renderer.color(value, element, key);

                    // emulate VML's dashstyle implementation
                    } else if (key === 'dashstyle') {
                        key = 'stroke-dasharray';
                        value = value && value.toLowerCase();
                        if (value === 'solid') {
                            value = NONE;
                        } else if (value) {
                            value = value
                            .replace('shortdashdotdot', '3,1,1,1,1,1,')
                            .replace('shortdashdot', '3,1,1,1')
                            .replace('shortdot', '1,1,')
                            .replace('shortdash', '3,1,')
                            .replace('longdash', '8,3,')
                            .replace(/dot/g, '1,3,')
                            .replace('dash', '4,3,')
                            .replace(/,$/, '')
                            .split(','); // ending comma

                            i = value.length;
                            while (i--) {
                                /**^
                                 * fix(#1471) for floating point dash lenght or dash gap
                                 */
                                value[i] = parseFloat(value[i]) * hash['stroke-width'];
                                /* EOP ^*/
                            }

                            value = value.join(',');
                        }

                    // special
                    } else if (key === 'isTracker') {
                        this[key] = value;

                    // IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
                    // is unable to cast them. Test again with final IE9.
                    } else if (key === 'width') {
                        value = pInt(value);

                    // Text alignment
                    } else if (key === 'align') {
                        key = 'text-anchor';
                        value = {
                            left: 'start',
                            center: 'middle',
                            right: 'end'
                        }
                        [value];
                    }



                    // jQuery animate changes case
                    if (key === 'strokeWidth') {
                        key = 'stroke-width';
                    }

                    // Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)
                    if (isWebKit && key === 'stroke-width' && value === 0) {
                        value = 0.000001;
                    }

                    // symbols
                    if (this.symbolName && /^(x|y|r|start|end|innerR)/.test(key)) {


                        if (!hasSetSymbolSize) {
                            this.symbolAttr(hash);
                            hasSetSymbolSize = true;
                        }
                        skipAttr = true;
                    }

                    // let the shadow follow the main element
                    /**^
                     * Apply shadow opacity using attr
                     */
                    if (shadows && (key === 'opacity' || key === 'stroke-opacity')) {
                        shadowStrength = 0.06 * value;
                        for (i = 0, l = shadows.length; i < l;) {
                            attr(shadows[i], key,
                                (i += 1) * shadowStrength);
                        }
                    }
                    /* EOP ^*/
                    if (shadows && /^(width|height|visibility|x|y|d)$/.test(key)) {
                        i = shadows.length;
                        while (i--) {
                            attr(shadows[i], key, value);
                        }
                    }

                    // validate heights
                    if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
                        value = 0;
                    }

                    if (key === 'text') {
                        // only one node allowed
                        this.textStr = value;
                        if (this.added) {
                            renderer.buildText(this);
                        }
                    } else if (!skipAttr) {
                        //element.setAttribute(key, value);
                        attr(element, key, value);
                    }

                }

            }
            return ret;
        },

        /**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
        symbolAttr: function(hash) {
            var wrapper = this;

            each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR'], function(key) {
                wrapper[key] = pick(hash[key], wrapper[key]);
            });

            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](
                    mathRound(wrapper.x * 2) / 2, // Round to halves. Issue #274.
                    mathRound(wrapper.y * 2) / 2,
                    wrapper.r,
                    {
                        start: wrapper.start,
                        end: wrapper.end,
                        width: wrapper.width,
                        height: wrapper.height,
                        innerR: wrapper.innerR
                    })
            });
        },

        /**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
        clip: function(clipRect) {
            return this.attr('clip-path', 'url(\''+ this.renderer.url +'#'+ clipRect.id +'\')'); // #FCXT-28
        },

        /**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
        crisp: function(strokeWidth, x, y, width, height) {
            var wrapper = this,
            key,
            attr = {},
            values = {},
            normalizer;

            strokeWidth = strokeWidth || wrapper.strokeWidth || 0;
            normalizer = strokeWidth % 2 / 2;

            // normalize for crisp edges
            values.x = mathFloor(x || wrapper.x || 0) + normalizer;
            values.y = mathFloor(y || wrapper.y || 0) + normalizer;
            values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
            values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
            values.strokeWidth = strokeWidth;

            /**^
             * nonZero width should not be zero due to crisp
             */
            if (values.width === 0 && width !== 0) {
                values.width = 1;
            }
            /* EOP ^*/
            for (key in values) {
                if (wrapper[key] !== values[key]) { // only set attribute if changed
                    wrapper[key] = attr[key] = values[key];
                }
            }

            return attr;
        },

        /**
	 * Set styles for the element
	 * @param {Object} styles
	 */
        css: function(styles) {
            var elemWrapper = this,
            elem = elemWrapper.element,
            textWidth = styles && styles.width && elem.nodeName === 'text',
            n,
            serializedCss = '',
            hyphenate = function(a, b){
                return '-'+ b.toLowerCase();
            };

            // convert legacy
            if (styles && styles.color) {
                styles.fill = styles.color;
            }

            // Merge the new styles with the old ones
            styles = extend(
                elemWrapper.styles,
                styles
                );


            // store object
            elemWrapper.styles = styles;


            // serialize and set style attribute
            if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
                if (textWidth) {
                    delete styles.width;
                }
                css(elemWrapper.element, styles);
            } else {
                for (n in styles) {
                    serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':'+ styles[n] + ';';
                }
                elemWrapper.attr({
                    style: serializedCss
                });
            }


            // re-build text
            if (textWidth && elemWrapper.added) {
                elemWrapper.renderer.buildText(elemWrapper);
            }

            return elemWrapper;
        },

        /**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
        on: function(eventType, handler) {
            var fn = handler;
            // touch
            if (hasTouch && eventType === 'click') {
                eventType = 'touchstart';
                fn = function(e) {
                    e.preventDefault();
                    handler();
                };
            }
            // simplest possible event model for internal use
            this.element['on'+ eventType] = fn;
            return this;
        },


        /**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
        translate: function(x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        },

        /**
	 * Invert a group, rotate and flip
	 */
        invert: function() {
            var wrapper = this;
            wrapper.inverted = true;
            wrapper.updateTransform();
            return wrapper;
        },

        /**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
        updateTransform: function() {
            var wrapper = this,
            translateX = wrapper.translateX || 0,
            translateY = wrapper.translateY || 0,
            inverted = wrapper.inverted,
            rotation = wrapper.rotation,
            transform = [];

            // flipping affects translate as adjustment for flipping around the group's axis
            if (inverted) {
                translateX += wrapper.attr('width');
                translateY += wrapper.attr('height');
            }

            // apply translate
            if (translateX || translateY) {
                transform.push('translate('+ translateX +','+ translateY +')');
            }

            // apply rotation
            if (inverted) {
                transform.push('rotate(90) scale(-1,1)');
            } else if (rotation) { // text rotation
                transform.push('rotate('+ rotation +' '+ wrapper.x +' '+ wrapper.y +')');
            }

            if (transform.length) {
                attr(wrapper.element, 'transform', transform.join(' '));
            }
        },

        /**^
         *
         */

        rotate : function (rotation, x, y) {
            this.x = x;
            this.y = y;
            return this.attr({
                translateX: x,
                translateY: y,
                rotation : rotation
            });
        },

        /**^ EOP*/

        /**
	 * Bring the element to the front
	 */
        toFront: function() {
            var element = this.element;
            element.parentNode.appendChild(element);
            return this;
        },


        /**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {Object} box The box to align to, needs a width and height
	 *
	 */
        align: function(alignOptions, alignByTranslate, box) {
            var elemWrapper = this;

            if (!alignOptions) { // called on resize
                alignOptions = elemWrapper.alignOptions;
                alignByTranslate = elemWrapper.alignByTranslate;
            } else { // first call on instanciate
                elemWrapper.alignOptions = alignOptions;
                elemWrapper.alignByTranslate = alignByTranslate;
                if (!box) { // boxes other than renderer handle this internally
                    elemWrapper.renderer.alignedObjects.push(elemWrapper);
                }
            }

            box = pick(box, elemWrapper.renderer);

            var align = alignOptions.align,
            vAlign = alignOptions.verticalAlign,
            x = (box.x || 0) + (alignOptions.x || 0), // default: left align
            y = (box.y || 0) + (alignOptions.y || 0), // default: top align
            attribs = {};


            // align
            if (/^(right|center)$/.test(align)) {
                x += (box.width - (alignOptions.width || 0) ) /
                {
                    right: 1,
                    center: 2
                }
                [align];
            }
            attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


            // vertical align
            if (/^(bottom|middle)$/.test(vAlign)) {
                y += (box.height - (alignOptions.height || 0)) /
                ({
                    bottom: 1,
                    middle: 2
                }
                [vAlign] || 1);

            }
            attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

            // animate only if already placed
            elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
            elemWrapper.placed = true;
            elemWrapper.alignAttr = attribs;

            return elemWrapper;
        },

        /**
	 * Get the bounding box (width, height, x and y) for the element
	 */
        getBBox: function() {
            var bBox,
            width,
            height,
            rotation = this.rotation,
            rad = rotation * deg2rad;

            try { // fails in Firefox if the container has display: none
                // use extend because IE9 is not allowed to change width and height in case
                // of rotation (below)
                bBox = extend({}, this.element.getBBox());
            } catch(e) {
                bBox = {
                    width: 0,
                    height: 0
                };
            }
            width = bBox.width;
            height = bBox.height;

            // adjust for rotated text
            if (rotation) {
                bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
            }

            return bBox;
        },

        /* *
	 * Manually compute width and height of rotated text from non-rotated. Shared by SVG and VML
	 * @param {Object} bBox
	 * @param {number} rotation
	 * /
	rotateBBox: function(bBox, rotation) {
		var rad = rotation * math.PI * 2 / 360, // radians
			width = bBox.width,
			height = bBox.height;


	},*/

        /**
	 * Show the element
	 */
        show: function() {
            return this.attr({
                visibility: VISIBLE
            });
        },

        /**
	 * Hide the element
	 */
        hide: function() {
            return this.attr({
                visibility: HIDDEN
            });
        },

        /**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *    to append the element to the renderer.box.
	 */
        add: function(parent) {

            var renderer = this.renderer,
            parentWrapper = parent || renderer,
            parentNode = parentWrapper.element || renderer.box,
            childNodes = parentNode.childNodes,
            element = this.element,
            zIndex = attr(element, 'zIndex'),
            otherElement,
            otherZIndex,
            i;

            // mark as inverted
            this.parentInverted = parent && parent.inverted;

            // build formatted text
            if (this.textStr !== undefined) {
                renderer.buildText(this);
            }

            // mark the container as having z indexed children
            if (zIndex) {
                parentWrapper.handleZ = true;
                zIndex = pInt(zIndex);
            }

            // insert according to this and other elements' zIndex
            if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
                for (i = 0; i < childNodes.length; i++) {
                    otherElement = childNodes[i];
                    otherZIndex = attr(otherElement, 'zIndex');
                    if (otherElement !== element && (
                        // insert before the first element with a higher zIndex
                        pInt(otherZIndex) > zIndex ||
                        // if no zIndex given, insert before the first element with a zIndex
                        (!defined(zIndex) && defined(otherZIndex))

                        )) {
                        parentNode.insertBefore(element, otherElement);
                        return this;
                    }
                }
            }

            // default: append at the end
            parentNode.appendChild(element);

            this.added = true;

            return this;
        },

        /**
	 * Destroy the element and element wrapper
	 */
        destroy: function() {
            var wrapper = this,
            element = wrapper.element || {},
            shadows = wrapper.shadows,
            parentNode = element.parentNode,
            key;

            // remove events
            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
            stop(wrapper); // stop running animations

            // remove element
            if (parentNode) {
                parentNode.removeChild(element);
            }

            // destroy shadows
            if (shadows) {
                each(shadows, function(shadow) {
                    parentNode = shadow.parentNode;
                    if (parentNode) { // the entire chart HTML can be overwritten
                        parentNode.removeChild(shadow);
                    }
                });
            }
            /**^
             * Verified whether the wrapper has aligned object and then deleted
             * them.
             */
            if (wrapper.renderer.alignedObjects) {
                erase(wrapper.renderer.alignedObjects, wrapper);
            }
            /* EOP ^*/


            for (key in wrapper) {
                delete wrapper[key];
            }

            return null;
        },

        /**
	 * Empty a group element
	 */
        empty: function() {
            var element = this.element,
            childNodes = element.childNodes,
            i = childNodes.length;

            while (i--) {
                element.removeChild(childNodes[i]);
            }
        },

        /**^
         * Updated shadow function
         * Calculated shadow offset in case of thick border.
         * Also calculate base opacity.
         */
        /**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean} apply
	 */
        shadow: function(apply, group, options) {
            if (!options) {
                options = {};
            }

            var shadows = [],
            i,
            shadow,
            element = this.element,
            // compensate for inverted plot area (XOR Gate)
            color = options.color || 'rgb(0,0,0)',
            transform = 'translate' + (!this.parentInverted != !options.inverted ?
                '(-1,-1)' : '(1,1)'),
            offset = pInt(this.attr('stroke-width') || 1, 10) + 6,
            opacity = pluck(options.opacity, 1) * 0.06;
            /* EOP ^*/

            if (apply) {
                for (i = 1; i <= 3; i++) {
                    shadow = element.cloneNode(0);
                    attr(shadow, {
                        'isShadow': 'true',
                        'stroke': color,
                        'stroke-opacity': opacity * i,
                        /**^
                         * Applied shadow offset and adda shadowIndex
                         * for later tracking
                         */
                        'stroke-width':  offset - 2 * i,
                        /* EOP ^*/
                        'transform': transform,
                        'fill': NONE
                    });

                    if (group) {
                        group.element.appendChild(shadow);
                    } else {
                        element.parentNode.insertBefore(shadow, element);
                    }

                    shadows.push(shadow);
                }

                this.shadows = shadows;
            }
            return this;

        },

        /**^
         * Text boundary element
         */
        textBound: function () {
            var wrapper = this,
            renderer = wrapper.renderer,
            bound = wrapper.textBoundWrapper,
            styles = wrapper.styles,
            pad = 4, halfpad = pad * 0.5, qhalfpad = halfpad * 0.75,
            bbox, x, y, w, h;

            if (wrapper.element.nodeName !== 'text' ||
                !styles || !(styles.backgroundColor || styles.borderColor) ||
                !wrapper.textStr || (wrapper.rotation % 90 !== 0)) {
                if (wrapper.textBoundWrapper) {
                    wrapper.textBoundWrapper.destroy();
                }
                return wrapper;
            }

            bbox = wrapper.getBBox();
            w = bbox.width + pad;
            h = bbox.height + pad;
            x = bbox.x;
            y = bbox.y;

            if (wrapper.rotation === 270) {
                x = wrapper.attr('x') - w / 2 - halfpad;
                y = wrapper.attr('y') - h + pad;
            }

            if (!bound) {
                bound = wrapper.textBoundWrapper = renderer.rect(0, 0, 0, 0, 0, 1);
                wrapper.element.parentNode.insertBefore(bound.element, wrapper.element);
            }
            bound.attr({
                fill: styles.backgroundColor || NONE,
                stroke: styles.borderColor || BLANKSTRING,
                'fill-opacity': pluck(styles.backgroundOpacity, 1),
                'stroke-opacity': pluck(styles.borderOpacity, 1)
            });

            bound.attr(bound.crisp(1, x - qhalfpad, y - qhalfpad, w, h));
        }
    /* EOP ^*/
    };

    /**
     * The default SVG renderer
     */
    var SVGRenderer = function() {
        this.init.apply(this, arguments);
    };
    SVGRenderer.prototype = {

        Element: SVGElement,

        /**^
         * Define renderer type for identification
         */
        type: 'SVG',
        /* EOP ^*/

        /**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
        init: function(container, width, height, forExport) {
            var renderer = this,
            loc = location,
            boxWrapper;

            boxWrapper = renderer.createElement('svg')
            .attr({
                xmlns: SVG_NS,
                version: '1.1'
            });
            container.appendChild(boxWrapper.element);

            // object properties
            renderer.box = boxWrapper.element;
            renderer.boxWrapper = boxWrapper;
            renderer.alignedObjects = [];
            renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, ''); // page url used for internal references
            renderer.defs = this.createElement('defs').add();
            renderer.forExport = forExport;

            renderer.setSize(width, height, false);

        },


        /**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
        createElement: function(nodeName) {
            var wrapper = new this.Element();
            wrapper.init(this, nodeName);
            return wrapper;
        },


        /**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
        buildText: function(wrapper) {
            var textNode = wrapper.element,
            lines = pick(wrapper.textStr, '').toString()
            .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
            .replace(/<(i|em)>/g, '<span style="font-style:italic">')
            .replace(/<a/g, '<span')
            .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
            .split(/<br.*?>/g),
            childNodes = textNode.childNodes,
            styleRegex = /style="([^"]+)"/,
            hrefRegex = /href="([^"]+)"/,
            parentX = attr(textNode, 'x'),
            textStyles = wrapper.styles,
            reverse = isFirefox && textStyles && textStyles.HcDirection === 'rtl' &&
            !this.forExport && pInt(userAgent.split('Firefox/')[1]) < 4, // issue #38
            arr,
            width = textStyles && pInt(textStyles.width),
            textLineHeight = textStyles && textStyles.lineHeight,
            lastLine,
            GET_COMPUTED_STYLE = 'getComputedStyle',
            i = childNodes.length;

            // remove old text
            while (i--) {
                textNode.removeChild(childNodes[i]);
            }

            if (width && !wrapper.added) {
                this.box.appendChild(textNode); // attach it to the DOM to read offset width
            }
            /**^
             * To support the title of text
             * @source 2146/2.1.4
             */
            var titleRegex = /title="([^"]+)"/;
            if (titleRegex.test(lines[0])) {
                attr(
                    textNode,
                    'title',
                    lines[0].match(titleRegex)[1]
                    );
            }
            /* EOP 2146/2.1.4 ^*/


            each(lines, function(line, lineNo) {
                var spans, spanNo = 0, lineHeight;

                line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
                spans = line.split('|||');

                each(spans, function (span) {
                    if (span !== '' || spans.length === 1) {
                        var attributes = {},
                        tspan = doc.createElementNS(SVG_NS, 'tspan');
                        if (styleRegex.test(span)) {
                            attr(
                                tspan,
                                'style',
                                span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
                                );
                        }
                        if (hrefRegex.test(span)) {
                            attr(tspan, 'onclick', 'location.href=\"'+ span.match(hrefRegex)[1] +'\"');
                            css(tspan, {
                                cursor: 'pointer'
                            });
                        }


                        span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>');

                        // issue #38 workaround.
                        if (reverse) {
                            arr = [];
                            i = span.length;
                            while (i--) {
                                arr.push(span.charAt(i));
                            }
                            span = arr.join('');
                        }

                        // add the text node
                        var aaa = doc.createTextNode(span)
                        tspan.appendChild(aaa);

                        if (!spanNo) { // first span in a line, align it to the left
                            attributes.x = parentX;
                        } else {
                            // Firefox ignores spaces at the front or end of the tspan
                            attributes.dx = 3; // space
                        }

                        // first span on subsequent line, add the line height
                        if (!spanNo) {
                            if (lineNo) {

                                // allow getting the right offset height in exporting in IE
                                if (!hasSVG && wrapper.renderer.forExport) {
                                    css(tspan, {
                                        display: 'block'
                                    });
                                }

                                // Webkit and opera sometimes return 'normal' as the line height. In that
                                // case, webkit uses offsetHeight, while Opera falls back to 18
                                lineHeight = win[GET_COMPUTED_STYLE] &&
                                pInt(win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height'));

                                if (!lineHeight || isNaN(lineHeight)) {
                                    lineHeight = textLineHeight || lastLine.offsetHeight || 18;
                                }
                                attr(tspan, 'dy', lineHeight);
                            }
                            lastLine = tspan; // record for use in next line
                        }

                        // add attributes
                        attr(tspan, attributes);

                        // append it
                        textNode.appendChild(tspan);

                        spanNo++;

                        // check width and apply soft breaks
                        if (width) {
                            var words = span.replace(/-/g, '- ').split(' '),
                            tooLong,
                            actualWidth,
                            rest = [];

                            while (words.length || rest.length) {
                                actualWidth = textNode.getBBox().width;
                                tooLong = actualWidth > width;
                                if (!tooLong || words.length === 1) { // new line needed
                                    words = rest;
                                    rest = [];
                                    if (words.length) {
                                        tspan = doc.createElementNS(SVG_NS, 'tspan');
                                        attr(tspan, {
                                            dy: textLineHeight || 16,
                                            x: parentX
                                        });
                                        textNode.appendChild(tspan);

                                        if (actualWidth > width) { // a single word is pressing it out
                                            width = actualWidth;
                                        }
                                    }
                                } else { // append to existing line tspan
                                    tspan.removeChild(tspan.firstChild);
                                    rest.unshift(words.pop());
                                }
                                if (words.length) {
                                    tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
                                }
                            }
                        }
                    }
                });
            });


        },

        /**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
        crispLine: function(points, width) {
            // points format: [M, 0, 0, L, 100, 0]
            // normalize to a crisp line
            if (points[1] === points[4]) {
                points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
            }
            if (points[2] === points[5]) {
                points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
            }
            return points;
        },


        /**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
        path: function (path) {
            return this.createElement('path').attr({
                d: path,
                fill: NONE
            });
        },

        /**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
        circle: function (x, y, r) {
            var attr = isObject(x) ?
            x :
            {
                x: x,
                y: y,
                r: r
            };

            return this.createElement('circle').attr(attr);
        },

        /**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
        arc: function (x, y, r, innerR, start, end) {
            // arcs are defined as symbols for the ability to set
            // attributes in attr and animate

            if (isObject(x)) {
                y = x.y;
                r = x.r;
                innerR = x.innerR;
                start = x.start;
                end = x.end;
                x = x.x;
            }

            return this.symbol('arc', x || 0, y || 0, r || 0, {
                innerR: innerR || 0,
                start: start || 0,
                end: end || 0
            });
        },

        /**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
        rect: function (x, y, width, height, r, strokeWidth) {
            if (isObject(x)) {
                y = x.y;
                width = x.width;
                height = x.height;
                r = x.r;
                strokeWidth = x.strokeWidth;
                x = x.x;
            }
            var wrapper = this.createElement('rect').attr({
                rx: r,
                ry: r,
                fill: NONE
            });

            return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
        },

        /**^
	 * - 3D rectangle drawing methode in renderer
         * - text boundary
	 * @source 2372/2.1.4
	 */
        // helper function to draw a 3d column
        
        rect3d: (function () {
            //list of attr that will handled here
            var attrList = {
                x : {//if x change then redraw top, right and front element
                    drawTop : true,
                    drawRight : true,
                    drawFront : true,
                    drawShadow: true
                },
                y : {
                    drawTop : true,
                    drawRight : true,
                    drawFront : true,
                    drawShadow: true
                },
                width : {
                    drawTop : true,
                    drawRight : true,
                    drawFront : true,
                    drawShadow: true
                },
                height : {
                    drawRight : true,
                    drawFront : true,
                    drawShadow: true
                },
                strokeWidth : true,
                'stroke-width' : true,
                stroke : true,
                x3D : {
                    drawTop : true,
                    drawRight : true,
                    drawShadow: true
                },
                y3D : {
                    drawTop : true,
                    drawRight : true,
                    drawShadow: true
                },
                fill : true
            },
            attr = function (hash, val) {
                var key,
                value,
                modificationList,
                ret = this,
                color,
                alpha,
                colorObject,
                attr3D = this['_3dAttr'];

                // single key-value pair
                if (isString(hash) && defined(val)) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }

                // used as a getter: first argument is a string, second is undefined
                if (isString(hash)) {
                    //if belongs from the list then handle here
                    if (attrList[hash]) {
                        ret = this['_3dAttr'][hash];
                    }
                    else {//else leve for the original attr
                        ret = this['_attr'](hash);
                    }

                // setter
                } else {

                    for (key in hash) {
                        value = hash[key];

                        //if belongs from the list then handle here
                        if (attrList[key]) {
                            //if there has any modiffication list avaiable the use it
                            modificationList = attrList[key];
                            //store the att in attr3D for further use
                            attr3D[key] = value;
                            //if it is 'stroke', 'stroke-width' or 'strokeWidth' the set the attr for all the 3 element
                            if (key === 'stroke' || key === 'stroke-width' || key === 'strokeWidth') {
                                this.frontRect.attr(key, value);
                                this.topRect.attr(key, value);
                                this.rightRect.attr(key, value);
                            }
                            //if it is 'fill' or 'lighting3D' the redefine the colors for all the 3 elements
                            if (key === 'fill') {
                                if (value && value.linearGradient && value.stops && value.stops[0]) {
                                    value = value.stops[0][1];
                                }

                                if (startsRGBA.test(value)) {
                                    colorObject = Color(value);
                                    color = colorObject.get('hex');
                                    alpha = colorObject.get('a') * 100;
                                }
                                else if (value && value.FCcolor) {
                                    color = value.FCcolor.color.split(COMMASTRING)[0];
                                    alpha = value.FCcolor.alpha.split(COMMASTRING)[0]
                                }
                                else if (hexcode.test(value)) {
                                    color = value.replace(dropHash, HASHSTRING);
                                    alpha = 100;
                                }

                                attr3D.color = color;
                                attr3D.alpha = alpha;

                                if (attr3D.lighting3D === false) {
                                    attr3D.frontColor = convertColor(attr3D.color, attr3D.alpha);
                                    attr3D.rightColor = convertColor(getDarkColor(attr3D.color, 60), attr3D.alpha);
                                    attr3D.topColor = convertColor(getDarkColor(attr3D.color, 75), attr3D.alpha);
                                }
                                else {
                                    attr3D.frontColor = {
                                        FCcolor : {
                                            color : getDarkColor(attr3D.color, 65) + COMMASTRING + getLightColor(attr3D.color, 55),
                                            alpha : alpha + COMMASTRING + alpha,
                                            angle : 270
                                        }
                                    },
                                    attr3D.rightColor = {
                                        FCcolor : {
                                            color : getDarkColor(attr3D.color, 35) + COMMASTRING + getDarkColor(attr3D.color, 75),
                                            alpha : alpha + COMMASTRING + alpha,
                                            angle : getAngle (attr3D.x3D, attr3D.height + attr3D.y3D, 3)
                                        }
                                    },
                                    attr3D.topColor = {
                                        FCcolor : {
                                            color : getDarkColor(attr3D.color, 85) + COMMASTRING + getLightColor(attr3D.color, 35),
                                            alpha : alpha + COMMASTRING + alpha,
                                            angle : getAngle (attr3D.width + attr3D.x3D, attr3D.y3D, 4)
                                        }
                                    }
                                }
                                this.topRect.attr({
                                    fill : attr3D.topColor
                                });
                                this.rightRect.attr({
                                    fill : attr3D.rightColor
                                });
                                this.frontRect.attr({
                                    fill : attr3D.frontColor
                                });
                            }
                            if (modificationList.drawTop) {
                                //during resizing recalculate angle of the color and set the color also
                                if (attr3D.lighting3D !== false && attr3D.topColor.FCcolor) {
                                    attr3D.topColor.FCcolor.angle = getAngle (attr3D.width + attr3D.x3D,
                                        attr3D.y3D, 4)
                                }
                                this.topRect.attr({
                                    d : ['M', attr3D.x, attr3D.y, 'L', attr3D.x + attr3D.width,
                                    attr3D.y, attr3D.x + attr3D.width + attr3D.x3D, attr3D.y - attr3D.y3D,
                                    attr3D.x + attr3D.x3D, attr3D.y - attr3D.y3D, 'Z'],
                                    fill : attr3D.topColor
                                });
                            }

                            if (modificationList.drawRight) {
                                if (attr3D.lighting3D !== false && attr3D.rightColor.FCcolor) {
                                    attr3D.rightColor.FCcolor.angle = getAngle (attr3D.x3D,
                                        attr3D.height + attr3D.y3D, 3)
                                }
                                this.rightRect.attr({
                                    d : ['M', attr3D.x + attr3D.width, attr3D.y, 'L', attr3D.x +
                                    attr3D.width + attr3D.x3D, attr3D.y - attr3D.y3D, attr3D.x +
                                    attr3D.width + attr3D.x3D, attr3D.y - attr3D.y3D + attr3D.height,
                                    attr3D.x + attr3D.width, attr3D.y + attr3D.height, 'Z'],
                                    fill : attr3D.rightRect
                                });
                            }
                            if (modificationList.drawFront) {
                                this.frontRect.attr(key, value);
                            }

                            if (modificationList.drawShadow) {
                                
                                this.shadowElement.attr({
                                    d: ['M', attr3D.x + attr3D.x3D, attr3D.y - attr3D.y3D, 'L', attr3D.x + attr3D.x3D + attr3D.width, attr3D.y - attr3D.y3D, attr3D.x + attr3D.x3D + attr3D.width, attr3D.y - attr3D.y3D + attr3D.height]
                                });
                            }
                        }
                        else {//else leve for the original attr
                            this['_attr'](key, value);
                        }
                    }

                }
                return ret;
            },

            shadow = function () {
                var silhuette = this.shadowElement;
                if (shadow) {
                    silhuette.shadow.apply(silhuette, arguments);
                }
            };

            return function (x, y, width, height, x3D, y3D, strokeWidth, gStr) {
                if (isObject(x)) {
                    y = x.y;
                    width = x.width;
                    height = x.height;
                    strokeWidth = x.strokeWidth;
                    x3D = x.x3D;
                    y3D = x.y3D;
                    x = x.x;
                }

                x3D = pluckNumber(x3D, 10);
                y3D = pluckNumber(y3D, 10);

                var frontShapeargs = {
                    x : x,
                    y : y,
                    width : width,
                    height : height,
                    r : 0//NOTE: for IE r must be provided
                },
                top = ['M', x, y, 'L', x + width, y, x + width + x3D, y - y3D, x + x3D, y - y3D, 'Z'],
                right = ['M', x + width, y, 'L', x + width + x3D, y - y3D,
                x + width + x3D, y - y3D + height, x + width, y + height, 'Z'],
                silhuette = ['M', x + x3D, y - y3D, 'L', x + x3D + width, y - y3D, x + x3D + width, y - y3D + height],
                renderer = this,

                rect3D = renderer.g(gStr);

                rect3D.shadowElement = renderer.path(silhuette)
                .add(rect3D);

                rect3D.frontRect = renderer.rect(frontShapeargs)
                .attr({
                    'stroke-width' : strokeWidth
                })
                .add(rect3D);

                rect3D.topRect = renderer.path(top)
                .attr({
                    'stroke-width' : strokeWidth
                })
                .add(rect3D);

                rect3D.rightRect = renderer.path(right)
                .attr({
                    'stroke-width' : strokeWidth
                })
                .add(rect3D);

                //modify the attr function of the group so that it can handle 3d attrs
                //store the old function
                rect3D['_attr'] = rect3D.attr;
                //add the new attr function
                rect3D.attr = attr;

                // Replace the shadow function with a modified version.
                rect3D.shadow = shadow;

                //store the 3d attr(requared in new attr function to change any related
                //                  attr modiffiaction)
                rect3D['_3dAttr'] = {
                    y : y,
                    width : width,
                    height : height,
                    x : x,
                    strokeWidth : strokeWidth,
                    x3D : x3D,
                    y3D : y3D,
                    lighting3D : renderer.lighting3D
                };

                return rect3D;
            };
        })(),
    
        //function to get the arc path
        //cX, cY, startX, startY, is not requared in SVG
        
        getArcPath : function (cX, cY, startX, startY, endX, endY, rX, rY, isClockWise, isLargeArc) {
            return [A, rX, rY, 0, isLargeArc, isClockWise, endX, endY];

        },

        /**
         * Draw scrollbar
         */
        scroller: function () {

            var pointerDownEvent = hasTouch ? 'touchstart' : 'mousedown',
            pointerUpEvent = hasTouch ? 'touchend' : 'mouseup',
            allPointerEvents = pointerDownEvent + ' ' + pointerUpEvent,

            anchorDragTrigger = function (event) {
                var end = event.type === 'dragend',
                config = event.data;

                config.dragActive = !end;
                if (!end) {
                    config.dragInitPos = config.scrollPosition;
                    config.dragStartX = event.pageX;
                    config.dragStartY = event.pageY;
                }
                else {
                    if (config.onChange) {
                        config.onChange(config.scrollPosition, false, true);
                    }
                    if (config.onEnd) {
                        config.onEnd(config.scrollPosition, false, true);
                    }
                }
                // Increase scroll-bar size for touch devices.
                if (hasTouch) {
                    config.anchor.attr('height',
                        config.anchor.attr('height') * (end ? 0.625 : 1.6));
                }
            },

            anchorDragHandler = function (event) {
                var config = event.data,
                horiz = config.horiz;

                config.group.setScrollPosition(config.dragInitPos + (horiz ?
                    (event.pageX - config.dragStartX) :
                    (event.pageY - config.dragStartY)) / config.zoneLength);
            },

            setCallback = function (change, end) {
                if (!arguments.length) {
                    return this;
                }

                var group = this,
                config = this.config,
                anchorEle = group.elements.anchor.element;

                /*addEvent(anchorEle, 'drag', null, config);
                addEvent(group.elements.track.element, pointerDownEvent, null, config);

                if (config.buttons) {
                    addEvent([group.elements.start.element,
                        group.elements.startArrow.element], allPointerEvents, null, config);
                    addEvent([group.elements.end.element,
                        group.elements.endArrow.element], allPointerEvents, null, config);
                }*/

                extend(config, {
                    onChange: change,
                    onEnd: end
                });

                return group;
            },

            setScrollRatio = function (value, silent) {
                var group = this,
                config = group.config;

                config.zoneLength = config.trackLength - config.trackLength *
                (config.scrollRatio = value);

                group.elements.anchor.attr({
                    width: this.config.trackLength * value
                });

                if (value >= 1) {
                    config.scrollDelta = 1;
                }
                else {
                    config.scrollDelta = 0.1;
                }

                return group.setScrollPosition(undefined, undefined, silent);
            },

            setScrollPosition = function (value, animate, silent) {
                var group = this,
                config = group.config,
                horiz = config.horiz,
                anchor = config.anchor,
                doTranslateY = isIE && !hasSVG && !horiz,
                translationValue;

                if (defined(value)) {
                    if (value <= 0) {
                        value = 0.00000001;
                    }
                    else if (value > 1) {
                        value = 1;
                    }
                    config.scrollPosition = value;
                }
                else {
                    value = config.scrollPosition;
                }

                translationValue = (horiz ? value : 1 - value) * config.zoneLength;

                // fix for no translation
                if (translationValue === 0) {
                    translationValue = 0.00000001;
                }

                if (doTranslateY) {
                    anchor.translate(undefined, -translationValue);
                }
                else {
                    anchor.translate(translationValue);
                }

                if (!silent && config.onChange) {
                    config.onChange(value, animate, true);
                }

                return group;
            },

            getColors = function (base, horiz, flat) {

                var angle = !horiz && isIE && !hasSVG ? 180 : 90,
                ret = {
                    base: base,
                    light: HASHSTRING + getLightColor(base, 15),
                    dark: HASHSTRING + getDarkColor(base, flat ? 50 : 30)
                };

                ret.darkFill = flat ? ret.dark : {
                    FCcolor: {
                        color: ret.dark + COMMASTRING + base,
                        alpha: "100",
                        angle: angle
                    }
                };
                ret.lightFill = flat ? ret.base : {
                    FCcolor: {
                        color: base + COMMASTRING + ret.light,
                        alpha: "100",
                        angle: angle
                    }
                };

                return ret;
            },

            attrScroller = function (hash) {
                var group = this,
                renderer = group.renderer,
                config = group.config,
                colors,
                darkColorFill,
                lightGradientFill;

                if (isObject(hash) && 'fill' in hash) {

                    colors = getColors(hash.fill, config.horiz, config.flat);
                    darkColorFill = {
                        fill: colors.dark
                    };
                    lightGradientFill = {
                        fill: colors.lightFill
                    };

                    if (config.buttons) {
                        group.elements.start.attr(lightGradientFill);
                        group.elements.end.attr(lightGradientFill);
                        group.elements.startArrow.attr(darkColorFill);
                        group.elements.endArrow.attr(darkColorFill);
                    }

                    group.elements.track.attr(lightGradientFill);
                    group.elements.anchor.attr({
                        fill: colors.darkFill,
                        stroke: colors.dark,
                        'stroke-width': 0.2
                    });

                    delete hash.fill;
                }

                // pass the rest of attr attributes via core attr function
                return renderer.Element.prototype.attr.apply(group, arguments);

            };

            return function (x, y, width, height, horiz, button, flat, companion) {

                // swap dimensions   in case the scroller is vertical
                // this will allow for easy calculation assuming horizontal bar
                // and then later invert it.
                if (!horiz) {
                    width += height;
                    height = width - height;
                    width = width - height;
                }

                var renderer = this,

                // create the scrollbar group.
                group = renderer.g('scroller')
                .attr({
                    translateX: x,
                    translateY: y,
                    width: width,
                    height: height
                }),

                // create objects to store config and other composite
                // elements.
                config = group.config = {},
                eles = group.elements = {},
                ele,

                buttonWidth = !button ? 0 : (button.size || height),
                buttonPadding = button && button.padding || 0,
                qW = buttonWidth * 0.25,
                qH = height * 0.25,

                trackOffset = buttonWidth + buttonPadding,
                trackLength = width - 2 * trackOffset;

                // draw the base track and anchor
                eles.track = renderer.rect(trackOffset, 0, trackLength, height, 0);
                eles.anchor = renderer.rect(trackOffset, flat ? 0 : (qH * 0.5), trackLength,
                    flat ? height : (height - qH), flat ? 0 : mathMin(qW, qH));

                // draw the buttons
                if (button) {
                    eles.start = renderer.rect(0, 0, buttonWidth, height, 0);
                    eles.startArrow = renderer.path([M, qW, 0, L, 0, qH,
                        qW, qH * 2, qW, 0]).translate(buttonWidth * 0.4, qH);
                    eles.end = renderer.rect(width - buttonWidth, 0, buttonWidth, height, 0);
                    eles.endArrow = renderer.path([M, 0, 0, L, qW, qH, 0,
                        qH * 2, 0, 0]).translate(width - buttonWidth * 0.6, qH);
                }

                // make vertical
                if (!horiz) {
                    group.attr({
                        width: height,
                        height: width
                    }).invert();
                }

                // append all the elements to the group
                for (ele in eles) {
                    eles[ele].add(group);
                }

                // store all configuration info for the scroller that might
                // be needed for later.
                extend(config, {
                    group: group,
                    anchor: eles.anchor,
                    width: width,
                    horiz: horiz,
                    flat: flat,
                    buttons: !!button,
                    scrollRatio: 1,
                    trackOffset: trackOffset,
                    trackLength: trackLength,
                    zoneLength: trackLength,
                    scrollPosition: 0,
                    scrollDelta: 0.1
                });

                // extend the group with scroller functions.
                extend(group, {
                    attr: attrScroller,
                    setScrollRatio: setScrollRatio,
                    setScrollPosition: setScrollPosition,
                    callback: setCallback
                });

                // attach pointer events
                addEvent(eles.anchor.element, 'dragstart dragend', anchorDragTrigger, config);
                addEvent(eles.anchor.element, 'drag', anchorDragHandler, config);

                if (button) {
                    addEvent([group.elements.start.element,
                        group.elements.startArrow.element], pointerDownEvent, function () {
                            group.setScrollPosition(group.config.scrollPosition - group.config.scrollDelta);
                        }, config);
                    addEvent([group.elements.end.element,
                        group.elements.endArrow.element], pointerDownEvent, function () {
                            group.setScrollPosition(group.config.scrollPosition + group.config.scrollDelta);
                        }, config);
                }

                if (companion) {
                    addEvent(companion.element, 'wheelchange', function (event, delta) {
                        group.setScrollPosition(group.config.scrollPosition - delta * 0.5)
                        event.preventDefault();
                    })
                }

                return group;
            };

        }(),

        /* EOP 2372/2.1.4 ^*/

        /**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
        setSize: function(width, height, animate) {
            var renderer = this,
            alignedObjects = renderer.alignedObjects,
            i = alignedObjects.length;

            renderer.width = width;
            renderer.height = height;

            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
                width: width,
                height: height
            });

            while (i--) {
                alignedObjects[i].align();
            }
        },

        /**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *     This can be used for styling and scripting.
	 */
        g: function(name) {
            return this.createElement('g').attr(
                defined(name) && {
                    'class': PREFIX + name
                }
                );
        },

        /**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
        image: function(src, x, y, width, height) {
            var attribs = {
                preserveAspectRatio: NONE
            },
            elemWrapper;

            // optional properties
            if (arguments.length > 1) {
                extend(attribs, {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            }

            elemWrapper = this.createElement('image').attr(attribs);

            // set the href in the xlink namespace
            if (elemWrapper.element.setAttributeNS) {
                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
                    'href', src);
            } else {
                // could be exporting in IE
                // using href throws "not supported" in ie7 and under, requries regex shim to fix later
                elemWrapper.element.setAttribute('hc-svg-href', src);
            }

            return elemWrapper;
        },

        /**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
        symbol: function(symbol, x, y, radius, options) {

            /**^
             * Allow sending in of sides via the symbolname for a polygon.
             * @source 2452/2.1.4
             */
            if (isObject(symbol)) {
                x = symbol.x,
                y = symbol.y,
                radius = symbol.radius,
                options = symbol.options,
                symbol = symbol.symbol
            }
            
            var polyRegx = /^poly\_\d+$/, sides, tempOptions;
            if (polyRegx.test(symbol)) {
                sides = pluckNumber(parseInt(symbol.split('_')[1], 10), 3);
                symbol = 'poly';
                if (typeof options !== 'object') {
                    options = {};
                }
                options.innerR = sides;//hide the side element as width
            }
            /* EOP 2452/2.1.4 ^*/

            var obj,

            // get the symbol definition function
            symbolFn = this.symbols[symbol],

            // check if there's a path defined for this symbol
            path = symbolFn && symbolFn(
                mathRound(x),
                mathRound(y),
                radius,
                options
                ),

            imageRegex = /^url\((.*?)\)$/,
            imageSrc,
            imageSize;

            if (path) {

                obj = this.path(path);
                // expando properties for use in animate and attr
                extend(obj, {
                    symbolName: symbol,
                    x: x,
                    y: y,
                    r: radius
                });
                if (options) {
                    extend(obj, options);
                }


            // image symbols
            } else if (imageRegex.test(symbol)) {

                var centerImage = function(img, size) {
                    img.attr({
                        width: size[0],
                        height: size[1]
                    }).translate(
                        -mathRound(size[0] / 2),
                        -mathRound(size[1] / 2)
                        );
                };

                imageSrc = symbol.match(imageRegex)[1];
                imageSize = symbolSizes[imageSrc];

                // create the image synchronously, add attribs async
                obj = this.image(imageSrc)
                .attr({
                    x: x,
                    y: y
                });

                if (imageSize) {
                    centerImage(obj, imageSize);
                } else {
                    // initialize image to be 0 size so export will still function if there's no cached sizes
                    obj.attr({
                        width: 0,
                        height: 0
                    });

                    // create a dummy JavaScript image to get the width and height
                    createElement('img', {
                        onload: function() {
                            var img = this;
                            centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
                        },
                        src: imageSrc
                    });
                }

            // default circles
            } else {
                obj = this.circle(x, y, radius);
            }

            return obj;
        },

        /**
	 * An extendable collection of functions for defining symbol paths.
	 */
        symbols: {
            /**^
             * Symbol to manage any sided polygon.
             * @source 2524/2.1.4
             */
            'poly' : function (x, y, radius, options) {
                // sides are sent via innerR of options
                var sides = options.innerR, angle = 2 * math.PI / sides, path, j,
                startAngle = (typeof options.startAngle !== "undefined") ? options.startAngle : math.PI / 2;
                // initialize point attr
                // move to the first point
                if (sides > 2) {
                    path = [M, x + (radius * mathCos(-startAngle)),
                    y + (radius * mathSin(-startAngle)), L];


                    //loop fpr the sides
                    for (j = 1; j < sides; j++) {
                        path.push(x + (radius * mathCos(-(startAngle + (j * angle)))));
                        path.push(y + (radius * mathSin(-(startAngle + (j * angle)))));
                    }
                    path.push('Z');
                }
                else {
                    path = [M, x, y, 'Z'];
                }

                return path;
            },
            /* EOP 2524/2.1.4 ^*/
            'square': function (x, y, radius) {
                var len = 0.707 * radius;
                return [
                M, x-len, y-len,
                L, x+len, y-len,
                x+len, y+len,
                x-len, y+len,
                'Z'
                ];
            },

            'triangle': function (x, y, radius) {
                return [
                M, x, y-1.33 * radius,
                L, x+radius, y + 0.67 * radius,
                x-radius, y + 0.67 * radius,
                'Z'
                ];
            },

            'triangle-down': function (x, y, radius) {
                return [
                M, x, y + 1.33 * radius,
                L, x-radius, y-0.67 * radius,
                x+radius, y-0.67 * radius,
                'Z'
                ];
            },
            'diamond': function (x, y, radius) {
                return [
                M, x, y-radius,
                L, x+radius, y,
                x, y+radius,
                x-radius, y,
                'Z'
                ];
            },
            'arc': function (x, y, radius, options) {
                var start = options.start,
                end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
                innerRadius = options.innerR,
                cosStart = mathCos(start),
                sinStart = mathSin(start),
                cosEnd = mathCos(end),
                sinEnd = mathSin(end),
                longArc = options.end - start < mathPI ? 0 : 1;

                return [
                M,
                x + radius * cosStart,
                y + radius * sinStart,
                'A', // arcTo
                radius, // x radius
                radius, // y radius
                0, // slanting
                longArc, // long or short arc
                1, // clockwise
                x + radius * cosEnd,
                y + radius * sinEnd,
                L,
                x + innerRadius * cosEnd,
                y + innerRadius * sinEnd,
                'A', // arcTo
                innerRadius, // x radius
                innerRadius, // y radius
                0, // slanting
                longArc, // long or short arc
                0, // clockwise
                x + innerRadius * cosStart,
                y + innerRadius * sinStart,

                'Z' // close
                ];
            }
        },

        /**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
        clipRect: function (x, y, width, height) {
            var wrapper,
            id = PREFIX + idCounter++,

            clipPath = this.createElement('clipPath').attr({
                id: id
            }).add(this.defs);

            wrapper = this.rect(x, y, width, height, 0).add(clipPath);
            wrapper.id = id;

            return wrapper;
        },


        /**
         * Take a color and return it if it's a string, make it a gradient if it's a
         * gradient configuration object
         *
         * @param {Object} color The color or config object
         */
        color: function(color, elem, prop) {
            var colorObject,
            regexRgba = /^rgba/;
            if (color && color.linearGradient) {
                var renderer = this,
                strLinearGradient = 'linearGradient',
                linearGradient = color[strLinearGradient],
                id = PREFIX + idCounter++,
                gradientObject,
                stopColor,
                stopOpacity;
                gradientObject = renderer.createElement(strLinearGradient).attr({
                    id: id,
                    gradientUnits: 'userSpaceOnUse',
                    x1: linearGradient[0],
                    y1: linearGradient[1],
                    x2: linearGradient[2],
                    y2: linearGradient[3]
                }).add(renderer.defs);

                each(color.stops, function(stop) {
                    if (regexRgba.test(stop[1])) {
                        colorObject = Color(stop[1]);
                        stopColor = colorObject.get('rgb');
                        stopOpacity = colorObject.get('a');
                    }else {
                        stopColor = stop[1];
                        stopOpacity = 1;
                    }
                    renderer.createElement('stop').attr({
                        offset: stop[0],
                        'stop-color': stopColor,
                        'stop-opacity': stopOpacity
                    }).add(gradientObject);
                });

                return 'url(\''+ this.url +'#'+ id +'\')'; // #FCXT-28

            }
            /**^
             * To support FusionCharts format of color.
             * @source 2668,10/2.1.4
             */
            else if (color && color.FCcolor) {

                var colorEl = color.FCcolor.element,
                renderer = this;

                if (colorEl && colorEl.parentNode && !renderer.forExport) {
                    return color.FCcolor.url;
                }

                var  FCcolor = pluck(color.FCcolor.color, "000000"), FCalpha = pluck(color.FCcolor.alpha, "100"),
                x, StopColor, StopAlpha, StopRatio,FCcount = 0, lastAlpah = 100,
                FCratio = pluck(color.FCcolor.ratio, "0"), FCangle = pluckNumber(color.FCcolor.angle, "0");
                //linearGradient, id, colorArr;
                //replaec all space
                FCcolor = FCcolor.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                FCalpha = FCalpha.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                FCratio = FCratio.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                FCangle = FCangle % 360;
                if (FCangle < 0) {//if negative then convert it to positive
                    FCangle = 360 + FCangle;
                }

                // Pie chart Use3DLighting
                if (color.FCcolor.radialGradient) {
                    strLinearGradient = 'radialGradient';
                    id = PREFIX + idCounter++;
                    //create linear gradient object
                    gradientObject = renderer.createElement(strLinearGradient).attr({
                        id: id,
                        gradientUnits: pluck(color.FCcolor.gradientUnits, 'userSpaceOnUse'),
                        cx: color.FCcolor.cx,
                        cy: color.FCcolor.cy,
                        r: color.FCcolor.r
                    }).add(renderer.defs);

                    for (x = 0; x < FCcolor.length && FCcount < 100; x += 1) {
                        StopColor = FCcolor[x].replace(/^#?/, '#');
                        lastAlpah = StopAlpha = pluckNumber(FCalpha[x], lastAlpah);
                        StopRatio = pluckNumber(FCratio[x], (x !== 0) ? ((100 - FCcount) / (FCcolor.length - x)) : 0);
                        FCcount += StopRatio;
                        if (FCcount > 100) {
                            FCcount = 100;
                        }
                        renderer.createElement('stop').attr({
                            'offset': FCcount + '%',
                            'stop-color': StopColor,
                            'stop-opacity': StopAlpha / 100
                        }).add(gradientObject);

                    }

                    color.FCcolor.element = gradientObject.element;
                    color.FCcolor.url = 'url(\''+ this.url +'#'+ id +'\')'; // #FCXT-28

                    return color.FCcolor.url;

                } else {
                    //if there has only 1 color
                    if (FCcolor.length === 1) {
                        attr(elem, prop +'-opacity', pluckNumber(FCalpha[0], 100) / 100);
                        return FCcolor[0].replace(/^#?/, '#');
                    }
                    else {
                        var width = 100, height = 100, x1, x2, y1, y2, tan, temp,
                        x, StopColor, StopAlpha, StopRatio, gradientObject,
                        FCcount = 0;

                        strLinearGradient = 'linearGradient';
                        linearGradient = color[strLinearGradient];
                        id = PREFIX + idCounter++;

                        tan = Math.tan((FCangle * Math.PI) / 180);
                        y1 = Math.round(height / 2 - ((width / 2) * tan));
                        x1 = Math.round(width / 2 - ((height / 2) / tan));
                        x1 = (x1 < 0) ? 0 : x1;
                        x1 = (x1 > width) ? width : x1;
                        y1 = (y1 < 0) ? 0 : y1;
                        y1 = (y1 > height) ? height : y1;
                        x2 = width - x1;
                        y2 = height - y1;
                        if (FCangle > 90 && FCangle <= 270) {
                            temp = y1;
                            y1 = y2;
                            y2 = temp;
                        }
                        if (FCangle > 180 && FCangle <= 360) {
                            temp = x1;
                            x1 = x2;
                            x2 = temp;
                        }
                        //create linear gradient object
                        gradientObject = renderer.createElement(strLinearGradient).attr({
                            id: id,
                            gradientUnits: pluck(color.FCcolor.gradientUnits, 'objectBoundingBox'),
                            x1: x1 + '%',
                            y1: y1 + '%',
                            x2: x2 + '%',
                            y2: y2 + '%'
                        }).add(renderer.defs);
                        //create Stops

                        for (x = 0; x < FCcolor.length && FCcount < 100; x += 1) {
                            StopColor = FCcolor[x].replace(/^#?/, '#');
                            lastAlpah = StopAlpha = pluckNumber(FCalpha[x], lastAlpah);
                            StopRatio = pluckNumber(FCratio[x], (x !== 0) ? ((100 - FCcount) / (FCcolor.length - x)) : 0);
                            FCcount += StopRatio;
                            if (FCcount > 100) {
                                FCcount = 100;
                            }
                            renderer.createElement('stop').attr({
                                offset: FCcount + '%',
                                'stop-color': StopColor,
                                'stop-opacity': StopAlpha / 100
                            }).add(gradientObject);
                        }

                        color.FCcolor.element = gradientObject.element;
                        color.FCcolor.url = 'url(\''+ this.url +'#'+ id +'\')'; // #FCXT-28

                        return color.FCcolor.url;
                    }
                }
            }
            /* EOP 2668,10/2.1.4 ^*/
            // Webkit and Batik can't show rgba.
            else if (regexRgba.test(color)) {
                colorObject = Color(color);
                attr(elem, prop +'-opacity', colorObject.get('a'));

                return colorObject.get('rgb');


            } else {
                return color;
            }

        },


        /**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 */
        text: function(str, x, y) {

            // declare variables
            var defaultChartStyle = defaultOptions.chart.style,
            wrapper;

            x = mathRound(pick(x, 0));
            y = mathRound(pick(y, 0));

            wrapper = this.createElement('text')
            .attr({
                x: x,
                y: y,
                text: str
            })
            .css({
                fontFamily: defaultChartStyle.fontFamily,
                fontSize: defaultChartStyle.fontSize
            });

            wrapper.x = x;
            wrapper.y = y;
            return wrapper;
        }
    }; // end SVGRenderer

    // general renderer
    Renderer = SVGRenderer;



/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/
    var VMLRenderer;
    if (!hasSVG) {

        /**
         * The VML element wrapper.
         */
        var VMLElement = extendClass( SVGElement, {

            /**^
             * Define type of renderer for identification
             */
            type: 'VML',
            /* EOP ^*/

            /**
             * Initialize a new VML element wrapper. It builds the markup as a string
             * to minimize DOM traffic.
             * @param {Object} renderer
             * @param {Object} nodeName
             */
            init: function(renderer, nodeName) {
                var markup =  ['<', nodeName, ' filled="f" stroked="f"'],
                style = ['position: ', ABSOLUTE, ';'];

                // divs and shapes need size
                if (nodeName === 'shape' || nodeName === DIV) {
                    style.push('left:0;top:0;width:10px;height:10px;');
                }
                if (docMode8) {
                    style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
                }

                markup.push(' style="', style.join(''), '"/>');

                // create element with default attributes and style
                if (nodeName) {
                    markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ?
                    markup.join('')
                    : renderer.prepVML(markup);
                    this.element = createElement(markup);
                }

                this.renderer = renderer;
            },

            /**
             * Add the node to the given parent
             * @param {Object} parent
             */
            add: function(parent) {
                var wrapper = this,
                renderer = wrapper.renderer,
                element = wrapper.element,
                box = renderer.box,
                inverted = parent && parent.inverted,

                // get the parent node
                parentNode = parent ?
                parent.element || parent :
                box;


                // if the parent group is inverted, apply inversion on all children
                if (inverted) { // only on groups
                    renderer.invertChild(element, parentNode);
                }

                // issue #140 workaround - related to #61 and #74
                if (docMode8 && parentNode.gVis === HIDDEN) {
                    css(element, {
                        visibility: HIDDEN
                    });
                }

                // append it
                parentNode.appendChild(element);

                // align text after adding to be able to read offset
                wrapper.added = true;
                if (wrapper.alignOnAdd) {
                    wrapper.updateTransform();
                }

                return wrapper;
            },

            /**
             * Get or set attributes
             */
            attr: function(hash, val) {
                var key,
                value,
                i,
                /**^
                 * Extra function scope variables
                 */
                l,
                shadowStrength,
                /* EOP ^*/
                element = this.element || {},
                elemStyle = element.style,
                nodeName = element.nodeName,
                renderer = this.renderer,
                symbolName = this.symbolName,
                childNodes,
                hasSetSymbolSize,
                shadows = this.shadows,
                skipAttr,
                ret = this;

                // single key-value pair
                if (isString(hash) && defined(val)) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }

                // used as a getter, val is undefined
                if (isString(hash)) {
                    key = hash;
                    if (key === 'strokeWidth' || key === 'stroke-width') {
                        ret = this.strokeweight;
                    } else {
                        ret = this[key];
                    }

                // setter
                } else {
                    for (key in hash) {
                        value = hash[key];
                        skipAttr = false;

                        // prepare paths
                        // symbols
                        if (symbolName && /^(x|y|r|start|end|width|height|innerR)/.test(key)) {
                            // if one of the symbol size affecting parameters are changed,
                            // check all the others only once for each call to an element's
                            // .attr() method
                            if (!hasSetSymbolSize) {
                                this.symbolAttr(hash);

                                hasSetSymbolSize = true;
                            }

                            skipAttr = true;

                        } else if (key === 'd') {
                            value = value || [];
                            this.d = value.join(' '); // used in getter for animation

                            // convert paths
                            i = value.length;
                            var convertedPath = [];
                            while (i--) {

                                // Multiply by 10 to allow subpixel precision.
                                // Substracting half a pixel seems to make the coordinates
                                // align with SVG, but this hasn't been tested thoroughly
                                if (isNumber(value[i])) {
                                    convertedPath[i] = mathRound(value[i] * 10) - 5;
                                }
                                // close the path
                                else if (value[i] === 'Z') {
                                    convertedPath[i] = 'x';
                                }
                                else {
                                    convertedPath[i] = value[i];
                                }

                            }
                            value = convertedPath.join(' ') || 'x';
                            element.path = value;

                            // update shadows
                            if (shadows) {
                                i = shadows.length;
                                while (i--) {
                                    shadows[i].path = value;
                                }
                            }
                            skipAttr = true;

                        // directly mapped to css
                        } else if (key === 'zIndex' || key === 'visibility') {

                            // issue 61 workaround
                            if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
                                element.gVis = value;
                                childNodes = element.childNodes;
                                i = childNodes.length;
                                while (i--) {
                                    css(childNodes[i], {
                                        visibility: value
                                    });
                                }
                                if (value === VISIBLE) { // issue 74
                                    value = null;
                                }
                            }

                            if (value) {
                                elemStyle[key] = value;
                            }



                            skipAttr = true;

                        // width and height
                        } else if (/^(width|height)$/.test(key)) {


                            // clipping rectangle special
                            if (this.updateClipping) {
                                this[key] = value;
                                this.updateClipping();

                            } else {
                                // normal
                                elemStyle[key] = value;
                            }

                            skipAttr = true;

                        // x and y
                        } else if (/^(x|y)$/.test(key)) {

                            this[key] = value; // used in getter

                            /**^
                             * clipping rectangle special
                             */
                            // clipping rectangle special
                            if (this.updateClipping) {
                                this[{
                                    x: 'left',
                                    y: 'top'
                                }
                                [key]] = value;
                                this.updateClipping();
                            } else
                            /* EOP ^*/
                            if (element.tagName === 'SPAN') {
                                this.updateTransform();

                            } else {
                                elemStyle[{
                                    x: 'left',
                                    y: 'top'
                                }
                                [key]] = value;
                            }
                            skipAttr = true;
                        // class name
                        } else if (key === 'class') {
                            // IE8 Standards mode has problems retrieving the className
                            element.className = value;

                        // stroke
                        } else if (key === 'stroke') {

                            value = renderer.color(value, element, key);

                            key = 'strokecolor';

                        // stroke width
                        } else if (key === 'stroke-width' || key === 'strokeWidth') {
                            element.stroked = value ? true : false;
                            key = 'strokeweight';
                            this[key] = value; // used in getter, issue #113
                            if (isNumber(value)) {
                                value += PX;
                            }
                        /**^
                         * Linecap support
                         */
                        // stroke lineCap
                        } else if (key === 'stroke-linecap' || key === 'strokeLinecap') {
                            this[key] = value; // used in getter, issue #113
                            key = 'endcap';
                            value = value === 'butt' ? 'flat' : (value || 'flat');

                            var strokeElem = element.getElementsByTagName('stroke')[0] ||
                            createElement(renderer.prepVML(['<stroke/>']), null, null, element);
                            strokeElem[key] = value;
                            skipAttr = true;
                        /* EOP ^*/

                        // dashStyle
                        } else if (key === 'dashstyle') {
                            var strokeElem = element.getElementsByTagName('stroke')[0] ||
                            createElement(renderer.prepVML(['<stroke/>']), null, null, element);
                            strokeElem[key] = value || 'solid';
                            this.dashstyle = value; /* because changing stroke-width will change the dash length
						and cause an epileptic effect */
                            skipAttr = true;

                        // fill
                        } else if (key === 'fill') {

                            if (nodeName === 'SPAN') { // text color
                                elemStyle.color = value;
                            } else {
                                element.filled = value !== NONE ? true : false;

                                value = renderer.color(value, element, key);

                                key = 'fillcolor';
                            }

                        // translation for animation
                        } else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'align') {
                            if (key === 'align') {
                                key = 'textAlign';
                            }
                            this[key] = value;
                            this.updateTransform();

                            skipAttr = true;
                        }

                        // text for rotated and non-rotated elements
                        else if (key === 'text') {
                            this.bBox = null;
                            element.innerHTML = value;
                            skipAttr = true;
                        }


                        // let the shadow follow the main element
                        if (shadows && key === 'visibility') {
                            i = shadows.length;
                            while (i--) {
                                shadows[i].style[key] = value;
                            }
                        }

                        /**^
                         * Apply shadow opacity using css
                         */
                        if (shadows && (key === 'opacity' || key === 'stroke-opacity')) {
                            shadowStrength = 6 * value; // 100 * 0.06 = 6
                            for (i = 0, l = shadows.length; i < l;) {
                                attr(shadows[i], key,
                                    (i += 1) * shadowStrength);
                            }
                        }
                        /* EOP ^*/

                        if (!skipAttr) {
                            if (docMode8) { // IE8 setAttribute bug
                                element[key] = value;
                            } else {
                                attr(element, key, value);
                            }
                        }
                    }
                }
                return ret;
            },

            /**
             * Set the element's clipping to a predefined rectangle
             *
             * @param {String} id The id of the clip rectangle
             */
            clip: function(clipRect) {
                var wrapper = this,
                clipMembers = clipRect.members;

                clipMembers.push(wrapper);
                wrapper.destroyClip = function() {
                    erase(clipMembers, wrapper);
                };
                return wrapper.css(clipRect.getCSS(wrapper.inverted));
            },

            /**
             * Set styles for the element
             * @param {Object} styles
             */
            css: function(styles) {
                var wrapper = this,
                element = wrapper.element,
                textWidth = styles && element.tagName === 'SPAN' && styles.width;

                /*if (textWidth) {
			extend(styles, {
				display: 'block',
				whiteSpace: 'normal'
			});
		}*/
                if (textWidth) {
                    delete styles.width;
                    wrapper.textWidth = textWidth;
                    wrapper.updateTransform();
                }

                wrapper.styles = extend(wrapper.styles, styles);
                css(wrapper.element, styles);

                return wrapper;
            },

            /**
             * Extend element.destroy by removing it from the clip members array
             */
            destroy: function() {
                var wrapper = this;

                if (wrapper.destroyClip) {
                    wrapper.destroyClip();
                }

                SVGElement.prototype.destroy.apply(wrapper);
            },

            /**
             * Remove all child nodes of a group, except the v:group element
             */
            empty: function() {
                var element = this.element,
                childNodes = element.childNodes,
                i = childNodes.length,
                node;

                while (i--) {
                    node = childNodes[i];
                    node.parentNode.removeChild(node);
                }
            },

            /**
             * VML override for calculating the bounding box based on offsets
             *
             * @return {Object} A hash containing values for x, y, width and height
             */

            getBBox: function() {
                var wrapper = this,
                element = wrapper.element,
                bBox = wrapper.bBox;

                if (!bBox) {
                    // faking getBBox in exported SVG in legacy IE
                    if (element.nodeName === 'text') {
                        element.style.position = ABSOLUTE;
                    }

                    bBox = wrapper.bBox = {
                        x: element.offsetLeft,
                        y: element.offsetTop,
                        width: element.offsetWidth,
                        height: element.offsetHeight
                    };
                }
                return bBox;

            },

            /**
             * Add an event listener. VML override for normalizing event parameters.
             * @param {String} eventType
             * @param {Function} handler
             */
            on: function(eventType, handler) {
                // simplest possible event model for internal use
                this.element['on'+ eventType] = function() {
                    var evt = win.event;
                    evt.target = evt.srcElement;
                    handler(evt);
                };
                return this;
            },


            /**
             * VML override private method to update elements based on internal
             * properties based on SVG transform
             */
            updateTransform: function(hash) {
                // aligning non added elements is expensive
                if (!this.added) {
                    this.alignOnAdd = true;
                    return;
                }

                var wrapper = this,
                elem = wrapper.element,
                translateX = wrapper.translateX || 0,
                translateY = wrapper.translateY || 0,
                x = wrapper.x || 0,
                y = wrapper.y || 0,
                align = wrapper.textAlign || 'left',
                alignCorrection = {
                    left: 0,
                    center: 0.5,
                    right: 1
                }
                [align],
                nonLeft = align && align !== 'left';

                // apply translate
                if (translateX || translateY) {
                    wrapper.css({
                        marginLeft: translateX,
                        marginTop: translateY
                    });
                }

                // apply inversion
                if (wrapper.inverted) { // wrapper is a group
                    each(elem.childNodes, function(child) {
                        wrapper.renderer.invertChild(child, elem);
                    });
                }

                if (elem.tagName === 'SPAN') {

                    var width, height,
                    rotation = wrapper.rotation,
                    lineHeight,
                    radians = 0,
                    costheta = 1,
                    sintheta = 0,
                    quad,
                    textWidth = pInt(wrapper.textWidth),
                    xCorr = wrapper.xCorr || 0,
                    yCorr = wrapper.yCorr || 0,
                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

                    if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed

                        if (defined(rotation)) {
                            radians = rotation * deg2rad; // deg to rad
                            costheta = mathCos(radians);
                            sintheta = mathSin(radians);

                            // Adjust for alignment and rotation.
                            // Test case: http://highcharts.com/tests/?file=text-rotation
                            css(elem, {
                                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                                ', sizingMethod=\'auto expand\')'].join('') : NONE
                            });
                        }

                        width = elem.offsetWidth;
                        height = elem.offsetHeight;

                        // update textWidth
                        if (width > textWidth) {
                            css(elem, {
                                width: textWidth +PX,
                                display: 'block',
                                whiteSpace: 'normal'
                            });
                            width = textWidth;
                        }

                        // correct x and y
                        lineHeight = mathRound((pInt(elem.style.fontSize) || 12) * 1.2);
                        xCorr = costheta < 0 && -width;
                        yCorr = sintheta < 0 && -height;

                        // correct for lineHeight and corners spilling out after rotation
                        quad = costheta * sintheta < 0;
                        xCorr += sintheta * lineHeight * (quad ? 1 - alignCorrection : alignCorrection);
                        yCorr -= costheta * lineHeight * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);

                        // correct for the length/height of the text
                        if (nonLeft) {
                            xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
                            if (rotation) {
                                yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
                            }
                            css(elem, {
                                textAlign: align
                            });
                        }

                        // record correction
                        wrapper.xCorr = xCorr;
                        wrapper.yCorr = yCorr;
                    }

                    // apply position with correction
                    css(elem, {
                        left: x + xCorr,
                        top: y + yCorr
                    });

                    // record current text transform
                    wrapper.cTT = currentTextTransform;
                }
            },
            /**^
             * added the rotation of non group element             *
             */

            rotate : function (rotation, cx, cy) {
                var wrapper = this,
                elem = wrapper.element,
                cssObj = {},
                width, height,
                radians = 0,
                costheta = 1,
                sintheta = 0,
                matrixStr,
                leftPos = wrapper.x || 0,
                topPos = wrapper.y || 0;
                cx = cx || 0;
                cy = cy || 0;


                if (defined(rotation)) {
                    rotation = Number(rotation);
                    cssObj.rotation = rotation;
                    radians = rotation * deg2rad; // deg to rad
                    costheta = mathCos(radians);
                    sintheta = mathSin(radians);
                    
                    /*css(elem, {
                        left : -cx,
                        top: -cy
                    });*/
                    if (docMode8) { // IE8 setAttribute bug
                        elem['CoordOrigin'] = (0) + ' ' + (0);
                    } else {
                        attr(elem, 'CoordOrigin', (0) + ' ' + (0));
                    } 
                    
                    /*  matrixStr = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                        ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                        ', sizingMethod=\'auto expand\')'].join('') : NONE
*/
                    // Adjust for alignment and rotation.
                    // Test case: http://highcharts.com/tests/?file=text-rotation
                    css(elem, {
                        //filter: matrixStr,
                        rotation: rotation,
                        left : 0,
                        top: 0
                    });                    
                    
                }
            },



              /* EOP ^*/


            /**^
             * Updated shadow function
             * Calculated shadow offset in case of thick border.
             * Also calculate base opacity.
             */
            /**
             * Apply a drop shadow by copying elements and giving them different strokes
             * @param {Boolean} apply
             */
            shadow: function(apply, group, options) {
                if (!options) {
                    options = {};
                }

                var shadows = [],
                i,
                element = this.element,
                renderer = this.renderer,
                shadow,
                elemStyle = element.style,
                markup,
                path = element.path,
                color = options.color || 'black',
                offset = pInt(this.attr('stroke-width') || 1, 10) + 6, // offset specifically reduced to 5 from SVG's 7
                elemOpacity = pluck(options.opacity, 1),
                opacity = elemOpacity * 0.06,
                // compensate for inverted plot area (XOR Gate)
                transform = !this.parentInverted != !options.inverted ?
                -1 : 1;
                /* EOP ^*/

                // some times empty paths are not strings
                if (path && typeof path.value !== 'string') {
                    path = 'x';
                }

                if (apply) {
                    for (i = 1; i <= 3; i++) {
                        /**^
                         * Applied shadow offset and opacity merging with
                         * parent element.
                         */
                        markup = ['<shape isShadow="true" strokeweight="', (offset - 2 * i ) ,
                        '" filled="false" path="', path,
                        '" coordsize="100,100" style="', elemStyle.cssText, '" />'];
                        shadow = createElement(renderer.prepVML(markup),
                            null, {
                                left: pInt(elemStyle.left) + transform,
                                top: pInt(elemStyle.top) + transform
                            }
                            );

                        // apply the opacity
                        markup = ['<stroke endcap="round" color="', color,
                        '" opacity="', (opacity * i), '"/>'];
                        createElement(renderer.prepVML(markup), null, null, shadow);
                        /* EOP ^*/

                        // insert it
                        if (group) {
                            group.element.appendChild(shadow);
                        } else {
                            element.parentNode.insertBefore(shadow, element);
                        }

                        // record it
                        shadows.push(shadow);

                    }

                    this.shadows = shadows;
                }
                return this;

            },

            /**^
             * No text bound for VML needed
             */
            textBound: function () {
                // only work out style mapping
                var wrapper = this,
                styles = wrapper.styles;

                if (wrapper.element.nodeName.toLowerCase() === 'span' && styles &&
                    (styles.backgroundColor || styles.borderColor) &&
                    wrapper.element.innerHTML == '') {

                    css(wrapper.element, {
                        backgroundColor: BLANKSTRING,
                        borderColor: BLANKSTRING,
                        border: BLANKSTRING
                    });
                    return wrapper;
                }

                if (styles && styles.backgroundOpacity) {
                    wrapper.attr({
                        opacity: styles.backgroundOpacity
                    });
                }
                return wrapper;
            }
        /* EOP ^*/

        });

        /**
         * The VML renderer
         */
        VMLRenderer = function() {
            this.init.apply(this, arguments);
        };
        VMLRenderer.prototype = merge( SVGRenderer.prototype, { // inherit SVGRenderer

            Element: VMLElement,
            isIE8: userAgent.indexOf('MSIE 8.0') > -1,


            /**
             * Initialize the VMLRenderer
             * @param {Object} container
             * @param {Number} width
             * @param {Number} height
             */
            init: function(container, width, height) {
                var renderer = this,
                boxWrapper;

                renderer.alignedObjects = [];

                boxWrapper = renderer.createElement(DIV);
                container.appendChild(boxWrapper.element);


                // generate the containing box
                renderer.box = boxWrapper.element;
                renderer.boxWrapper = boxWrapper;


                renderer.setSize(width, height, false);

                // The only way to make IE6 and IE7 print is to use a global namespace. However,
                // with IE8 the only way to make the dynamic shapes visible in screen and print mode
                // seems to be to add the xmlns attribute and the behaviour style inline.
                if (!doc.namespaces.hcv) {

                    doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

                    // setup default css
                    doc.createStyleSheet().cssText =
                    'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'+
                '{ behavior:url(#default#VML); display: inline-block; } ';

                }
            },

            /**^
             * Patched to fix for very small clipping with negative x, y
             *
             * Define a clipping rectangle. In VML it is accomplished by storing the values
             * for setting the CSS style to all associated members.
             *
             * @param {Number} x
             * @param {Number} y
             * @param {Number} width
             * @param {Number} height
             */
            clipRect: function (x, y, width, height) {

                // create a dummy element
                var clipRect = this.createElement();

                // mimic a rectangle with its style object for automatic updating in attr
                return extend(clipRect, {
                    members: [],
                    left: x,
                    top: y,
                    width: width,
                    height: height,
                    getCSS: function(inverted) {
                        var rect = this,//clipRect.element.style,
                        top = rect.top,
                        left = rect.left,
                        right = left + rect.width,
                        bottom = top + rect.height,
                        /**^
                         * Allow negative transformation for cliprect
                         */

                        ret = {
                            clip: 'rect('+
                            mathRound(inverted ? left : top) + 'px,'+
                            mathRound(inverted ? bottom : right) + 'px,'+
                            mathRound(inverted ? right : bottom) + 'px,'+
                            mathRound(inverted ? top : left) +'px)'
                        };
                        // issue 74 workaround
                        if (!inverted && docMode8) {
                            extend(ret, {
                                width: (right < 0 ? 0 : right) +PX,
                                height: (bottom < 0 ? 0 : bottom) +PX
                            });
                        }
                        /* EOP ^*/
                        return ret;
                    },

                    // used in attr and animation to update the clipping of all members
                    updateClipping: function() {
                        each(clipRect.members, function(member) {
                            member.css(clipRect.getCSS(member.inverted));
                        });
                    }
                });

            },
            /** EOP ^*/

            //function to get the arc path
            //isLargeArc is not requared in VML
            
            getArcPath : function (cX, cY, startX, startY, endX, endY, rX, rY, isClockWise, isLargeArc) {
                return [isClockWise? WA : AT, cX - rX, cY - rY, cX + rX, cY + rY, startX, startY, endX, endY];

            },

            /** EOP ^*/


            /**
             * Take a color and return it if it's a string, make it a gradient if it's a
             * gradient configuration object, and apply opacity.
             *
             * @param {Object} color The color or config object
             */
            color: function(color, elem, prop) {
                var colorObject,
                regexRgba = /^rgba/,
                markup;

                if (color && color.linearGradient) {

                    var stopColor,
                    stopOpacity,
                    linearGradient = color.linearGradient,
                    angle,
                    color1,
                    opacity1,
                    color2,
                    opacity2;

                    each(color.stops, function(stop, i) {
                        if (regexRgba.test(stop[1])) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get('rgb');
                            stopOpacity = colorObject.get('a');
                        }else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }

                        if (!i) { // first
                            color1 = stopColor;
                            opacity1 = stopOpacity;
                        } else {
                            color2 = stopColor;
                            opacity2 = stopOpacity;
                        }
                    });



                    // calculate the angle based on the linear vector
                    angle = 90  - math.atan(
                        (linearGradient[3] - linearGradient[1]) / // y vector
                        (linearGradient[2] - linearGradient[0]) // x vector
                        ) * 180 / mathPI;

                    // when colors attribute is used, the meanings of opacity and o:opacity2
                    // are reversed.
                    markup = ['<', prop, ' colors="0% ', color1, ',100% ', color2, '" angle="', angle,
                    '" opacity="', opacity2, '" o:opacity2="', opacity1,
                    '" type="gradient" focus="100%" />'];
                    createElement(this.prepVML(markup), null, null, elem);


                }
            /**^
             * To support FC format color
             * @source 3471/2.1.4
             */
                else if (color && color.FCcolor) {
                    var  FCcolor = pluck(color.FCcolor.color, "000000"), FCalpha = pluck(color.FCcolor.alpha, "100"),
                    FCratio = pluck(color.FCcolor.ratio, "0"), FCangle = pluckNumber(color.FCcolor.angle, "0"),
                    lastAlpah = 100;
                    //linearGradient, id, colorArr;
                    //replaec all space
                    FCcolor = FCcolor.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                    FCalpha = FCalpha.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                    FCratio = FCratio.replace(/\s+/ig, '').replace(/\,+$/ig, '').split(",");
                    FCangle = FCangle - 90;//for anticlock rotation
                    FCangle = FCangle * (-1);//for anticlock rotation
                    FCangle = FCangle % 360;
                    if (FCangle < 0) {//if negative then convert it to positive
                        FCangle = 360 + FCangle;
                    }
                    //if there has only 1 color
                    if (FCcolor.length === 1) {
                        markup = ['<', prop, ' opacity="', pluckNumber(FCalpha[0], 100) / 100, '"/>'];
                        createElement(this.prepVML(markup), null, null, elem);
                        return FCcolor[0].replace(/^#?/, '#');
                    }
                    else {
                        var x, StopColor, StopAlpha, StopRatio, FCcount = 0, colors = '', isFirst = true;

                        color1 = FCcolor[0].replace(/^#?/, '#');
                        opacity1 = pluckNumber(FCalpha[0], 100) / 100;
                        for (x = 0; x < FCcolor.length && FCcount < 100; x += 1) {
                            StopColor = FCcolor[x].replace(/^#?/, '#');
                            lastAlpah = StopAlpha = pluckNumber(FCalpha[x], lastAlpah);
                            StopRatio = pluckNumber(FCratio[x], (x !== 0) ? ((100 - FCcount) / (FCcolor.length - x)) : 0);
                            FCcount += StopRatio;
                            if (FCcount > 100) {
                                FCcount = 100;
                            }
                            if (isFirst) {
                                if (FCcount > 0) {//if not starts from 0 then extend the first color to 0
                                    colors += '0% ' + StopColor + ','
                                }
                                isFirst = false;
                            }
                            colors += FCcount + '% ' + StopColor + ','

                        }
                        //if gradient stop befor 100 then extend it to the end
                        if (FCcount < 100) {
                            colors += '100% ' + StopColor + ','
                        }
                        color2 = StopColor;
                        opacity2 = StopAlpha / 100;
                        if (color.FCcolor.radialGradient) {
                            if (color.FCcolor.gradientUnits !== 'objectBoundingBox') {
                                markup = ['<', prop, ' opacity="', pluckNumber(color.FCcolor.defaultAlpha, FCalpha[0], 100) / 100, '"/>'];
                                createElement(this.prepVML(markup), null, null, elem);
                                return pluck(color.FCcolor.defaultColor, FCcolor[0], '000000').replace(/^#?/, '#');
                            }
                            else {
                                // when colors attribute is used, the meanings of opacity and o:opacity2
                                // are reversed.
                                var focusposition = color.FCcolor.cx + "," + color.FCcolor.cy;

                                markup = ['<', prop, ' colors="', colors,
                                '" color="', color1, '" color2="', color2,
                                '" focusposition="', focusposition,
                                '" opacity="', opacity2, '" o:opacity2="', opacity1,
                                '" type="gradientTitle" focus="100%" />'];
                            }
                        }
                        else {
                            // when colors attribute is used, the meanings of opacity and o:opacity2
                            // are reversed.
                            markup = ['<', prop, ' colors="', colors, '" angle="', FCangle,
                            '" color="', color1, '" color2="', color2,
                            '" opacity="', opacity2, '" o:opacity2="', opacity1,
                            '" type="gradient" focus="100%" />'];
                        }
                        createElement(this.prepVML(markup), null, null, elem);
                    }
                }
                /* EOP 3471/2.1.4 ^*/

                // if the color is an rgba color, split it and add a fill node
                // to hold the opacity component
                else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

                    colorObject = Color(color);

                    markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
                    createElement(this.prepVML(markup), null, null, elem);

                    return colorObject.get('rgb');


                } else {
                    return color;
                }

            },

            /**
             * Take a VML string and prepare it for either IE8 or IE6/IE7.
             * @param {Array} markup A string array of the VML markup to prepare
             */
            prepVML: function(markup) {
                var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
                isIE8 = this.isIE8;

                markup = markup.join('');

                if (isIE8) { // add xmlns and style inline
                    markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
                    if (markup.indexOf('style="') === -1) {
                        markup = markup.replace('/>', ' style="'+ vmlStyle +'" />');
                    } else {
                        markup = markup.replace('style="', 'style="'+ vmlStyle);
                    }

                } else { // add namespace
                    markup = markup.replace('<', '<hcv:');
                }

                return markup;
            },

            /**
             * Create rotated and aligned text
             * @param {String} str
             * @param {Number} x
             * @param {Number} y
             */
            text: function(str, x, y) {

                var defaultChartStyle = defaultOptions.chart.style;

                return this.createElement('span')
                .attr({
                    text: str,
                    x: mathRound(x),
                    y: mathRound(y)
                })
                .css({
                    whiteSpace: 'nowrap',
                    fontFamily: defaultChartStyle.fontFamily,
                    fontSize: defaultChartStyle.fontSize
                });
            },

            /**
             * Create and return a path element
             * @param {Array} path
             */
            path: function (path) {
                // create the shape
                return this.createElement('shape').attr({
                    // subpixel precision down to 0.1 (width and height = 10px)
                    coordsize: '100 100',
                    d: path
                });
            },

            /**
             * Create and return a circle element. In VML circles are implemented as
             * shapes, which is faster than v:oval
             * @param {Number} x
             * @param {Number} y
             * @param {Number} r
             */
            circle: function(x, y, r) {
                return this.symbol('circle').attr({
                    x: x,
                    y: y,
                    r: r
                });
            },

            /**
             * Create a group using an outer div and an inner v:group to allow rotating
             * and flipping. A simple v:group would have problems with positioning
             * child HTML elements and CSS clip.
             *
             * @param {String} name The name of the group
             */
            g: function(name) {
                var wrapper,
                attribs;

                // set the class name
                if (name) {
                    attribs = {
                        'className': PREFIX + name,
                        'class': PREFIX + name
                    };
                }

                // the div to hold HTML and clipping
                wrapper = this.createElement(DIV).attr(attribs);

                return wrapper;
            },

            /**
             * VML override to create a regular HTML image
             * @param {String} src
             * @param {Number} x
             * @param {Number} y
             * @param {Number} width
             * @param {Number} height
             */
            image: function(src, x, y, width, height) {
                var obj = this.createElement('img')
                .attr({
                    src: src
                });

                if (arguments.length > 1) {
                    obj.css({
                        left: x,
                        top: y,
                        width: width,
                        height: height
                    });
                }
                return obj;
            },

            /**
             * VML uses a shape for rect to overcome bugs and rotation problems
             */
            rect: function(x, y, width, height, r, strokeWidth) {

                if (isObject(x)) {
                    y = x.y;
                    width = x.width;
                    height = x.height;
                    r = x.r;
                    strokeWidth = x.strokeWidth;
                    x = x.x;
                }
                var wrapper = this.symbol('rect');
                wrapper.r = r;

                return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
            },

            /**
             * In the VML renderer, each child of an inverted div (group) is inverted
             * @param {Object} element
             * @param {Object} parentNode
             */
            invertChild: function(element, parentNode) {
                var parentStyle = parentNode.style;

                css(element, {
                    flip: 'x',
                    left: pInt(parentStyle.width) - 10,
                    top: pInt(parentStyle.height) - 10,
                    rotation: -90
                });
            },

            /**
             * Symbol definitions that override the parent SVG renderer's symbols
             *
             */
            symbols: {
                // VML specific arc function
                arc: function (x, y, radius, options) {
                    var start = options.start,
                    end = options.end,
                    cosStart = mathCos(start),
                    sinStart = mathSin(start),
                    cosEnd = mathCos(end),
                    sinEnd = mathSin(end),
                    innerRadius = options.innerR,
                    circleCorrection = 0.07 / radius,
                    innerCorrection = (innerRadius && 0.1 / innerRadius) || 0;

                    if (end - start === 0) { // no angle, don't show it.
                        return ['x'];

                    //} else if (end - start == 2 * mathPI) { // full circle
                    } else if (2 * mathPI - end + start < circleCorrection) { // full circle
                        // empirical correction found by trying out the limits for different radii
                        cosEnd = - circleCorrection;
                    } else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
                        cosEnd = mathCos(start + innerCorrection);
                    }

                    return [
                    'wa', // clockwise arc to
                    x - radius, // left
                    y - radius, // top
                    x + radius, // right
                    y + radius, // bottom
                    x + radius * cosStart, // start x
                    y + radius * sinStart, // start y
                    x + radius * cosEnd, // end x
                    y + radius * sinEnd, // end y


                    'at', // anti clockwise arc to
                    x - innerRadius, // left
                    y - innerRadius, // top
                    x + innerRadius, // right
                    y + innerRadius, // bottom
                    x + innerRadius * cosEnd, // start x
                    y + innerRadius * sinEnd, // start y
                    x + innerRadius * cosStart, // end x
                    y + innerRadius * sinStart, // end y

                    'x', // finish path
                    'e' // close
                    ];

                },
                // Add circle symbol path. This performs significantly faster than v:oval.
                circle: function (x, y, r) {
                    return [
                    'wa', // clockwisearcto
                    x - r, // left
                    y - r, // top
                    x + r, // right
                    y + r, // bottom
                    x + r, // start x
                    y,     // start y
                    x + r, // end x
                    y,     // end y
                    //'x', // finish path
                    'e' // close
                    ];
                },
                /**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape
		 *
		 * @param {Number} left Left position
		 * @param {Number} top Top position
		 * @param {Number} r Border radius
		 * @param {Object} options Width and height
		 */

                rect: function (left, top, r, options) {
                    if (!defined(options)) {
                        return [];
                    }
                    var width = options.width,
                    height = options.height,
                    right = left + width,
                    bottom = top + height;

                    r = mathMin(r, width, height);

                    return [
                    M,
                    left + r, top,

                    L,
                    right - r, top,
                    'wa',
                    right - 2 * r, top,
                    right, top + 2 * r,
                    right - r, top,
                    right, top + r,

                    L,
                    right, bottom - r,
                    'wa',
                    right - 2 * r, bottom - 2 * r,
                    right, bottom,
                    right, bottom - r,
                    right - r, bottom,

                    L,
                    left + r, bottom,
                    'wa',
                    left, bottom - 2 * r,
                    left + 2 * r, bottom,
                    left + r, bottom,
                    left, bottom - r,

                    L,
                    left, top + r,
                    'wa',
                    left, top,
                    left + 2 * r, top + 2 * r,
                    left, top + r,
                    left + r, top,


                    'x',
                    'e'
                    ];

                }
            }
        });

        // general renderer
        Renderer = VMLRenderer;
    }
/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/


/**^
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
    function Chart (options, callback) {

        defaultXAxisOptions = merge(defaultXAxisOptions, defaultOptions.xAxis);
        defaultYAxisOptions = merge(defaultYAxisOptions, defaultOptions.yAxis);
        defaultOptions.xAxis = defaultOptions.yAxis = null;

        // Handle regular options
        options = merge(defaultOptions, options);

        // Define chart variables
        var optionsChart = options.chart,
        optionsMargin = optionsChart.margin,
        margin = isObject(optionsMargin) ?
        optionsMargin :
        [optionsMargin, optionsMargin, optionsMargin, optionsMargin],
        optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
        optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
        optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
        optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
        spacingTop = optionsChart.spacingTop,
        spacingRight = optionsChart.spacingRight,
        spacingBottom = optionsChart.spacingBottom,
        spacingLeft = optionsChart.spacingLeft,
        spacingBox,
        chartTitleOptions,
        chartSubtitleOptions,
        plotTop,
        marginRight,
        marginBottom,
        plotLeft,
        axisOffset,
        renderTo,
        renderToClone,
        container,
        containerId,
        containerWidth,
        containerHeight,
        chartWidth,
        chartHeight,
        oldChartWidth,
        oldChartHeight,
        chartBackground,
        plotBackground,
        plotBGImage,
        /**^
         * Added variable for chart background image like plotBGImage
         * @source 3839/2.1.4
         */
        chartAPI = options.instanceAPI,
        chartBGImage,
        chartBGImageGroup,
        chartLogoImage,
        chartLogoImageGroup,
        stepZoom, // function
        /* EOP 3839/2.1.4 ^*/
        plotBorder,
        chart = this,
        chartEvents = optionsChart.events,
        runChartClick = chartEvents && !!chartEvents.click,
        eventType,
        isInsidePlot, // function
        tooltip,
        mouseIsDown,
        loadingDiv,
        loadingSpan,
        loadingShown,
        plotHeight,
        plotWidth,
        tracker,
        trackerGroup,
        placeTrackerGroup,
        legend,
        legendWidth,
        legendHeight,
        chartPosition,// = getPosition(container),
        hasCartesianSeries = optionsChart.showAxes,
        isResizing = 0,
        axes = [],
        maxTicks, // handle the greatest amount of ticks on grouped axes
        series = [],
        inverted,
        renderer,
        tooltipTick,
        tooltipInterval,
        hoverX,
        drawChartBox, // function
        getMargins, // function
        resetMargins, // function
        setChartSize, // function
        resize,
        zoom, // function
        zoomOut; // function


        /**
	 * Create a new axis object
	 * @param {Object} chart
	 * @param {Object} options
	 */
        function Axis (chart, options) {

            // Define variables
            var isXAxis = options.isX,
            opposite = options.opposite, // needed in setOptions
            horiz = inverted ? !isXAxis : isXAxis,
            side = horiz ?
            (opposite ? 0 /* top */  : 2 /* bottom */) :
            (opposite ? 1 /* right*/ : 3 /* left */  ),
            stacks = {};


            options = merge(
                isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
                [defaultTopAxisOptions, defaultRightAxisOptions,
                defaultBottomAxisOptions, defaultLeftAxisOptions][side],
                options
                );

            var axis = this,
            type = options.type,
            isDatetimeAxis = type === 'datetime',
            isLog = type === 'logarithmic',
            offset = options.offset || 0,
            xOrY = isXAxis ? 'x' : 'y',
            /**^
             * Log support
             */
            isLogAxis = options.type == 'log',
            base = options.base,
            getLog = function (value, base) {
                value = value == 0 ? 1 : value;
                return math.log(value) / math.log(base || 10);
            },
            tMin = 0,
            /* EOP ^*/

            axisLength,
            transA, // translation factor
            oldTransA, // used for prerendering
            transB = horiz ? plotLeft : marginBottom, // translation addend
            translate, // fn
            getPlotLinePath, // fn
            axisGroup,
            gridGroup,
            axisLine,
            dataMin,
            dataMax,
            associatedSeries,
            userMin,
            userMax,
            max = null,
            min = null,
            oldMin,
            oldMax,
            minPadding = options.minPadding,
            maxPadding = options.maxPadding,
            isLinked = defined(options.linkedTo),
            ignoreMinPadding, // can be set to true by a column or bar series
            ignoreMaxPadding,
            usePercentage,
            events = options.events,
            eventType,
            plotLinesAndBands = [],
            tickInterval,
            minorTickInterval,
            magnitude,
            tickPositions, // array containing predefined positions
            ticks = {},
            minorTicks = {},
            alternateBands = {},
            tickAmount,
            labelOffset,
            axisTitleMargin,// = options.title.margin,
            dateTimeLabelFormat,
            categories = options.categories,
            labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
            function() {
                var value = this.value,
                ret;

                if (dateTimeLabelFormat) { // datetime axis
                    ret = dateFormat(dateTimeLabelFormat, value);

                } else if (tickInterval % 1000000 === 0) { // use M abbreviation
                    ret = (value / 1000000) +'M';

                } else if (tickInterval % 1000 === 0) { // use k abbreviation
                    ret = (value / 1000) +'k';

                } else if (!categories && value >= 1000) { // add thousands separators
                    ret = numberFormat(value, 0);

                } else { // strings (categories) and small numbers
                    ret = value;
                }
                return ret;
            },

            staggerLines = horiz && options.labels.staggerLines,
            reversed = options.reversed,
            tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;

            /**
             * The Tick class
             */
            function Tick(pos, minor) {
                var tick = this;
                tick.pos = pos;
                tick.minor = minor;
                tick.isNew = true;

                if (!minor) {
                    tick.addLabel();
                }
            }
            Tick.prototype = {
                /**
                 * Write the tick label
                 */
                addLabel: function() {
                    var pos = this.pos,
                    labelOptions = options.labels,
                    str,
                    withLabel = !((pos === min && !pick(options.showFirstLabel, 1)) ||
                        (pos === max && !pick(options.showLastLabel, 0))),
                    width = (categories && horiz && categories.length &&
                        !labelOptions.step && !labelOptions.staggerLines &&
                        !labelOptions.rotation &&
                        plotWidth / categories.length) ||
                    (!horiz && plotWidth / 2),
                    css,
                    label = this.label;


                    // get the string
                    str = labelFormatter.call({
                        isFirst: pos === tickPositions[0],
                        isLast: pos === tickPositions[tickPositions.length - 1],
                        dateTimeLabelFormat: dateTimeLabelFormat,
                        value: (categories && categories[pos] ? categories[pos] : pos)
                    });


                    // prepare CSS
                    css = width && {
                        width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) +PX
                    };
                    css = extend(css, labelOptions.style);

                    // first call
                    if (label === UNDEFINED) {
                        this.label =
                        defined(str) && withLabel && labelOptions.enabled ?
                        renderer.text(
                            str,
                            0,
                            0
                            )
                        .attr({
                            align: labelOptions.align,
                            rotation: labelOptions.rotation
                        })
                        // without position absolute, IE export sometimes is wrong
                        .css(css)
                        .add(axisGroup):
                        null;

                    // update
                    } else if (label) {
                        label.attr({
                            text: str
                        })
                        .css(css);
                    }
                },
                /**
                 * Get the offset height or width of the label
                 */
                getLabelSize: function() {
                    var label = this.label;
                    return label ?
                    ((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
                    0;
                },
                /**
                 * Put everything in place
                 *
                 * @param index {Number}
                 * @param old {Boolean} Use old coordinates to prepare an animation into new position
                 */
                render: function(index, old) {
                    var tick = this,
                    major = !tick.minor,
                    label = tick.label,
                    pos = tick.pos,
                    labelOptions = options.labels,
                    gridLine = tick.gridLine,
                    gridLineWidth = major ? options.gridLineWidth : options.minorGridLineWidth,
                    gridLineColor = major ? options.gridLineColor : options.minorGridLineColor,
                    dashStyle = major ?
                    options.gridLineDashStyle :
                    options.minorGridLineDashStyle,
                    gridLinePath,
                    mark = tick.mark,
                    markPath,
                    tickLength = major ? options.tickLength : options.minorTickLength,
                    tickWidth = major ? options.tickWidth : (options.minorTickWidth || 0),
                    tickColor = major ? options.tickColor : options.minorTickColor,
                    tickPosition = major ? options.tickPosition : options.minorTickPosition,
                    step = labelOptions.step,
                    cHeight = (old && oldChartHeight) || chartHeight,
                    attribs,
                    x,
                    y;

                    // get x and y position for ticks and labels
                    x = horiz ?
                    translate(pos + tickmarkOffset, null, null, old) + transB :
                    plotLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - marginRight - plotLeft : 0);

                    y = horiz ?
                    cHeight - marginBottom + offset - (opposite ? plotHeight : 0) :
                    cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;

                    // create the grid line
                    if (gridLineWidth) {
                        gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);

                        if (gridLine === UNDEFINED) {
                            attribs = {
                                stroke: gridLineColor,
                                'stroke-width': gridLineWidth
                            };
                            if (dashStyle) {
                                attribs.dashstyle = dashStyle;
                            }
                            tick.gridLine = gridLine =
                            gridLineWidth ?
                            renderer.path(gridLinePath)
                            .attr(attribs).add(gridGroup) :
                            null;
                        }
                        if (gridLine && gridLinePath) {
                            gridLine.animate({
                                d: gridLinePath
                            });
                        }
                    }

                    // create the tick mark
                    if (tickWidth) {

                        // negate the length
                        if (tickPosition === 'inside') {
                            tickLength = -tickLength;
                        }
                        if (opposite) {
                            tickLength = -tickLength;
                        }

                        markPath = renderer.crispLine([
                            M,
                            x,
                            y,
                            L,
                            x + (horiz ? 0 : -tickLength),
                            y + (horiz ? tickLength : 0)
                            ], tickWidth);

                        if (mark) { // updating
                            mark.animate({
                                d: markPath
                            });
                        } else { // first time
                            tick.mark = renderer.path(
                                markPath
                                ).attr({
                                stroke: tickColor,
                                'stroke-width': tickWidth
                            }).add(axisGroup);
                        }
                    }

                    // the label is created on init - now move it into place
                    if (label && !isNaN(x)) {
                        x = x + labelOptions.x - (tickmarkOffset && horiz ?
                            tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
                        y = y + labelOptions.y - (tickmarkOffset && !horiz ?
                            tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

                        // vertically centered
                        if (!defined(labelOptions.y)) {
                            y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
                        }


                        // correct for staggered labels
                        if (staggerLines) {
                            y += (index / (step || 1) % staggerLines) * 16;
                        }
                        // apply step
                        if (step) {
                            // show those indices dividable by step
                            label[index % step ? 'hide' : 'show']();
                        }

                        label[tick.isNew ? 'attr' : 'animate']({
                            x: x,
                            y: y
                        });
                    }

                    tick.isNew = false;
                },
                /**
                 * Destructor for the tick prototype
                 */
                destroy: function() {
                    var tick = this,
                    n;
                    for (n in tick) {
                        if (tick[n] && tick[n].destroy) {
                            tick[n].destroy();
                        }
                    }
                }
            };

            /**
             * The object wrapper for plot lines and plot bands
             * @param {Object} options
             */
            function PlotLineOrBand(options) {
                var plotLine = this;
                if (options) {
                    plotLine.options = options;
                    plotLine.id = options.id;
                }

                //plotLine.render()
                return plotLine;
            }

            PlotLineOrBand.prototype = {

                /**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
                render: function () {
                    var plotLine = this,
                    options = plotLine.options,
                    optionsLabel = options.label,
                    label = plotLine.label,
                    width = options.width,
                    to = options.to,
                    toPath, // bands only
                    from = options.from,
                    dashStyle = options.dashStyle,
                    svgElem = plotLine.svgElem,
                    path = [],
                    addEvent,
                    eventType,
                    xs,
                    ys,
                    x,
                    y,
                    color = options.color,
                    zIndex = options.zIndex,
                    events = options.events,
                    attribs;

                    /**^
                     * @source 4237/2.1.4
                     * Add a hook of the chart obj in the plotlile so that
                     * events can access chart.
                     * + To draw plot label without line.
                     */
                    var labelWidth,
                    labelHeight,
                    scaleAxis;

                    plotLine.chart = chart;

                    // Adjust where we want to draw a label without the plot
                    // line.
                    if (width === 0 && optionsLabel && defined(optionsLabel.text)) {
                        width = 1;
                        color = COLOR_TRANSPARENT;
                    }
                    /* EOP 4237/2.1.4 ^*/

                    // plot line
                    if (width) {
                        /**^
                         * To send slanting value to the patched getPlotLinePath
                         * function.
                         * @source 4240/2.1.4
                         */
                        path = getPlotLinePath([options.value, pluck(options.to, options.value)], width);
                        /* EOP 4240/2.1.4 ^*/
                        attribs = {
                            stroke: color,
                            'stroke-width': width
                        };
                        if (dashStyle) {
                            attribs.dashstyle = dashStyle;
                        }
                    }

                    // plot band
                    else if (defined(from) && defined(to)) {
                        // keep within plot area
                        from = mathMax(from, min);
                        to = mathMin(to, max);

                        toPath = getPlotLinePath(to);
                        path = getPlotLinePath(from);
                        if (path && toPath) {
                            /**^ Ensure minimum trendzone height
                             */
                            if (this.options.alwaysVisible) {
                                if (horiz) {
                                    toPath[1] = toPath[4] +=
                                    path[1] === toPath[1] &&
                                    path[4] === toPath[4];
                                }
                                else {
                                    toPath[2] = toPath[5] +=
                                    path[2] === toPath[2] &&
                                    path[5] === toPath[5];
                                }
                            }
                            /* EOP ^*/

                            path.push(
                                toPath[4],
                                toPath[5],
                                toPath[1],
                                toPath[2]
                                );
                        } else { // outside the axis area
                            path = null;
                        }
                        attribs = {
                            fill: color
                        };
                    }else {
                        return;
                    }
                    // zIndex
                    if (defined(zIndex)) {
                        attribs.zIndex = zIndex;
                    }

                    // common for lines and bands
                    if (svgElem) {
                        if (path) {
                            svgElem.animate({
                                d: path
                            }, null, svgElem.onGetPath);
                        } else {
                            svgElem.hide();
                            svgElem.onGetPath = function() {
                                svgElem.show();
                            };
                        }
                    } else if (path && path.length) {
                        plotLine.svgElem = svgElem = renderer.path(path)
                        .attr(attribs).add();

                        // events
                        if (events) {
                            addEvent = function(eventType) {
                                svgElem.on(eventType, function(e) {
                                    events[eventType].apply(plotLine, [e]);
                                });
                            };
                            for (eventType in events) {
                                addEvent(eventType);
                            }
                        }
                    }

                    // the plot band/line label
                    if (optionsLabel && defined(optionsLabel.text) && path && path.length && plotWidth > 0 && plotHeight > 0) {
                        // apply defaults
                        optionsLabel = merge({
                            align: horiz && toPath && 'center',
                            x: horiz ? !toPath && 4 : 10,
                            verticalAlign : !horiz && toPath && 'middle',
                            y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
                            rotation: horiz && !toPath && 90
                        }, optionsLabel);

                        // add the SVG element
                        if (!label) {
                            plotLine.label = label = renderer.text(
                                optionsLabel.text,
                                0,
                                0
                                )
                            .attr({
                                align: optionsLabel.textAlign || optionsLabel.align,
                                rotation: optionsLabel.rotation,
                                zIndex: zIndex
                            })
                            .css(optionsLabel.style)
                            .add();
                        }

                        // get the bounding box and align the label
                        xs = [path[1], path[4], pick(path[6], path[1])];
                        ys = [path[2], path[5], pick(path[7], path[2])];
                        x = mathMin.apply(math, xs);
                        y = mathMin.apply(math, ys);

                    /**^
                     * To send slanting value to the patched getPlotLinePath
                     * function.
                     * @source 4341/2.1.4
                     */
                        labelWidth = mathMax.apply(math, xs) - x;
                        labelHeight = mathMax.apply(math, ys) - y;


                        if (optionsLabel.offsetScale !== undefined) {
                            // Label offset scale calculated wrt opposite axis
                            if (optionsLabel.offsetScaleIndex !== undefined) {
                                scaleAxis = (isXAxis ? chart.yAxis : chart.xAxis)[optionsLabel.offsetScaleIndex];
                                if (horiz) {
                                    y += scaleAxis.translate(optionsLabel.offsetScale, 0, 1);
                                }
                                else {
                                    x = scaleAxis.translate(optionsLabel.offsetScale, 0, 1) + x;
                                }
                            }
                            // Label offset scale calculated wrt opposite axis.
                            else {
                                if (horiz) {
                                    y += plotHeight * optionsLabel.offsetScale;
                                }
                                else {
                                    x += plotWidth * optionsLabel.offsetScale;
                                }
                            }
                        }

                        label.align(optionsLabel, false, {
                            x: x,
                            y: y,
                            width: labelWidth,
                            height: labelHeight
                        });
                        label.textBound();
                        /* EOP 4341/2.1.4 ^*/
                        label.show();

                    } else if (label) { // move out of sight
                        label.hide();
                    }

                    // chainable
                    return plotLine;
                },

                /**
		 * Remove the plot line or band
		 */
                destroy: function() {
                    var obj = this,
                    n;

                    for (n in obj) {
                        if (obj[n] && obj[n].destroy) {
                            obj[n].destroy(); // destroy SVG wrappers
                        }
                        delete obj[n];
                    }
                    // remove it from the lookup
                    erase(plotLinesAndBands, obj);
                }
            };

            /**
             * The class for stack items
             */
            function StackItem(options, isNegative, x) {
                var stackItem = this;

                // Tells if the stack is negative
                stackItem.isNegative = isNegative;

                // Save the options to be able to style the label
                stackItem.options = options;

                // Save the x value to be able to position the label later
                stackItem.x = x;

                // The align options and text align varies on whether the stack is negative and
                // if the chart is inverted or not.
                // First test the user supplied value, then use the dynamic.
                stackItem.alignOptions = {
                    align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
                    verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
                    y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
                    x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
                };

                stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
            }

            StackItem.prototype = {
                /**
                 * Sets the total of this stack. Should be called when a serie is hidden or shown
                 * since that will affect the total of other stacks.
                 */
                setTotal: function(total) {
                    this.total = total;
                    this.cum = total;
                },

                /**
                 * Renders the stack total label and adds it to the stack label group.
                 */
                render: function(group) {
                    var stackItem = this,									// aliased this
                    str = stackItem.options.formatter.call(stackItem);	// format the text in the label

                    // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
                    if (stackItem.label) {
                        stackItem.label.attr({
                            text: str,
                            visibility: HIDDEN
                        });
                    // Create new label
                    } else {
                        stackItem.label =
                        chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
                        .css(stackItem.options.style)			// apply style
                        .attr({
                            align: stackItem.textAlign,			// fix the text-anchor
                            rotation: stackItem.options.rotation,	// rotation
                            visibility: HIDDEN
                        })					// hidden until setOffset is called
                        .add(group);							// add to the labels-group
                    }
                },

                /**
                 * Sets the offset that the stack has from the x value and repositions the label.
                 */
                setOffset: function(xOffset, xWidth) {
                    var stackItem = this,										// aliased this
                    neg = stackItem.isNegative,								// special treatment is needed for negative stacks
                    y = axis.translate(stackItem.total),					// stack value translated mapped to chart coordinates
                    yZero = axis.translate(0),								// stack origin
                    h = mathAbs(y - yZero),									// stack height
                    x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
                    plotHeight = chart.plotHeight,
                    stackBox = {	// this is the box for the complete stack
                        x: inverted ? (neg ? y : y - h) : x,
                        y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
                        width: inverted ? h : xWidth,
                        height: inverted ? xWidth : h
                    };

                    if (stackItem.label) {
                        stackItem.label
                        .align(stackItem.alignOptions, null, stackBox)	// align the label to the box
                        .attr({
                            visibility: VISIBLE
                        });					// set visibility
                    }
                }
            };

            /**
             * Get the minimum and maximum for the series of each axis
             */
            function getSeriesExtremes() {
                var posStack = [],
                negStack = [],
                run;

                // reset dataMin and dataMax in case we're redrawing
                dataMin = dataMax = null;

                // get an overview of what series are associated with this axis
                associatedSeries = [];

                each(series, function(serie) {
                    run = false;


                    // match this axis against the series' given or implicated axis
                    each(['xAxis', 'yAxis'], function(strAxis) {
                        if (
                            // the series is a cartesian type, and...
                            serie.isCartesian &&
                            // we're in the right x or y dimension, and...
                            ((strAxis === 'xAxis' && isXAxis) || (strAxis === 'yAxis' && !isXAxis)) && (
                                // the axis number is given in the options and matches this axis index, or
                                (serie.options[strAxis] === options.index) ||
                                // the axis index is not given
                                (serie.options[strAxis] === UNDEFINED && options.index === 0)
                                )
                            ) {
                            serie[strAxis] = axis;
                            associatedSeries.push(serie);

                            // the series is visible, run the min/max detection
                            run = true;
                        }
                    });
                    // ignore hidden series if opted
                    if (!serie.visible && optionsChart.ignoreHiddenSeries) {
                        run = false;
                    }

                    if (run) {

                        var stacking,
                        posPointStack,
                        negPointStack,
                        stackKey,
                        negKey;

                        if (!isXAxis) {
                            stacking = serie.options.stacking;
                            usePercentage = stacking === 'percent';

                            // create a stack for this particular series type
                            if (stacking) {
                                stackKey = serie.type + pick(serie.options.stack, '');
                                negKey = '-'+ stackKey;
                                serie.stackKey = stackKey; // used in translate

                                posPointStack = posStack[stackKey] || []; // contains the total values for each x
                                posStack[stackKey] = posPointStack;

                                negPointStack = negStack[negKey] || [];
                                negStack[negKey] = negPointStack;
                            }
                            if (usePercentage) {
                                dataMin = 0;
                                dataMax = 99;
                            }
                        }
                        if (serie.isCartesian) { // line, column etc. need axes, pie doesn't
                            each(serie.data, function(point, i) {
                                var pointX = point.x,
                                pointY = point.y,
                                isNegative = pointY < 0,
                                pointStack = isNegative ? negPointStack : posPointStack,
                                key = isNegative ? negKey : stackKey,
                                totalPos,
                                pointLow;

                                // initial values
                                if (dataMin === null) {

                                    // start out with the first point
                                    dataMin = dataMax = point[xOrY];
                                }

                                // x axis
                                if (isXAxis) {
                                    if (pointX > dataMax) {
                                        dataMax = pointX;
                                    } else if (pointX < dataMin) {
                                        dataMin = pointX;
                                    }
                                }

                                // y axis
                                else if (defined(pointY)) {
                                    if (stacking) {
                                        pointStack[pointX] =
                                        defined(pointStack[pointX]) ?
                                        pointStack[pointX] + pointY : pointY;
                                    }
                                    totalPos = pointStack ? pointStack[pointX] : pointY;
                                    pointLow = pick(point.low, totalPos);
                                    if (!usePercentage) {
                                        if (totalPos > dataMax) {
                                            dataMax = totalPos;
                                        } else if (pointLow < dataMin) {
                                            dataMin = pointLow;
                                        }
                                    }
                                    if (stacking) {
                                        // add the series
                                        if (!stacks[key]) {
                                            stacks[key] = {};
                                        }

                                        // If the StackItem is there, just update the values,
                                        // if not, create one first
                                        if (!stacks[key][pointX]) {
                                            stacks[key][pointX] = new StackItem(options.stackLabels, isNegative, pointX);
                                        }
                                        stacks[key][pointX].setTotal(totalPos);
                                    }
                                }
                            });


                            // For column, areas and bars, set the minimum automatically to zero
                            // and prevent that minPadding is added in setScale
                            if (/(area|column|bar)/.test(serie.type) && !isXAxis) {
                                var threshold = 0; // use series.options.threshold?
                                if (dataMin >= threshold) {
                                    dataMin = threshold;
                                    ignoreMinPadding = true;
                                } else if (dataMax < threshold) {
                                    dataMax = threshold;
                                    ignoreMaxPadding = true;
                                }
                            }
                        }
                    }
                });

            }

            /**
             * Translate from axis value to pixel position on the chart, or back
             *
             */
            translate = function(val, backwards, cvsCoord, old, handleLog, convertLength) {
                var sign = 1,
                cvsOffset = 0,
                localA = old ? oldTransA : transA,
                localMin = old ? oldMin : min,
                returnValue;

                if (!localA) {
                    localA = transA;
                }

                if (cvsCoord) {
                    sign *= -1; // canvas coordinates inverts the value
                    cvsOffset = axisLength;
                }
                if (reversed) { // reversed axis
                    sign *= -1;
                    cvsOffset -= sign * axisLength;
                }
                if (convertLength) {
                    if (backwards) { // reverse translation
                        returnValue = val / localA; // from chart pixel to value
                        if (isLog && handleLog) {
                            returnValue = lin2log(returnValue);
                        }

                    }else { // normal translation
                        if (isLog && handleLog) {
                            val = log2lin(val);
                        }
                        returnValue = val * localA; // from value to chart pixel
                    }
                }
                else {
                    if (backwards) { // reverse translation
                        if (reversed) {
                            val = axisLength - val;
                        }
                        returnValue = val / localA + localMin; // from chart pixel to value
                        if (isLog && handleLog) {
                            returnValue = lin2log(returnValue);
                        }

                    } else { // normal translation
                        if (isLog && handleLog) {
                            val = log2lin(val);
                        }
                        returnValue = sign * (val - localMin) * localA + cvsOffset; // from value to chart pixel
                    }
                }
                return returnValue;
            };

            /**
             * Create the path for a plot line that goes from the given value on
             * this axis, across the plot to the opposite side
             * @param {Number} value
             * @param {Number} lineWidth Used for calculation crisp line
             * @param {Number] old Use old coordinates (for resizing and rescaling)
             */
            getPlotLinePath = function(value, lineWidth, old) {
                /**^
                     * To accomodate slopeing plot lines.
                     * @source 4566/2.1.4
                     * @code
                     */
                var x1,
                y1,
                x2,
                y2,
                translatedValue,
                translatedValue2,
                cHeight = old && oldChartHeight || chartHeight,
                cWidth = old && oldChartWidth || chartWidth,
                skip;

                if (!(value instanceof Array)) {
                    value = [value, value];
                }

                translatedValue = translate(value[0], null, null, old);
                translatedValue2 = translate(value[1], null, null, old);

                x1 = mathRound(translatedValue + transB);
                x2 = mathRound(translatedValue2 + transB);
                y1 = mathRound(cHeight - translatedValue - transB);
                y2 = mathRound(cHeight - translatedValue2 - transB);

                if (isNaN(translatedValue) || isNaN(translatedValue2)) { // no min or max
                    /* EOP 4566/2.1.4 ^*/
                    skip = true;

                } else if (horiz) {
                    y1 = plotTop;
                    y2 = cHeight - marginBottom;
                    if (x1 < plotLeft || x1 > plotLeft + plotWidth) {
                        skip = true;
                    }
                }else {
                    x1 = plotLeft;
                    x2 = cWidth - marginRight;
                    if (y1 < plotTop || y1 > plotTop + plotHeight) {
                        skip = true;
                    }
                }
                return skip ?
                null :
                renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
            };


            /**
             * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
             * @param {Number} interval
             */
            function normalizeTickInterval(interval, multiples) {
                var normalized, i;

                // round to a tenfold of 1, 2, 2.5 or 5
                magnitude = multiples ? 1 : math.pow(10, mathFloor(math.log(interval) / math.LN10));
                normalized = interval / magnitude;

                // multiples for a linear scale
                if (!multiples) {
                    multiples = [1, 2, 2.5, 5, 10];
                    //multiples = [1, 2, 2.5, 4, 5, 7.5, 10];

                    // the allowDecimals option
                    if (options.allowDecimals === false || isLog) {
                        if (magnitude === 1) {
                            multiples = [1, 2, 5, 10];
                        }else if (magnitude <= 0.1) {
                            multiples = [1 / magnitude];
                        }
                    }
                }

                // normalize the interval to the nearest multiple
                for (i = 0; i < multiples.length; i++) {
                    interval = multiples[i];
                    if (normalized <= (multiples[i] + (multiples[i+1] || multiples[i])) / 2) {
                        break;
                    }
                }

                // multiply back to the correct magnitude
                interval *= magnitude;

                return interval;
            }

            /**
             * Set the tick positions to a time unit that makes sense, for example
             * on the first of each month or on every Monday.
             */
            function setDateTimeTickPositions() {
                tickPositions = [];
                var i,
                useUTC = defaultOptions.global.useUTC,
                oneSecond = 1000 / timeFactor,
                oneMinute = 60000 / timeFactor,
                oneHour = 3600000 / timeFactor,
                oneDay = 24 * 3600000 / timeFactor,
                oneWeek = 7 * 24 * 3600000 / timeFactor,
                oneMonth = 30 * 24 * 3600000 / timeFactor,
                oneYear = 31556952000 / timeFactor,

                units = [[
                'second',						// unit name
                oneSecond,						// fixed incremental unit
                [1, 2, 5, 10, 15, 30]			// allowed multiples
                ], [
                'minute',						// unit name
                oneMinute,						// fixed incremental unit
                [1, 2, 5, 10, 15, 30]			// allowed multiples
                ], [
                'hour',							// unit name
                oneHour,						// fixed incremental unit
                [1, 2, 3, 4, 6, 8, 12]			// allowed multiples
                ], [
                'day',							// unit name
                oneDay,							// fixed incremental unit
                [1, 2]							// allowed multiples
                ], [
                'week',							// unit name
                oneWeek,						// fixed incremental unit
                [1, 2]							// allowed multiples
                ], [
                'month',
                oneMonth,
                [1, 2, 3, 4, 6]
                ], [
                'year',
                oneYear,
                null
                ]],

                unit = units[6], // default unit is years
                interval = unit[1],
                multiples = unit[2];

                // loop through the units to find the one that best fits the tickInterval
                for (i = 0; i < units.length; i++)  {
                    unit = units[i];
                    interval = unit[1];
                    multiples = unit[2];


                    if (units[i+1]) {
                        // lessThan is in the middle between the highest multiple and the next unit.
                        var lessThan = (interval * multiples[multiples.length - 1] +
                            units[i + 1][1]) / 2;

                        // break and keep the current unit
                        if (tickInterval <= lessThan) {
                            break;
                        }
                    }
                }

                // prevent 2.5 years intervals, though 25, 250 etc. are allowed
                if (interval === oneYear && tickInterval < 5 * interval) {
                    multiples = [1, 2, 5];
                }

                // get the minimum value by flooring the date
                var multitude = normalizeTickInterval(tickInterval / interval, multiples),
                minYear, // used in months and years as a basis for Date.UTC()
                minDate = new Date(min * timeFactor);

                minDate.setMilliseconds(0);

                if (interval >= oneSecond) { // second
                    minDate.setSeconds(interval >= oneMinute ? 0 :
                        multitude * mathFloor(minDate.getSeconds() / multitude));
                }

                if (interval >= oneMinute) { // minute
                    minDate[setMinutes](interval >= oneHour ? 0 :
                        multitude * mathFloor(minDate[getMinutes]() / multitude));
                }

                if (interval >= oneHour) { // hour
                    minDate[setHours](interval >= oneDay ? 0 :
                        multitude * mathFloor(minDate[getHours]() / multitude));
                }

                if (interval >= oneDay) { // day
                    minDate[setDate](interval >= oneMonth ? 1 :
                        multitude * mathFloor(minDate[getDate]() / multitude));
                }

                if (interval >= oneMonth) { // month
                    minDate[setMonth](interval >= oneYear ? 0 :
                        multitude * mathFloor(minDate[getMonth]() / multitude));
                    minYear = minDate[getFullYear]();
                }

                if (interval >= oneYear) { // year
                    minYear -= minYear % multitude;
                    minDate[setFullYear](minYear);
                }

                // week is a special case that runs outside the hierarchy
                if (interval === oneWeek) {
                    // get start of current week, independent of multitude
                    minDate[setDate](minDate[getDate]() - minDate[getDay]() +
                        options.startOfWeek);
                }


                // get tick positions
                i = 1; // prevent crash just in case
                minYear = minDate[getFullYear]();
                var time = minDate.getTime() / timeFactor,
                minMonth = minDate[getMonth](),
                minDateDate = minDate[getDate]();

                // iterate and add tick positions at appropriate values
                while (time < max && i < plotWidth) {
                    tickPositions.push(time);

                    // if the interval is years, use Date.UTC to increase years
                    if (interval === oneYear) {
                        time = makeTime(minYear + i * multitude, 0) / timeFactor;

                    // if the interval is months, use Date.UTC to increase months
                    } else if (interval === oneMonth) {
                        time = makeTime(minYear, minMonth + i * multitude) / timeFactor;

                    // if we're using global time, the interval is not fixed as it jumps
                    // one hour at the DST crossover
                    }else if (!useUTC && (interval === oneDay || interval === oneWeek)) {
                        time = makeTime(minYear, minMonth, minDateDate +
                            i * multitude * (interval === oneDay ? 1 : 7));

                    // else, the interval is fixed and we use simple addition
                    } else {
                        time += interval * multitude;
                    }

                    i++;
                }
                // push the last time
                tickPositions.push(time);


                // dynamic label formatter
                dateTimeLabelFormat = options.dateTimeLabelFormats[unit[0]];
            }

            /**
             * Fix JS round off float errors
             * @param {Number} num
             */
            function correctFloat(num) {
                var invMag, ret = num;
                magnitude = pick(magnitude, math.pow(10, mathFloor(math.log(tickInterval) / math.LN10)));

                if (magnitude < 1) {
                    invMag = mathRound(1 / magnitude)  * 10;
                    ret = mathRound(num * invMag) / invMag;
                }
                return ret;
            }

            /**
             * Set the tick positions of a linear axis to round values like whole tens or every five.
             */
            function setLinearTickPositions() {

                var i,
                roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
                roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval);

                tickPositions = [];

                // populate the intermediate values
                i = correctFloat(roundedMin);
                while (i <= roundedMax) {
                    tickPositions.push(i);
                    i = correctFloat(i + tickInterval);
                }

            }

            /**
             * Set the tick positions to round values and optionally extend the extremes
             * to the nearest tick
             */
            function setTickPositions(secondPass) {
                var length,
                catPad,
                linkedParent,
                linkedParentExtremes,
                tickIntervalOption = options.tickInterval,
                tickPixelIntervalOption = options.tickPixelInterval,
                maxZoom = options.maxZoom || (
                    isXAxis && !defined(options.min) && !defined(options.max) ?
                    mathMin(chart.smallestInterval * 5, dataMax - dataMin) :
                    null
                    ),
                zoomOffset;


                axisLength = horiz ? plotWidth : plotHeight;

                // linked axis gets the extremes from the parent axis
                if (isLinked) {
                    linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
                    linkedParentExtremes = linkedParent.getExtremes();
                    min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                    max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                }

                // initial min and max from the extreme data values
                else {
                    min = pick(userMin, options.min, dataMin);
                    max = pick(userMax, options.max, dataMax);
                }

                if (isLog) {
                    min = log2lin(min);
                    max = log2lin(max);
                }

                // maxZoom exceeded, just center the selection
                if (max - min < maxZoom) {
                    zoomOffset = (maxZoom - max + min) / 2;
                    // if min and max options have been set, don't go beyond it
                    min = mathMax(min - zoomOffset, pick(options.min, min - zoomOffset), dataMin);
                    max = mathMin(min + maxZoom, pick(options.max, min + maxZoom), dataMax);
                }

                // pad the values to get clear of the chart's edges
                if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
                    length = (max - min) || 1;
                    if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) {
                        min -= length * minPadding;
                    }
                    if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) {
                        max += length * maxPadding;
                    }
                }

                // get tickInterval
                if (min === max) {
                    tickInterval = 1;
                }else if (isLinked && !tickIntervalOption &&
                    tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
                    tickInterval = linkedParent.tickInterval;
                } else {
                    tickInterval = pick(
                        tickIntervalOption,
                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix
                        1 :
                        (max - min) * tickPixelIntervalOption / axisLength
                        );
                }

                if (!isDatetimeAxis && !defined(options.tickInterval)) { // linear
                    tickInterval = normalizeTickInterval(tickInterval);
                }
                axis.tickInterval = tickInterval; // record for linked axis

                // get minorTickInterval
                minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
                tickInterval / 5 : options.minorTickInterval;

                // find the tick positions
                if (isDatetimeAxis)	{
                    setDateTimeTickPositions();
                } else {
                    setLinearTickPositions();
                }

                if (!isLinked) {
                    // pad categorised axis to nearest half unit
                    if (categories || (isXAxis && chart.hasColumn)) {
                        catPad = (categories ? 1 : tickInterval) * 0.5;
                        if (categories || !defined(pick(options.min, userMin))) {
                            min -= catPad;
                        }
                        if (categories || !defined(pick(options.max, userMax))) {
                            max += catPad;
                        }
                    }

                    // reset min/max or remove extremes based on start/end on tick
                    var roundedMin = tickPositions[0],
                    roundedMax = tickPositions[tickPositions.length - 1];

                    if (options.startOnTick) {
                        min = roundedMin;
                    } else if (min > roundedMin) {
                        tickPositions.shift();
                    }

                    if (options.endOnTick) {
                        max = roundedMax;
                    } else if (max < roundedMax) {
                        tickPositions.pop();
                    }

                    // record the greatest number of ticks for multi axis
                    if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
                        maxTicks = {
                            x: 0,
                            y: 0
                        };
                    }

                    if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY]) {
                        maxTicks[xOrY] = tickPositions.length;
                    }
                }


            }

            /**
             * When using multiple axes, adjust the number of ticks to match the highest
             * number of ticks in that group
             */
            function adjustTickAmount() {

                if (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale
                    var oldTickAmount = tickAmount,
                    calculatedTickAmount = tickPositions.length;

                    // set the axis-level tickAmount to use below
                    tickAmount = maxTicks[xOrY];

                    if (calculatedTickAmount < tickAmount) {
                        while (tickPositions.length < tickAmount) {
                            tickPositions.push( correctFloat(
                                tickPositions[tickPositions.length - 1] + tickInterval
                                ));
                        }
                        transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
                        max = tickPositions[tickPositions.length - 1];

                    }
                    if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
                        axis.isDirty = true;
                    }
                }

            }

            /**
             * Set the scale based on data min and max, user set min and max or options
             *
             */
            function setScale() {
                var type,
                i;

                oldMin = min;
                oldMax = max;

                // get data extremes if needed
                getSeriesExtremes();

                // get fixed positions based on tickInterval
                setTickPositions();

                // the translation factor used in translate function
                oldTransA = transA;
                transA = axisLength / ((max - min) || 1);

                // reset stacks
                if (!isXAxis) {
                    for (type in stacks) {
                        for (i in stacks[type]) {
                            /*^
                         * Stack line FC first series at lowest position
                         * @source 5281/2.1.4
                         * @code
                         * stacks[type][i].cum = stacks[type][i].total;
                         */
                            stacks[type][i].cum = 0;
                        /* EOP 5281/2.1.4 ^*/
                        }
                    }
                }

                // mark as dirty if it is not already set to dirty and extremes have changed
                if (!axis.isDirty) {
                    axis.isDirty = (min !== oldMin || max !== oldMax);
                }

            }

            /**
             * Set the extremes and optionally redraw
             * @param {Number} newMin
             * @param {Number} newMax
             * @param {Boolean} redraw
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             *
             */
            function setExtremes(newMin, newMax, redraw, animation) {

                redraw = pick(redraw, true); // defaults to true

                fireEvent(axis, 'setExtremes', { // fire an event to enable syncing of multiple charts
                    min: newMin,
                    max: newMax
                }, function() { // the default event handler

                    userMin = newMin;
                    userMax = newMax;


                    // redraw
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });

            }

            /**
             * Get the actual axis extremes
             */
            function getExtremes() {
                return {
                    min: min,
                    max: max,
                    dataMin: dataMin,
                    dataMax: dataMax,
                    userMin: userMin,
                    userMax: userMax
                };
            }

            /**
             * Get the zero plane either based on zero or on the min or max value.
             * Used in bar and area plots
             */
            function getThreshold(threshold) {
                if (min > threshold) {
                    threshold = min;
                }else if (max < threshold) {
                    threshold = max;
                }

                return translate(threshold, 0, 1);
            }

            /**
             * Add a plot band or plot line after render time
             *
             * @param options {Object} The plotBand or plotLine configuration object
             */
            function addPlotBandOrLine(options) {
                var obj = new PlotLineOrBand(options).render();
                plotLinesAndBands.push(obj);
                return obj;
            }

            /**
             * Render the tick labels to a preliminary position to get their sizes
             */
            function getOffset() {
                /**^
                 * issue #680
                 */
                var hasData = pluck(options.showAlways, associatedSeries.length && defined(min) && defined(max)),
                /*EOP^*/
                titleOffset = 0,
                titleMargin = 0,
                axisTitleOptions = options.title,
                labelOptions = options.labels,
                directionFactor = [-1, 1, 1, -1][side],
                n;

                if (!axisGroup) {
                    axisGroup = renderer.g('axis')
                    .attr({
                        zIndex: 7
                    })
                    .add();
                    gridGroup = renderer.g('grid')
                    .attr({
                        zIndex: 1
                    })
                    .add();
                }

                labelOffset = 0; // reset

                if (hasData || isLinked) {
                    each(tickPositions, function(pos) {
                        if (!ticks[pos]) {
                            ticks[pos] = new Tick(pos);
                        } else {
                            ticks[pos].addLabel(); // update labels depending on tick interval
                        }

                        // left side must be align: right and right side must have align: left for labels
                        if (side === 0 || side === 2 || {
                            1: 'left',
                            3: 'right'
                        }
                        [side] === labelOptions.align) {

                            // get the highest offset
                            labelOffset = mathMax(
                                ticks[pos].getLabelSize(),
                                labelOffset
                                );
                        }

                    });

                    if (staggerLines) {
                        labelOffset += (staggerLines - 1) * 16;
                    }

                } else { // doesn't have data
                    for (n in ticks) {
                        ticks[n].destroy();
                        delete ticks[n];
                    }
                }

                if (axisTitleOptions && axisTitleOptions.text) {
                    if (!axis.axisTitle) {
                        axis.axisTitle = renderer.text(
                            axisTitleOptions.text,
                            0,
                            0
                            )
                        .attr({
                            zIndex: 7,
                            rotation: axisTitleOptions.rotation || 0,
                            align:
                            axisTitleOptions.textAlign ||
                            {
                                low: 'left',
                                middle: 'center',
                                high: 'right'
                            }
                            [axisTitleOptions.align]
                        })
                        .css(axisTitleOptions.style)
                        .add();
                    }

                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                    titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);

                }

                // handle automatic or user set offset
                offset = directionFactor * (options.offset || axisOffset[side]);

                axisTitleMargin =
                labelOffset +
                (side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x']) +
                titleMargin;

                axisOffset[side] = mathMax(
                    axisOffset[side],
                    axisTitleMargin + titleOffset + directionFactor * offset
                    );

            }

            /**
             * Render the axis
             */
            function render() {
                var axisTitleOptions = options.title,
                stackLabelOptions = options.stackLabels,
                alternateGridColor = options.alternateGridColor,
                lineWidth = options.lineWidth,
                lineLeft,
                lineTop,
                linePath,
                hasRendered = chart.hasRendered,
                slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
                /**^
                 * issue #680
                 */
                hasData = pluck(options.showAlways, associatedSeries.length && defined(min) && defined(max));
                /* EOP ^*/

                // update metrics
                axisLength = horiz ? plotWidth : plotHeight;
                transA = axisLength / ((max - min) || 1);
                transB = horiz ? plotLeft : marginBottom; // translation addend

                // If the series has data draw the ticks. Else only the line and title
                if (hasData || isLinked) {

                    // minor ticks
                    if (minorTickInterval && !categories) {
                        var pos = min + (tickPositions[0] - min) % minorTickInterval;
                        for (; pos <= max; pos += minorTickInterval) {
                            if (!minorTicks[pos]) {
                                minorTicks[pos] = new Tick(pos, true);
                            }

                            // render new ticks in old position
                            if (slideInTicks && minorTicks[pos].isNew) {
                                minorTicks[pos].render(null, true);
                            }


                            minorTicks[pos].isActive = true;
                            minorTicks[pos].render();
                        }
                    }

                    // major ticks
                    each(tickPositions, function(pos, i) {
                        // linked axes need an extra check to find out if
                        if (!isLinked || (pos >= min && pos <= max)) {

                            // render new ticks in old position
                            if (slideInTicks && ticks[pos].isNew) {
                                ticks[pos].render(i, true);
                            }

                            ticks[pos].isActive = true;
                            ticks[pos].render(i);
                        }
                    });

                    // alternate grid color
                    if (alternateGridColor) {
                        each(tickPositions, function(pos, i) {
                            if (i % 2 === 0 && pos < max) {
                                /*plotLinesAndBands.push(new PlotLineOrBand({
								from: pos,
								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
								color: alternateGridColor
							}));*/

                                if (!alternateBands[pos]) {
                                    alternateBands[pos] = new PlotLineOrBand();
                                }
                                alternateBands[pos].options = {
                                    from: pos,
                                    to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
                                    color: alternateGridColor
                                };
                                alternateBands[pos].render();
                                alternateBands[pos].isActive = true;
                            }
                        });
                    }

                    // custom plot bands (behind grid lines)
                    /*if (!hasRendered) { // only first time
					each(options.plotBands || [], function(plotBandOptions) {
						plotLinesAndBands.push(new PlotLineOrBand(
							extend({ zIndex: 1 }, plotBandOptions)
						).render());
					});
				}*/




                    // custom plot lines and bands
                    if (!hasRendered) { // only first time
                        each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
                            plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
                        });
                    }



                } // end if hasData

                // remove inactive ticks
                each([ticks, minorTicks, alternateBands], function(coll) {
                    var pos;
                    for (pos in coll) {
                        if (!coll[pos].isActive) {
                            coll[pos].destroy();
                            delete coll[pos];
                        } else {
                            coll[pos].isActive = false; // reset
                        }
                    }
                });




                // Static items. As the axis group is cleared on subsequent calls
                // to render, these items are added outside the group.
                // axis line
                if (lineWidth) {
                    lineLeft = plotLeft + (opposite ? plotWidth : 0) + offset;
                    lineTop = chartHeight - marginBottom - (opposite ? plotHeight : 0) + offset;

                    linePath = renderer.crispLine([
                        M,
                        horiz ?
                        plotLeft:
                        lineLeft,
                        horiz ?
                        lineTop:
                        plotTop,
                        L,
                        horiz ?
                        chartWidth - marginRight :
                        lineLeft,
                        horiz ?
                        lineTop:
                        chartHeight - marginBottom
                        ], lineWidth);
                    if (!axisLine) {
                        axisLine = renderer.path(linePath)
                        .attr({
                            stroke: options.lineColor,
                            'stroke-width': lineWidth,
                            zIndex: 7
                        })
                        .add();
                    } else {
                        axisLine.animate({
                            d: linePath
                        });
                    }

                }

                if (axis.axisTitle) {
                    // compute anchor points for each of the title align options
                    var margin = horiz ? plotLeft : plotTop,
                    fontSize = pInt(axisTitleOptions.style.fontSize || 12),
                    // the position in the length direction of the axis
                    alongAxis = {
                        low: margin + (horiz ? 0 : axisLength),
                        middle: margin + axisLength / 2,
                        high: margin + (horiz ? axisLength : 0)
                    }
                    [axisTitleOptions.align],

                    // the position in the perpendicular direction of the axis
                    offAxis = (horiz ? plotTop + plotHeight : plotLeft) +
                    (horiz ? 1 : -1) * // horizontal axis reverses the margin
                    (opposite ? -1 : 1) * // so does opposite axes
                    axisTitleMargin +
                    //(isIE ? fontSize / 3 : 0)+ // preliminary fix for vml's centerline
                    (side === 2 ? fontSize : 0);

                    axis.axisTitle[hasRendered ? 'animate' : 'attr']({
                        x: horiz ?
                        alongAxis:
                        offAxis + (opposite ? plotWidth : 0) + offset +
                        (axisTitleOptions.x || 0), // x
                        y: horiz ?
                        offAxis - (opposite ? plotHeight : 0) + offset:
                        alongAxis + (axisTitleOptions.y || 0) // y
                    });

                }

                // Stacked totals:
                if (stackLabelOptions && stackLabelOptions.enabled) {
                    var stackKey, oneStack, stackCategory,
                    stackTotalGroup = axis.stackTotalGroup;

                    // Create a separate group for the stack total labels
                    if (!stackTotalGroup) {
                        axis.stackTotalGroup = stackTotalGroup =
                        renderer.g('stack-labels')
                        .attr({
                            visibility: VISIBLE,
                            zIndex: 6
                        })
                        .translate(plotLeft, plotTop)
                        .add();
                    }

                    // Render each stack total
                    for (stackKey in stacks) {
                        oneStack = stacks[stackKey];
                        for (stackCategory in oneStack) {
                            oneStack[stackCategory].render(stackTotalGroup);
                        }
                    }
                }
                // End stacked totals

                /**^
                 * Draw scroller
                 */

                var scrollOptions = options.scroll,
                scroller = axis.scroller,
                scrollLeft,
                scrollTop;

                if (scrollOptions && scrollOptions.enabled) {
                    if (horiz) {
                        scrollLeft = plotLeft + offset - 2;
                        scrollTop = chartHeight - marginBottom -
                        (!opposite ?  0 : plotHeight) + offset +
                        scrollOptions.padding - 1;
                    }
                    else {
                        scrollLeft = plotLeft + (opposite ?
                            plotWidth : 0);
                        scrollTop = chartHeight - marginBottom;
                    }

                    if (!scroller) {
                        scroller = axis.scroller = renderer.scroller(scrollLeft,
                            scrollTop, axisLength + 4, scrollOptions.height,
                            horiz, {
                                size: scrollOptions.buttonWidth,
                                padding: scrollOptions.buttonPadding
                            }, false)
                        .attr({
                            fill: scrollOptions.color
                        })
                        .setScrollRatio(scrollOptions.scrollRatio)
                        .setScrollPosition(scrollOptions.startPercent)
                        .callback(function () {
                            axis.scroll.apply(axis, arguments);
                        })
                        .add(axisGroup);
                    }
                }
                /* EOP ^*/

                axis.isDirty = false;
            }

            /**
             * Remove a plot band or plot line from the chart by id
             * @param {Object} id
             */
            function removePlotBandOrLine(id) {
                var i = plotLinesAndBands.length;
                while (i--) {
                    if (plotLinesAndBands[i].id === id) {
                        plotLinesAndBands[i].destroy();
                    }
                }
            }

            /**
             * Redraw the axis to reflect changes in the data or axis extremes
             */
            function redraw() {

                // hide tooltip and hover states
                if (tracker.resetTracker) {
                    tracker.resetTracker();
                }

                // render the axis
                render();

                // move plot lines and bands
                each(plotLinesAndBands, function(plotLine) {
                    plotLine.render();
                });

                // mark associated series as dirty and ready for redraw
                each(associatedSeries, function(series) {
                    series.isDirty = true;
                });

            }

            /**
             * Set new axis categories and optionally redraw
             * @param {Array} newCategories
             * @param {Boolean} doRedraw
             */
            function setCategories(newCategories, doRedraw) {
                // set the categories
                axis.categories = categories = newCategories;

                // force reindexing tooltips
                each(associatedSeries, function(series) {
                    series.translate();
                    series.setTooltipPoints(true);
                });


                // optionally redraw
                axis.isDirty = true;

                if (pick(doRedraw, true)) {
                    chart.redraw();
                }
            }

            /**^
             * Scroll the axis
             */
            function scroll (pos, animation, resetTooltip) {

                var axis = this,
                options = axis.options,
                scrollOptions = options.scroll,
                start = pos,
                axisMin = options.min,
                vxLength = scrollOptions.vxLength,
                vpMax = scrollOptions.viewPortMax,
                vpMin = scrollOptions.viewPortMin,
                scrollableLength = vpMax - vpMin - vxLength,
                newMin = scrollableLength * start + vpMin,
                newMax = newMin + vxLength,
                shift;

                if (resetTooltip === undefined) {
                    resetTooltip = true;
                }

                // hide tooltip and hover states
                if (tracker.resetTracker) {
                    if (resetTooltip) {
                        tracker.resetTracker();
                    }
                    else {
                        chart.tooltip && chart.tooltip.hide();
                    }
                }

                userMin = newMin;
                userMax = newMax;
                setAnimation(pick(animation, false), chart);

                if (hasCartesianSeries) {
                    if (!isResizing) {

                        // reset maxTicks
                        maxTicks = null;

                        // set axes scales
                        axis.setScale();
                    }

                    // move plot lines and bands
                    each(plotLinesAndBands, function(plotLine) {
                        plotLine.render();
                    });

                    shift = transA * (newMin - axisMin);
                    // mark associated series as dirty and ready for redraw
                    each(associatedSeries, function(series) {
                        //series.isDirty = true;
                        series.scroll(shift, 0, resetTooltip);
                    });

                }

                // fire the event
                fireEvent(chart, 'scroll');
            }



            // Run Axis

            // inverted charts have reversed xAxes as default
            if (inverted && isXAxis && reversed === UNDEFINED) {
                reversed = true;
            }


            // expose some variables
            extend(axis, {
                addPlotBand: addPlotBandOrLine,
                addPlotLine: addPlotBandOrLine,
                adjustTickAmount: adjustTickAmount,
                categories: categories,
                getExtremes: getExtremes,
                getPlotLinePath: getPlotLinePath,
                getThreshold: getThreshold,
                isXAxis: isXAxis,
                options: options,
                plotLinesAndBands: plotLinesAndBands,
                getOffset: getOffset,
                render: render,
                setCategories: setCategories,
                setExtremes: setExtremes,
                setScale: setScale,
                setTickPositions: setTickPositions,
                translate: translate,
                redraw: redraw,
                removePlotBand: removePlotBandOrLine,
                removePlotLine: removePlotBandOrLine,
                reversed: reversed,
                stacks: stacks,
                scroll: scroll
            });

            // register event listeners
            for (eventType in events) {
                addEvent(axis, eventType, events[eventType]);
            }

            // set min and max
            setScale();

        } // end Axis


        /**
	 * The toolbar object
	 *
	 * @param {Object} chart
	 */
        function Toolbar(chart) {
            var buttons = {};

            function add(id, text, title, fn) {
                if (!buttons[id]) {
                    var button = renderer.text(
                        text,
                        0,
                        0
                        )
                    .css(options.toolbar.itemStyle)
                    .align({
                        align: 'right',
                        x: - marginRight - 20,
                        y: plotTop + 30
                    })
                    .on('click', fn)
                    /*.on('touchstart', function(e) {
					e.stopPropagation(); // don't fire the container event
					fn();
				})*/
                    .attr({
                        align: 'right',
                        zIndex: 20
                    })
                    .add();
                    buttons[id] = button;
                }
            }
            function remove(id) {
                discardElement(buttons[id].element);
                buttons[id] = null;
            }

            // public
            return {
                add: add,
                remove: remove
            };
        }

        /**
	 * The tooltip object
	 * @param {Object} options Tooltip options
	 */
        function Tooltip (options) {
            var currentSeries,
            borderWidth = options.borderWidth,
            crosshairsOptions = options.crosshairs,
            crosshairs = [],
            style = options.style,
            shared = options.shared,
            padding = pInt(style.padding),
            boxOffLeft = borderWidth + padding, // off left/top position as IE can't
            //properly handle negative positioned shapes
            tooltipIsHidden = true,
            boxWidth,
            boxHeight,
            currentX = 0,
            currentY = 0,
            /**^
             * Global variables needed to control blocking of tooltip
             */
            blocked = false
            ;

            function block (state) {
                blocked = Boolean(state);
                if (blocked) {
                    hide();
                }
            }
            /* EOP ^*/

            // remove padding CSS and apply padding on box instead
            style.padding = 0;

            // create the elements
            var group = renderer.g('tooltip')
            .attr({
                zIndex: 8
            })
            .add(),

            box = renderer.rect(boxOffLeft, boxOffLeft, 0, 0, options.borderRadius, borderWidth)
            .attr({
                fill: options.backgroundColor,
                'stroke-width': borderWidth
            })
            .add(group)
            /**^
             * Patched for advanced shadow
             */
            .shadow(options.shadow, undefined, options.shadow),
            /* EOP ^*/
            label = renderer.text('', padding + boxOffLeft, pInt(style.fontSize) + padding + boxOffLeft)
            .attr({
                zIndex: 1
            })
            .css(style)
            .add(group);

            group.hide();

            /**
             * In case no user defined formatter is given, this will be used
             */
            function defaultFormatter() {
                var pThis = this,
                items = pThis.points || splat(pThis),
                xAxis = items[0].series.xAxis,
                x = pThis.x,
                isDateTime = xAxis && xAxis.options.type === 'datetime',
                useHeader = isString(x) || isDateTime,
                series,
                s;

                // build the header
                s = useHeader ?
                ['<span style="font-size: 10px">' +
                (isDateTime ? dateFormat('%A, %b %e, %Y', x) :  x) +
                '</span>'] : [];

                // build the values
                each(items, function(item) {
                    s.push(item.point.tooltipFormatter(useHeader));
                });
                return s.join('<br/>');
            }

            /**
             * Provide a soft movement for the tooltip
             *
             * @param {Number} finalX
             * @param {Number} finalY
             */
            function move(finalX, finalY) {

                currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
                currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;

                group.translate(currentX, currentY);


                // run on next tick of the mouse tracker
                if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
                    tooltipTick = function() {
                        move(finalX, finalY);
                    };
                }else {
                    tooltipTick = null;
                }
            }

            /**
             * Hide the tooltip
             */
            function hide() {
                if (!tooltipIsHidden) {
                    var hoverPoints = chart.hoverPoints;

                    group.hide();

                    each(crosshairs, function(crosshair) {
                        if (crosshair) {
                            crosshair.hide();
                        }
                    });

                    // hide previous hoverPoints and set new
                    if (hoverPoints) {
                        each(hoverPoints, function(point) {
                            point.setState();
                        });
                    }
                    chart.hoverPoints = null;


                    tooltipIsHidden = true;
                }

            }

            /**
             * Refresh the tooltip's text and position.
             * @param {Object} point
             *
             */
            function refresh(point) {
                var x,
                y,
                boxX,
                boxY,
                show,
                bBox,
                plotX,
                plotY = 0,
                textConfig = {},
                text,
                pointConfig = [],
                tooltipPos = point.tooltipPos,
                formatter = options.formatter || defaultFormatter,
                hoverPoints = chart.hoverPoints;

                /**^
                 * Modify function to accomodate functions to unblock a tooltip
                 * that was blocked due to user events.
                 */
                if (blocked) {
                    hide();
                    return;
                }
                /* EOP ^*/

                // shared tooltip, array is sent over
                if (shared) {

                    // hide previous hoverPoints and set new
                    if (hoverPoints) {
                        each(hoverPoints, function(point) {
                            point.setState();
                        });
                    }
                    chart.hoverPoints = point;

                    each(point, function(item, i) {
                        /*var series = item.series,
						hoverPoint = series.hoverPoint;
					if (hoverPoint) {
						hoverPoint.setState();
					}
					series.hoverPoint = item;*/
                        item.setState(HOVER_STATE);
                        plotY += item.plotY; // for average

                        pointConfig.push(item.getLabelConfig());
                    });

                    plotX = point[0].plotX;
                    plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here

                    textConfig = {
                        x: point[0].category
                    };
                    textConfig.points = pointConfig;
                    point = point[0];

                // single point tooltip
                } else {
                    textConfig = point.getLabelConfig();
                }
                text = formatter.call(textConfig);

                // register the current series
                currentSeries = point.series;

                // get the reference point coordinates (pie charts use tooltipPos)
                plotX = shared ? plotX : point.plotX;
                plotY = shared ? plotY : point.plotY;
                x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
                y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));


                // hide tooltip if the point falls outside the plot
                show = shared || !point.series.isCartesian || isInsidePlot(x, y);

                // update the inner HTML
                if (text === false || !show) {
                    hide();
                }else {

                    // show it
                    if (tooltipIsHidden) {
                        group.show();
                        tooltipIsHidden = false;
                    }

                    // update text
                    label.attr({
                        text: text
                    });

                    // get the bounding box
                    bBox = label.getBBox();
                    boxWidth = bBox.width + 2 * padding;
                    boxHeight = bBox.height + 2 * padding;

                    // set the size of the box
                    box.attr({
                        width: boxWidth,
                        height: boxHeight,
                        stroke: options.borderColor || point.color || currentSeries.color || '#606060'
                    });

                    // keep the box within the chart area
                    boxX = x - boxWidth + plotLeft - 25;
                    boxY = y - boxHeight + plotTop + 10;

                    // it is too far to the left, adjust it
                    if (boxX < 7) {
                        boxX = plotLeft + x + 15;
                    }


                    if (boxY < 5) {
                        boxY = 5; // above
                    } else if (boxY + boxHeight > chartHeight) {
                        boxY = chartHeight - boxHeight - 5; // below
                    }

                    // do the move
                    move(mathRound(boxX - boxOffLeft), mathRound(boxY - boxOffLeft));


                }


                // crosshairs
                if (crosshairsOptions) {
                    crosshairsOptions = splat(crosshairsOptions); // [x, y]

                    var path,
                    i = crosshairsOptions.length,
                    attribs,
                    axis;

                    while (i--) {
                        axis = point.series[i ? 'yAxis' : 'xAxis'];
                        if (crosshairsOptions[i] && axis) {
                            path = axis
                            .getPlotLinePath(point[i ? 'y' : 'x'], 1);
                            if (crosshairs[i]) {
                                crosshairs[i].attr({
                                    d: path,
                                    visibility: VISIBLE
                                });

                            } else {
                                attribs = {
                                    'stroke-width': crosshairsOptions[i].width || 1,
                                    stroke: crosshairsOptions[i].color || '#C0C0C0',
                                    zIndex: 2
                                };
                                if (crosshairsOptions[i].dashStyle) {
                                    attribs.dashstyle = crosshairsOptions[i].dashStyle;
                                }
                                crosshairs[i] = renderer.path(path)
                                .attr(attribs)
                                .add();
                            }
                        }
                    }
                }
            }



            // public members
            return {
                shared: shared,
                refresh: refresh,
                hide: hide,
                /**^
                 * Opened up API to move Tooltips
                 * @source 5827/2.1.4
                 */
                move: move,
                block: block
                /* EOP 5827/2.1.4 ^*/
            };
        }

        /**
	 * The mouse tracker object
	 * @param {Object} chart
	 * @param {Object} options
	 */
        function MouseTracker (chart, options) {


            var mouseDownX,
            mouseDownY,
            hasDragged,
            selectionMarker,
            zoomType = optionsChart.zoomType,
            zoomX = /x/.test(zoomType),
            zoomY = /y/.test(zoomType),
            zoomHor = (zoomX && !inverted) || (zoomY && inverted),
            zoomVert = (zoomY && !inverted) || (zoomX && inverted);

            /**
             * Add crossbrowser support for chartX and chartY
             * @param {Object} e The event object in standard browsers
             */
            function normalizeMouseEvent(e) {
                var ePos,
                pageZoomFix = isWebKit && doc.width / doc.documentElement.clientWidth - 1,
                chartPosLeft,
                chartPosTop,
                chartX,
                chartY;

                // common IE normalizing
                e = e || win.event;
                if (!e.target) {
                    e.target = e.srcElement;
                }

                // iOS
                ePos = e.touches ? e.touches.item(0) : e;

                // in certain cases, get mouse position
                if (e.type !== 'mousemove' || win.opera || pageZoomFix) { // only Opera needs position on mouse move, see below
                    chartPosition = getPosition(container);
                    chartPosLeft = chartPosition.left;
                    chartPosTop = chartPosition.top;
                }

                // chartX and chartY
                if (isIE) { // IE including IE9 that has chartX but in a different meaning
                    chartX = e.x;
                    chartY = e.y;
                }else {
                    if (ePos.layerX === UNDEFINED) { // Opera and iOS
                        chartX = ePos.pageX - chartPosLeft;
                        chartY = ePos.pageY - chartPosTop;
                    } else {
                        chartX = e.layerX;
                        chartY = e.layerY;
                    }
                }

                // correct for page zoom bug in WebKit
                if (pageZoomFix) {
                    chartX += mathRound((pageZoomFix + 1) * chartPosLeft - chartPosLeft);
                    chartY += mathRound((pageZoomFix + 1) * chartPosTop - chartPosTop);
                }

                return extend(e, {
                    chartX: chartX,
                    chartY: chartY
                });
            }

            /**
             * Get the click position in terms of axis values.
             *
             * @param {Object} e A mouse event
             */
            function getMouseCoordinates(e) {
                var coordinates = {
                    xAxis: [],
                    yAxis: []
                };
                each(axes, function(axis, i) {
                    var translate = axis.translate,
                    isXAxis = axis.isXAxis,
                    isHorizontal = inverted ? !isXAxis : isXAxis;

                    coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
                        axis: axis,
                        value: translate(
                            isHorizontal ?
                            e.chartX - plotLeft  :
                            plotHeight - e.chartY + plotTop,
                            true
                            )
                    });
                });
                return coordinates;
            }

            /**
             * With line type charts with a single tracker, get the point closest to the mouse
             */
            function onmousemove (e) {
                var point,
                points,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries,
                i,
                j,
                distance = chartWidth,
                index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?

                // shared tooltip
                if (tooltip && options.shared) {
                    points = [];

                    // loop over all series and find the ones with points closest to the mouse
                    i = series.length;
                    for (j = 0; j < i; j++) {
                        if (series[j].visible && series[j].tooltipPoints.length) {
                            point = series[j].tooltipPoints[index];
                            point._dist = mathAbs(index - point.plotX);
                            distance = mathMin(distance, point._dist);
                            points.push(point);
                        }
                    }
                    // remove furthest points
                    i = points.length;
                    while (i--) {
                        if (points[i]._dist > distance) {
                            points.splice(i, 1);
                        }
                    }
                    // refresh the tooltip if necessary
                    if (points.length && (points[0].plotX !== hoverX)) {
                        tooltip.refresh(points);
                        hoverX = points[0].plotX;
                    }
                }

                // separate tooltip and general mouse events
                if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker

                    /**^
                     * Patched to fix scroll offset.
                     */
                    // get the point
                    point = hoverSeries.tooltipPoints[index +
                    ((inverted ? hoverSeries.yShift : hoverSeries.xShift) || 0)];
                    /* EOP ^*/

                    // a new point is hovered, refresh the tooltip
                    if (point && point !== hoverPoint) {

                        // trigger the events
                        point.onMouseOver();

                    }
                }
            }



            /**
             * Reset the tracking by hiding the tooltip, the hover series state and the hover point
             */
            function resetTracker() {
                var hoverSeries = chart.hoverSeries,
                hoverPoint = chart.hoverPoint;

                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }

                if (hoverSeries) {
                    hoverSeries.onMouseOut();
                }

                if (tooltip) {
                    tooltip.hide();
                }

                hoverX = null;
            }

            /**
             * Mouse up or outside the plot area
             */
            function drop() {
                if (selectionMarker) {
                    var selectionData = {
                        xAxis: [],
                        yAxis: []
                    },
                    selectionBox = selectionMarker.getBBox(),
                    selectionLeft = selectionBox.x - plotLeft,
                    selectionTop = selectionBox.y - plotTop;

                    /**^
                     *changes to get the selection x and y during step zoom[ZOOMLINE]
                     */
                    selectionData.selectionLeft = selectionLeft;
                    selectionData.selectionTop = selectionTop;
                    selectionData.selectionWidth = selectionBox.width;
                    selectionData.selectionHeight = selectionBox.height;
                    /*^EOP*/


                    // a selection has been made
                    if (hasDragged) {

                        // record each axis' min and max
                        each(axes, function(axis, i) {
                            var translate = axis.translate,
                            isXAxis = axis.isXAxis,
                            isHorizontal = inverted ? !isXAxis : isXAxis,
                            selectionMin = translate(
                                isHorizontal ?
                                selectionLeft :
                                plotHeight - selectionTop - selectionBox.height,
                                true,
                                0,
                                0,
                                1
                                ),
                            selectionMax = translate(
                                isHorizontal ?
                                selectionLeft + selectionBox.width :
                                plotHeight - selectionTop,
                                true,
                                0,
                                0,
                                1
                                );

                            selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
                                axis: axis,
                                min: mathMin(selectionMin, selectionMax), // for reversed axes,
                                max: mathMax(selectionMin, selectionMax)
                            });

                        });
                        fireEvent(chart, 'selection', selectionData, zoom);

                    }
                    selectionMarker = selectionMarker.destroy();
                }

                chart.mouseIsDown = mouseIsDown = hasDragged = false;
                removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);

            }

            /**
             * Set the JS events on the container element
             */
            function setDOMEvents () {
                var lastWasOutsidePlot = true;

                /*
                 * Record the starting position of a dragoperation
                 */
                container.onmousedown = function(e) {
                    e = normalizeMouseEvent(e);

                    // issue #295, dragging not always working in Firefox
                    if (!hasTouch && e.preventDefault) {
                        e.preventDefault();
                    }

                    // record the start position
                    chart.mouseIsDown = mouseIsDown = true;
                    mouseDownX = e.chartX;
                    mouseDownY = e.chartY;

                    addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
                };

                // The mousemove, touchmove and touchstart event handler
                var mouseMove = function(e) {

                    // let the system handle multitouch operations like two finger scroll
                    // and pinching
                    if (e && e.touches && e.touches.length > 1) {
                        return;
                    }

                    // normalize
                    e = normalizeMouseEvent(e);
                    if (!hasTouch) { // not for touch devices
                        e.returnValue = false;
                    }

                    var chartX = e.chartX,
                    chartY = e.chartY,
                    isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);

                    // on touch devices, only trigger click if a handler is defined
                    if (hasTouch && e.type === 'touchstart') {
                        if (attr(e.target, 'isTracker')) {
                            if (!chart.runTrackerClick) {
                                e.preventDefault();
                            }
                        } else if (!runChartClick && !isOutsidePlot) {
                            e.preventDefault();
                        }
                    }

                    // cancel on mouse outside
                    if (isOutsidePlot) {

                        if (!lastWasOutsidePlot) {
                            // reset the tracker
                            resetTracker();
                        }

                        // drop the selection if any and reset mouseIsDown and hasDragged
                        //drop();
                        if (chartX < plotLeft) {
                            chartX = plotLeft;
                        } else if (chartX > plotLeft + plotWidth) {
                            chartX = plotLeft + plotWidth;
                        }

                        if (chartY < plotTop) {
                            chartY = plotTop;
                        } else if (chartY > plotTop + plotHeight) {
                            chartY = plotTop + plotHeight;
                        }

                    }

                    if (mouseIsDown && e.type !== 'touchstart') { // make selection

                        // determine if the mouse has moved more than 10px
                        hasDragged = Math.sqrt(
                            Math.pow(mouseDownX - chartX, 2) +
                            Math.pow(mouseDownY - chartY, 2));
                        if (hasDragged > 10) {

                            // make a selection
                            if (hasCartesianSeries && (zoomX || zoomY) &&
                                isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop)) {
                                if (!selectionMarker) {
                                    selectionMarker = renderer.rect(
                                        plotLeft,
                                        plotTop,
                                        zoomHor ? 1 : plotWidth,
                                        zoomVert ? 1 : plotHeight,
                                        0
                                        )
                                    .attr({
                                        fill: 'rgba(69,114,167,0.25)',
                                        zIndex: 7
                                    })
                                    .add();
                                }
                            }

                            // adjust the width of the selection marker
                            if (selectionMarker && zoomHor) {
                                var xSize = chartX - mouseDownX;
                                selectionMarker.attr({
                                    width: mathAbs(xSize),
                                    x: (xSize > 0 ? 0 : xSize) + mouseDownX
                                });
                            }
                            // adjust the height of the selection marker
                            if (selectionMarker && zoomVert) {
                                var ySize = chartY - mouseDownY;
                                selectionMarker.attr({
                                    height: mathAbs(ySize),
                                    y: (ySize > 0 ? 0 : ySize) + mouseDownY
                                });
                            }
                        }

                    } else if (!isOutsidePlot) {
                        // show the tooltip
                        onmousemove(e);
                    }

                    lastWasOutsidePlot = isOutsidePlot;

                    // when outside plot, allow touch-drag by returning true
                    return isOutsidePlot || !hasCartesianSeries;
                };

                /*
			 * When the mouse enters the container, run mouseMove
			 */
                container.onmousemove = mouseMove;

                /*
			 * When the mouse leaves the container, hide the tracking (tooltip).
			 */
                addEvent(container, 'mouseleave', resetTracker);


                container.ontouchstart = function(e) {
                    // For touch devices, use touchmove to zoom
                    if (zoomX || zoomY) {
                        container.onmousedown(e);
                    }
                    // Show tooltip and prevent the lower mouse pseudo event
                    mouseMove(e);
                };

                /*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
                container.ontouchmove = mouseMove;

                /*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
                container.ontouchend = function() {
                    if (hasDragged) {
                        resetTracker();
                    }
                };


                // MooTools 1.2.3 doesn't fire this in IE when using addEvent
                container.onclick = function(e) {
                    var hoverPoint = chart.hoverPoint;
                    e = normalizeMouseEvent(e);

                    e.cancelBubble = true; // IE specific


                    if (!hasDragged) {
                        if (hoverPoint && attr(e.target, 'isTracker')) {
                            var plotX = hoverPoint.plotX,
                            plotY = hoverPoint.plotY;

                            // add page position info
                            extend(hoverPoint, {
                                pageX: chartPosition.left + plotLeft +
                                (inverted ? plotWidth - plotY : plotX),
                                pageY: chartPosition.top + plotTop +
                                (inverted ? plotHeight - plotX : plotY)
                            });

                            // the series click event
                            fireEvent(hoverPoint.series, 'click', extend(e, {
                                point: hoverPoint
                            }));

                            // the point click event
                            hoverPoint.firePointEvent('click', e);

                        } else {
                            extend(e, getMouseCoordinates(e));

                            /**^
                             * Fire click event over all the chart
                             * @source 6251/2.1.4
                             * if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                             *     fireEvent(chart, 'click', e);
                             * }
                             */
                            fireEvent(chart, 'click', e);
                            /* EOP ^*/
                        }


                    }
                    // reset mouseIsDown and hasDragged
                    hasDragged = false;
                };

            }

            /**
             * Create the image map that listens for mouseovers
             */
            placeTrackerGroup = function() {

                // first create - plot positions is not final at this stage
                if (!trackerGroup) {
                    chart.trackerGroup = trackerGroup = renderer.g('tracker')
                    .attr({
                        zIndex: 9
                    })
                    .add();

                // then position - this happens on load and after resizing and changing
                // axis or box positions
                } else {
                    trackerGroup.translate(plotLeft, plotTop);
                    if (inverted) {
                        trackerGroup.attr({
                            width: chart.plotWidth,
                            height: chart.plotHeight
                        }).invert();
                    }
                }
            };


            // Run MouseTracker
            placeTrackerGroup();
            if (options.enabled) {
                chart.tooltip = tooltip = Tooltip(options);
            }

            setDOMEvents();

            // set the fixed interval ticking for the smooth tooltip
            tooltipInterval = setInterval(function() {
                if (tooltipTick) {
                    tooltipTick();
                }
            }, 32);

            // expose properties
            extend(this, {
                zoomX: zoomX,
                zoomY: zoomY,
                resetTracker: resetTracker
            });
        }



        /**
	 * The overview of the chart's series
	 * @param {Object} chart
	 */
        var Legend = function(chart) {

            var options = chart.options.legend;

            if (!options.enabled) {
                return;
            }

            var horizontal = options.layout === 'horizontal',
            symbolWidth = options.symbolWidth,
            symbolPadding = options.symbolPadding,
            allItems,
            style = options.style,
            itemStyle = options.itemStyle,
            itemHoverStyle = options.itemHoverStyle,
            itemHiddenStyle = options.itemHiddenStyle,
            padding = options.padding || 4,
            halfPadding = padding * 0.5,
            rightPadding = 20,
            //lineHeight = options.lineHeight || 16,
            fontSize = pInt(itemStyle.fontSize) || 10,
            y = fontSize + padding,
            /**^
             * remove default 4 px padd at left
             * create few variables requared later
             */
            captionPadding = options.title.padding,
            textPadding = options.textPadding,
            initialItemX = textPadding + padding + symbolWidth + (2 * symbolPadding) + options.initialItemX,
            scrollOptions = options.scroll,
            legendCaption,
            startX = -textPadding - symbolPadding - symbolWidth,
            startY = -fontSize + symbolPadding,
            cx = -textPadding - symbolPadding - symbolWidth / 2,
            cy = -fontSize + symbolPadding + symbolWidth / 2,
            legendGroupContainer, legendBox,
            legendArray = [],
            currentIndex = 0,
            currentRowIndex = 0,
            rowHeight = options.rowHeight,
            legendNumColumns = options.legendNumColumns,
            tempRow,
            tempColumn,
            numberOfCell,
            tempCurrentIndex,
            j,
            heightOption = options.height,
            /* EOP ^*/
            itemX,
            itemY,
            lastItemY,
            itemHeight = 0,
            box,
            legendBorderWidth = options.borderWidth,
            legendBackgroundColor = options.backgroundColor,
            legendGroup,
            offsetWidth,
            widthOption = options.width,
            legendGroupWidth = widthOption,
            series = chart.series,
            reversedLegend = options.reversed;

            /**^
             * Add functions to allow dragable legend
             */
            function moveLegend (event) {

                // Compute the position of the legend that has to be translated
                var transX = event.pageX + legendBox.dragOffsetX,
                transY = event.pageY + legendBox.dragOffsetY;

                // Prevent movement of legend beyond the chart dimension
                if (transX < legendBox.movementBoundaryOrigin) {
                    transX = legendBox.movementBoundaryOrigin;
                }
                else if (transX > legendBox.movementBoundaryX) {
                    transX = legendBox.movementBoundaryX;
                }
                if (transY < legendBox.movementBoundaryOrigin) {
                    transY = legendBox.movementBoundaryOrigin;
                }
                else if (transY > legendBox.movementBoundaryY) {
                    transY = legendBox.movementBoundaryY;
                }

                // move the legend
                legendBox.translate(transX, transY);

            }
            /* EOP ^*/

            /**^
             * Added colorization of custom symbol
             */
            /**
             * Set the colors for the legend item
             * @param {Object} item A Series or Point instance
             * @param {Object} visible Dimmed or colored
             */
            function colorizeItem(item, visible) {
                var legendItem = item.legendItem,
                legendLine = item.legendLine,
                legendSymbol = item.legendSymbol,
                hiddenColor = itemHiddenStyle.color,
                textColor = visible ? options.itemStyle.color : hiddenColor,
                lineColor = visible ? item.color : hiddenColor,
                customSymbol = item.customSymbol,
                symbolAttr = visible ? item.pointAttr[NORMAL_STATE] : {
                    stroke: hiddenColor,
                    fill: hiddenColor
                };

                if (legendItem) {
                    legendItem.css({
                        fill: textColor
                    });
                }

                if (legendLine) {
                    legendLine.attr({
                        stroke: lineColor,
                        // Prevent the line from getting thick when the plot-line is
                        // thick.
                        'stroke-width': 2,
                        'stroke-opacity': 1
                    });
                }

                if (legendSymbol) {
                    legendSymbol.attr(symbolAttr);
                    legendSymbol.attr({
                        r: mathCeil(symbolWidth / (legendLine ? 4 : 2)), // mathRound to fix VML issue #1814
                        // Prevent the marker from inheriting stroke thickness and alpha.
                        'stroke-width': 1,
                        'stroke-opacity': 1,
                        'fill-opacity': 1
                    });
                }

                if (customSymbol) {
                    // Note: when not visible, symbolAttr is hidden styles
                    customSymbol.attr(visible ? customSymbol.symbolAttr : symbolAttr);
                }
            }
            /* EOP ^*/

            /**^
             * Custom legend symbol added
             */
            /**
             * Position the legend item
             * @param {Object} item A Series or Point instance
             * @param {Object} visible Dimmed or colored
             */
            function positionItem (item, itemX, itemY) {
                var legendItem = item.legendItem,
                legendLine = item.legendLine,
                legendSymbol = item.legendSymbol,
                checkbox = item.checkbox,
                customSymbol = item.customSymbol,
                legendLabelHeight = item.legendLabelHeight;

                if (legendItem) {
                    legendItem.align({
                        x: itemX,
                        y: itemY,
                        height: legendLabelHeight,
                        verticalAlign: 'middle'
                    }, true, {
                        height: item.legendItemHeight
                    });
                }

                if (legendLine) {
                    legendLine.translate(itemX, itemY);
                }

                if (legendSymbol) {
                    legendSymbol.attr({
                        x: itemX + cx,
                        y: itemY + cy
                    });
                }

                if (customSymbol) {
                    item.customSymbol.translate(itemX, itemY);
                }

                if (checkbox) {
                    checkbox.x = itemX;
                    checkbox.y = itemY;
                }
            }
            /* EOP ^*/

            /**
             * Destroy a single legend item
             * @param {Object} item The series or point
             */
            function destroyItem(item) {
                var checkbox = item.checkbox;

                // pull out from the array
                //erase(allItems, item);

                // destroy SVG elements
                each(['legendItem', 'legendLine', 'legendSymbol'], function(key) {
                    if (item[key]) {
                        item[key].destroy();
                    }
                });

                if (checkbox) {
                    discardElement(item.checkbox);
                }


            }


            /**
             * Position the checkboxes after the width is determined
             */
            function positionCheckboxes() {
                each(allItems, function(item) {
                    var checkbox = item.checkbox,
                    alignAttr = legendGroup.alignAttr;
                    if (checkbox) {
                        css(checkbox, {
                            left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) +PX,
                            top: (alignAttr.translateY + checkbox.y - 11) + PX
                        });
                    }
                });
            }

            /**
             * Render a single specific legend item
             * @param {Object} item A series or point
             */
            function renderItem(item) {
                var bBox,
                itemWidth,
                legendSymbol,
                simpleSymbol,
                li = item.legendItem,
                series = item.series || item,
                i = allItems.length,
                itemOptions = series.options;

                if (!li) { // generate it once, later move it

                    // let these series types use a simple symbol
                    simpleSymbol = /^(bar|pie|area|column|column3d|bar3d|floatedcolumn|radar)$/.test(series.type);

                    // generate the list item text
                    item.legendItem = li = renderer.text(
                        options.labelFormatter.call(item),
                        0,
                        0
                        )
                    .css(item.visible ? itemStyle : itemHiddenStyle)
                    .on('mouseover', function() {
                        item.setState(HOVER_STATE);
                        li.css(itemHoverStyle);
                    })
                    .on('mouseout', function() {
                        li.css(item.visible ? itemStyle : itemHiddenStyle);
                        item.setState();
                    })
                    .on('click', function(event) {
                        var strLegendItemClick = 'legendItemClick',
                        fnLegendItemClick = function() {
                            /**^ Not to redraw the chart
                             *@source 6504/2.1.4
                             * item.setVisible();
                             */
                            item.setVisible(undefined, false);
                            /* EOP 6504/2.1.4 ^*/
                        };

                        /**^
                         * do not perform drag event if
                         * dragActive is marked true
                         */
                        if (legendGroup.dragActive) {
                            delete legendGroup.dragActive;
                            return false;
                        }
                        /* EOP ^*/

                        // click the name or symbol
                        if (item.firePointEvent) { // point
                            item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
                        } else {
                            fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
                        }
                    })
                    .attr({
                        zIndex: 2
                    })
                    .add(legendGroup);

                    // draw the line
                    if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
                        var attrs = {
                            'stroke-width': itemOptions.lineWidth,
                            zIndex: 2
                        };
                        if (itemOptions.dashStyle) {
                            attrs.dashstyle = itemOptions.dashStyle;
                        }
                        item.legendLine = renderer.path([
                            M,
                            startX,
                            cy,
                            L,
                            startX + symbolWidth,
                            cy
                            ])
                        .attr(attrs)
                        .add(legendGroup);
                    }

                    // draw a simple symbol
                    if (simpleSymbol) { // bar|pie|area|column
                        /**^
                         * @source 6535/2.1.4
                         */
                        var symbolObj = getSymbolPath(
                            startX,
                            startY,
                            symbolWidth,
                            // Patch to make symbol size increase proportionaltely.
                            symbolWidth,
                            series.type,
                            item,
                            renderer);

                        item.customSymbol = renderer.path(symbolObj.path)
                        .attr({
                            'stroke-width': symbolObj.strokeWidth,
                            zIndex: 3
                        })
                        .add(legendGroup);

                        item.customSymbol.symbolAttr = {
                            stroke: symbolObj.strokeColor,
                            fill: symbolObj.color
                        };
                    }
                    /* EOP 6535/2.1.4 ^*/

                    // draw the marker
                    else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) {
                        legendSymbol = renderer.symbol(
                            item.symbol,
                            cx,
                            cy,
                            symbolWidth / 2
                            )
                        .attr({
                            zIndex: 3
                        })
                        .add(legendGroup);

                    }


                    item.legendSymbol = legendSymbol;

                    // colorize the items
                    colorizeItem(item, item.visible);

                    /**^
                     * Extend Mouse interactions to Symbol
                     */
                    var symbolObject = legendSymbol || item.customSymbol;
                    if (symbolObject) {
                        symbolObject.css(options.symbolStyle)
                        .on('click', function () {
                            fireEvent(li.element, 'click');
                        })
                    }
                    /* EOP ^*/

                    // add the HTML checkbox on top
                    if (itemOptions && itemOptions.showCheckbox) {
                        item.checkbox = createElement('input', {
                            type: 'checkbox',
                            checked: item.selected,
                            defaultChecked: item.selected // required by IE7
                        }, options.itemCheckboxStyle, container);

                        addEvent(item.checkbox, 'click', function(event) {
                            var target = event.target;
                            fireEvent(item, 'checkboxClick', {
                                checked: target.checked
                            },
                            function() {
                                item.select();
                            }
                            );
                        });
                    }
                }


                // calculate the positions for the next line
                bBox = li.getBBox();

                itemWidth = item.legendItemWidth =
                options.itemWidth || symbolWidth + symbolPadding + bBox.width + rightPadding;
                /**^
                 * Ensure Legend item occupy height of symbol in case
                 * symbol  height is larger than text.
                 */
                itemHeight = item.legendItemHeight = mathMax(bBox.height,
                    rowHeight);
                item.legendLabelHeight = bBox.height;
                item.symbolSize = symbolWidth;
                item.lineHeight = rowHeight;

                // if the item exceeds the width, start a new line
                if (horizontal){
                    if (rowHeight && legendNumColumns){
                        while (legendArray[currentIndex] === true) {
                            currentIndex += 1;
                        }
                        tempRow = mathFloor(currentIndex / legendNumColumns);
                        tempColumn = currentIndex % legendNumColumns;
                        if (tempRow > currentRowIndex) {
                            itemY += rowHeight * (tempRow - currentRowIndex);
                            currentRowIndex = tempRow
                        }
                        itemX = initialItemX + (tempColumn * itemWidth);
                        legendArray[currentIndex] = true;
                        numberOfCell = itemHeight / rowHeight;
                        tempCurrentIndex = currentIndex;
                        for (j = 0; j < numberOfCell; j += 1, tempCurrentIndex += legendNumColumns) {
                            legendArray[tempCurrentIndex] = true;
                        }

                    }
                    else if(itemX - initialItemX + itemWidth >
                        (widthOption || (chartWidth - 2 * padding - initialItemX))) {
                        itemX = initialItemX;
                        itemY += itemHeight;
                    }
                }
                /* EOP ^*/
                lastItemY = itemY;

                // position the newly generated or reordered items
                positionItem(item, itemX, itemY);

                // advance
                if (horizontal)  {
                    itemX += itemWidth;
                } else {
                    itemY += itemHeight;
                }

                // the width of the widest item
                offsetWidth = widthOption || mathMax(
                    horizontal ? itemX - initialItemX : itemWidth,
                    offsetWidth
                    );



            // add it all to an array to use below
            //allItems.push(item);
            }

            /**^
             * Render the legend. This method can be called both before and after
             * chart.render. If called after, it will only rearrange items instead
             * of creating new ones.
             */
            function renderLegend() {
                var halfBorderWidth = legendBorderWidth * 0.5;

                itemX = initialItemX;
                itemY = y;
                offsetWidth = 0;
                lastItemY = 0;

                if (!legendGroup) {

                    /**^
                     * Changed the legend z index so that it
                     * stay on top of every thing
                     */
                    var clipRect,
                    cliprectX, cliprectY, cliprectW, cliprectH;
                    if (scrollOptions && scrollOptions.enabled) {
                        legendBox = renderer.g('legend-box')
                        .attr({
                            zIndex: 10
                        })
                        .add();

                        cliprectX = 0;
                        cliprectY = halfPadding + halfBorderWidth;
                        cliprectW = legendGroupWidth = widthOption -
                        scrollOptions.scrollBarWidth -
                        scrollOptions.scrollBarPadding;
                        cliprectH = heightOption - halfPadding - legendBorderWidth;
                        clipRect =  renderer.clipRect(cliprectX, cliprectY,
                            cliprectW, cliprectH);

                        legendGroupContainer = renderer.g('legend-container')
                        .attr({
                            zIndex: 1
                        })
                        .clip(clipRect)
                        .add(legendBox);

                        legendGroup = renderer.g('legend')
                        .add(legendGroupContainer);

                        renderer.scroller(cliprectW + halfPadding - halfBorderWidth,
                            halfBorderWidth, 10, cliprectH + 1,
                            false, false, false, legendBox)
                        .attr({
                            zIndex: 3,
                            fill: options.legendScrollBgColor
                        })
                        .setScrollRatio((cliprectH + padding) / options.totalHeight)
                        .callback(function () {
                            legendGroup.translate(0, (cliprectH - options.totalHeight) * arguments[0]);
                        })
                        .add(legendBox);
                    }
                    else {
                        legendGroupContainer = legendBox = legendGroup = renderer.g('legend')
                        .attr({
                            zIndex: 10
                        })
                        .add()
                    }
                    /* EOP ^*/

                    /**^
                     * Add legend dragging events and configuration.
                     */
                    if (options.legendAllowDrag) {
                        legendBox.css({
                            cursor: 'move'
                        });
                        addEvent(legendBox.element, 'dragstart dragend', function (event) {
                            legendBox.movementBoundaryOrigin = legendBorderWidth || 0;
                            legendBox.movementBoundaryX = chartWidth - widthOption - legendBox.movementBoundaryOrigin;
                            legendBox.movementBoundaryY = chartHeight - heightOption - legendBox.movementBoundaryOrigin;
                            legendBox.dragOffsetX = legendBox.attr('translateX') - event.pageX,
                            legendBox.dragOffsetY = legendBox.attr('translateY') - event.pageY;
                            legendBox.dragActive = true;
                            if (tooltip) {
                                tooltip.block(event.type === 'dragstart');
                            }
                        });

                        addEvent(legendBox.element, 'drag', moveLegend);
                    }
                /* EOP ^*/
                }
                /**^
                 * Draw the caption
                 */
                if (options.title && options.title.text !== BLANKSTRING) {
                    legendCaption = renderer.text(
                        options.title.text,
                        0,
                        0
                        )
                    .css(options.title.style)
                    .attr({
                        zIndex: 2,
                        align : 'center'
                    })
                    .add(legendGroup);
                    var legendcaptionBBox = legendCaption.getBBox();
                    //padd 6px remaning 4 into the space between title and items

                    legendCaption.align({
                        align : 'center',
                        verticalAlign : 'top',
                        y : itemY
                    }, false, {
                        x : 0,
                        y : 0,
                        width : legendGroupWidth,
                        height : legendcaptionBBox.height
                    });
                    itemY += ((legendcaptionBBox.height || 0) + captionPadding);
                }
                /* EOP ^*/

                // add each series or point
                allItems = [];
                each(series, function(serie) {
                    var seriesOptions = serie.options;

                    if (!seriesOptions.showInLegend) {
                        return;
                    }

                    // use points or series for the legend item depending on legendType
                    if (seriesOptions.legendType === 'point') {
                        each (serie.data, function (point) {
                            if (!point.showInLegend) {
                                return;
                            }
                            else {
                                allItems = allItems.concat(point)
                            }
                        });
                    }
                    else {
                        allItems = allItems.concat(
                            serie
                            );
                    }
                });

                // sort by legendIndex
                allItems.sort(function(a, b) {
                    return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
                });

                // reversed legend
                if (reversedLegend) {
                    allItems.reverse();
                }

                // render the items
                each(allItems, renderItem);

                // Draw the border
                legendWidth = widthOption || offsetWidth;
                legendHeight = lastItemY - y + itemHeight;

                if (legendBorderWidth || legendBackgroundColor) {

                    if (!box) {
                        box = renderer.rect(
                            0,
                            0,
                            legendWidth,
                            heightOption,
                            options.borderRadius,
                            legendBorderWidth || 0
                            ).attr({
                            stroke: options.borderColor,
                            'stroke-width': legendBorderWidth || 0,
                            fill: legendBackgroundColor || NONE
                        })
                        .add(legendBox)
                        /**^
                         * Allowed to pass more advanced shadow options
                         */
                        .shadow(options.shadow, undefined, options.shadow);
                        /* EOP ^*/

                    } else if (legendWidth > 0 && legendHeight > 0) {
                        box.animate(
                            box.crisp(null, null, null, legendWidth, heightOption)
                            );
                    }

                    // hide the border if no items
                    box[allItems.length ? 'show' : 'hide']();
                }

                // 1.x compatibility: positioning based on style
                var props = ['left', 'right', 'top', 'bottom'],
                prop,
                i = 4;
                while(i--) {
                    prop = props[i];
                    if (style[prop] && style[prop] !== 'auto') {
                        options[i < 2 ? 'align' : 'verticalAlign'] = prop;
                        options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
                    }
                }

                if (!horizontal) {//align the chart legend when it is on right
                    options.y = (chart.options.chart.marginTop - chart.options.chart.marginBottom) / 2;
                }


                legendBox.align(extend(options, {
                    width: legendWidth,
                    height: heightOption
                }), true, spacingBox);

                if (!isResizing) {
                    positionCheckboxes();
                }
            }


            // run legend
            renderLegend();

            // move checkboxes
            addEvent(chart, 'endResize', positionCheckboxes);

            // expose
            return {
                colorizeItem: colorizeItem,
                destroyItem: destroyItem,
                renderLegend: renderLegend
            };
        };






        /**
	 * Initialize an individual series, called internally before render time
	 */
        function initSeries(options) {
            var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
            typeClass = seriesTypes[type],
            serie,
            hasRendered = chart.hasRendered;

            // an inverted chart can't take a column series and vice versa
            if (hasRendered) {
                if (inverted && type === 'column') {
                    typeClass = seriesTypes.bar;
                } else if (!inverted && type === 'bar') {
                    typeClass = seriesTypes.column;
                }
            }

            serie = new typeClass();

            serie.init(chart, options);

            // set internal chart properties
            if (!hasRendered && serie.inverted) {
                inverted = true;
            }
            if (serie.isCartesian) {
                hasCartesianSeries = serie.isCartesian;
            }

            series.push(serie);

            return serie;
        }

        /**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
        function addSeries(options, redraw, animation) {
            var series;

            if (options) {
                setAnimation(animation, chart);
                redraw = pick(redraw, true); // defaults to true

                fireEvent(chart, 'addSeries', {
                    options: options
                }, function() {
                    series = initSeries(options);
                    series.isDirty = true;

                    chart.isDirtyLegend = true; // the series array is out of sync with the display
                    if (redraw) {
                        chart.redraw();
                    }
                });
            }

            return series;
        }

        /**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} x Pixel x relative to the coordinateSystem
	 * @param {Number} y Pixel y relative to the coordinateSystem
	 */
        isInsidePlot = function(x, y) {
            return x >= 0 &&
            x <= plotWidth &&
            y >= 0 &&
            y <= plotHeight;
        };

        /**
         * Adjust all axes tick amounts
         */
        function adjustTickAmounts() {
            if (optionsChart.alignTicks !== false) {
                each(axes, function(axis) {
                    axis.adjustTickAmount();
                });
            }
            maxTicks = null;
        }

        /**
         * Redraw legend, axes or series based on updated data
         *
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        function redraw(animation) {
            var redrawLegend = chart.isDirtyLegend,
            hasStackedSeries,
            isDirtyBox = chart.isDirtyBox, 
            seriesLength = series.length,
            i = seriesLength,
            clipRect = chart.clipRect,
            serie;

            setAnimation(animation, chart);

            // link stacked series
            while (i--) {
                serie = series[i];
                if (serie.isDirty && serie.options.stacking) {
                    hasStackedSeries = true;
                    break;
                }
            }
            if (hasStackedSeries) { // mark others as dirty
                i = seriesLength;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }

            // handle updated data in the series
            each(series, function(serie) {
                if (serie.isDirty) { // prepare the data so axis can read it
                    serie.cleanData();
                    serie.getSegments();

                    if (serie.options.legendType === 'point') {
                        redrawLegend = true;
                    }
                }
            });

            // handle added or removed series
            if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
                // draw legend graphics
                legend.renderLegend();

                chart.isDirtyLegend = false;
            }

            if (hasCartesianSeries) {
                if (!isResizing) {

                    // reset maxTicks
                    maxTicks = null;

                    // set axes scales
                    each(axes, function(axis) {
                        axis.setScale();
                    });
                }
                adjustTickAmounts();
                getMargins();

                // redraw axes
                each(axes, function(axis) {
                    if (axis.isDirty || isDirtyBox) {
                        axis.redraw();
                        isDirtyBox = true; // always redraw box to reflect changes in the axis labels
                    }
                });


            }

            // the plot areas size has changed
            if (isDirtyBox) {
                drawChartBox();
                placeTrackerGroup();

                // move clip rect
                if (clipRect) {
                    stop(clipRect);
                    clipRect.animate({ // for chart resize
                        
                        width: chart.plotSizeX,
                        height: chart.plotSizeY
                    });
                }

            }


            // redraw affected series
            each(series, function(serie) {
                if (serie.isDirty && serie.visible &&
                    (!serie.isCartesian || serie.xAxis)) { // issue #153
                    serie.redraw();
                }
            });


            // hide tooltip and hover states
            if (tracker && tracker.resetTracker) {
                tracker.resetTracker();
            }

            // fire the event
            fireEvent(chart, 'redraw');
        }



        /**^
         * Dim the chart and show a loading text or symbol
         * @param {String} str An optional text to show in the loading label instead of the default one
         */
        function showLoading(str) {
            var loadingOptions = options.loading,
            labelStyle = loadingOptions.labelStyle;

            // create the layer at the first call
            if (!loadingDiv) {
                loadingDiv = createElement(DIV, {
                    className: 'highcharts-loading'
                }, extend(loadingOptions.style, {
                    left: 0,
                    top: 0,
                    width: chartWidth + PX,
                    height: chartHeight + PX,
                    zIndex: 22,
                    display: NONE
                }), container);

                extend(labelStyle, {
                    top: (chartHeight / 2 - 3) + PX
                });
                loadingSpan = createElement(
                    'span',
                    null,
                    labelStyle,
                    loadingDiv
                    );

            }
            /** EOP ^*/

            // update text
            loadingSpan.innerHTML = str || options.lang.loading;

            // show it
            if (!loadingShown) {
                css(loadingDiv, {
                    opacity: 0,
                    display: ''
                });
                animate(loadingDiv, {
                    opacity: loadingOptions.style.opacity
                }, {
                    duration: loadingOptions.showDuration
                });
                loadingShown = true;
            }
        }
        /**
	 * Hide the loading layer
	 */
        function hideLoading() {
            animate(loadingDiv, {
                opacity: 0
            }, {
                duration: options.loading.hideDuration,
                complete: function() {
                    css(loadingDiv, {
                        display: NONE
                    });
                }
            });
            loadingShown = false;
        }

        /**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
        function get(id) {
            var i,
            j,
            data;

            // search axes
            for (i = 0; i < axes.length; i++) {
                if (axes[i].options.id === id) {
                    return axes[i];
                }
            }

            // search series
            for (i = 0; i < series.length; i++) {
                if (series[i].options.id === id) {
                    return series[i];
                }
            }

            // search points
            for (i = 0; i < series.length; i++) {
                data = series[i].data;
                for (j = 0; j < data.length; j++) {
                    if (data[j].id === id) {
                        return data[j];
                    }
                }
            }
            return null;
        }

        /**
	 * Create the Axis instances based on the config options
	 */
        function getAxes() {
            var xAxisOptions = options.xAxis || {},
            yAxisOptions = options.yAxis || {},
            axis;

            // make sure the options are arrays and add some members
            xAxisOptions = splat(xAxisOptions);
            each(xAxisOptions, function(axis, i) {
                axis.index = i;
                axis.isX = true;
            });

            yAxisOptions = splat(yAxisOptions);
            each(yAxisOptions, function(axis, i) {
                axis.index = i;
            });

            // concatenate all axis options into one array
            axes = xAxisOptions.concat(yAxisOptions);

            // loop the options and construct axis objects
            chart.xAxis = [];
            chart.yAxis = [];
            axes = map(axes, function(axisOptions) {
                axis = new Axis(chart, axisOptions);
                chart[axis.isXAxis ? 'xAxis' : 'yAxis'].push(axis);

                return axis;
            });

            adjustTickAmounts();
        }


        /**
	 * Get the currently selected points from all series
	 */
        function getSelectedPoints() {
            var points = [];
            each(series, function(serie) {
                points = points.concat( grep( serie.data, function(point) {
                    return point.selected;
                }));
            });
            return points;
        }

        /**
	 * Get the currently selected series
	 */
        function getSelectedSeries() {
            return grep(series, function (serie) {
                return serie.selected;
            });
        }

        /**
	 * Zoom out to 1:1
	 */
        zoomOut = function () {

            if (chart.stepZoom && stepZoom) {
                stepZoom(undefined, undefined, 0);
            }
            else {

                fireEvent(chart, 'selection', {
                    resetSelection: true
                }, zoom);
            }
            chart.toolbar.remove('zoom');

        };

        stepZoom = function (startIndex, stopIndex, resetIndex) {
            var optionsStep = chart.stepZoom,
            zoomHistory = optionsStep.zoomHistory,
            currentZLIndex = optionsStep.currentZoomLevelIndex,
            lastZoomHistory,
            pixelsPerPoint = optionsStep.pixelsPerPoint,
            series = chart.series,
            seriesLength = series.length,
            dataLength = optionsStep.maxIndex,
            width,
            stepping,
            visibleLength,
            perPointPixelDistance,
            seriesStart,
            seriesEnd,
            currentZoomConfig,
            scrollRatio,
            plotX, seriesPointLength, seriesPXLength, scrollablePXLength, scrollPosition,
            i;

            if (resetIndex < currentZLIndex) {
                currentZLIndex = optionsStep.currentZoomLevelIndex = resetIndex || (resetIndex = 0);
                zoomHistory.splice(currentZLIndex + 1, zoomHistory.length);

                currentZoomConfig = zoomHistory[currentZLIndex];
                stepping = currentZoomConfig.stepping;
                seriesStart = currentZoomConfig.seriesStart;
                perPointPixelDistance = currentZoomConfig.perPointPixelDistance;
                scrollRatio = currentZoomConfig.scrollRatio;
                scrollPosition = optionsStep.scrollPosition = currentZoomConfig.scrollPosition;
                optionsStep.scrollablePXLength = currentZoomConfig.scrollablePXLength;
            }
            else {

                if (startIndex > stopIndex) {
                    var swapper = startIndex;
                    startIndex = stopIndex;
                    stopIndex = swapper;
                }

                width = chart.plotWidth;
                visibleLength = stopIndex - startIndex,
                perPointPixelDistance = width / visibleLength;
                if (perPointPixelDistance < pixelsPerPoint) {
                    stepping = Math.ceil(pixelsPerPoint / perPointPixelDistance);
                }
                else {
                    stepping = 1;
                }
                //recalculate perPointPixelDistance
                perPointPixelDistance = width / (visibleLength -
                    (visibleLength % stepping));

                seriesStart = startIndex % stepping;
                seriesEnd = dataLength - (dataLength % stepping);
                seriesPointLength = seriesEnd - seriesStart;
                seriesPXLength = seriesPointLength * perPointPixelDistance;
                scrollRatio = width / seriesPXLength;
                scrollablePXLength = seriesPXLength - width;
                if (scrollablePXLength > 0) {
                    scrollPosition = ((startIndex - seriesStart)* perPointPixelDistance) / (seriesPXLength - width);
                }
                else {
                    scrollPosition = 0
                }

                optionsStep.scrollPosition = scrollPosition;
                optionsStep.scrollablePXLength = scrollablePXLength;

                // Check if no zooming is needed.
                lastZoomHistory = zoomHistory[currentZLIndex];
                if (lastZoomHistory && lastZoomHistory.stepping === stepping &&
                    lastZoomHistory.seriesStart === seriesStart &&
                    lastZoomHistory.seriesEnd === seriesEnd &&
                    lastZoomHistory.seriesEnd === perPointPixelDistance) {
                    return;
                }

                zoomHistory[(optionsStep.currentZoomLevelIndex = (currentZLIndex += 1))] = {
                    seriesStart : seriesStart,
                    seriesEnd : seriesEnd,
                    stepping : stepping,
                    perPointPixelDistance : perPointPixelDistance,
                    visiblePointDistance : stepping * perPointPixelDistance,
                    seriesConf : [],
                    scrollRatio: scrollRatio,
                    scrollPosition: scrollPosition,
                    scrollablePXLength: scrollablePXLength
                };
            }

            var offset, j, seriesPath = [], seriesConf, graphPath, serie, point, catLabelX,
            showHideStr, pointHidden, labelObj, commandArr = [undefined, M, L];
            for (i = 0; i <= dataLength; i += 1) {
                offset = i - seriesStart;
                plotX = offset * perPointPixelDistance;
                catLabelX = plotX + optionsStep.xDisplacement;
                pointHidden = offset < 0 || offset % stepping !== 0;
                showHideStr = pointHidden ? 'hide' : 'show';
                //set cat labels
                labelObj = optionsStep.catLabelArr[i];
                if (labelObj) {
                    labelObj[showHideStr]();                    
                    labelObj.attr({
                        x : catLabelX
                    });
                }



                for (j = 0; j < seriesLength; j += 1) {
                    serie = series[j];
                    point = serie.data[i];
                    point.plotX = plotX;
                    seriesConf = seriesPath[j] || (seriesPath[j] = {
                        path : [],
                        addMove : true,
                        addLine : false,
                        lastMovePoint : [],                    
                        connectNullData : serie.options.connectNullData
                    });
                    graphPath = seriesConf.path;
                    //anchor
                    if (point.graphic) {
                        point.graphic.attr({
                            x: plotX
                        });
                        point.graphic[showHideStr]();
                    }
                    //datalabels
                    if (point.dataLabel && point.dataLabel.attr) {
                        point.dataLabel.attr({
                            x : plotX
                        });
                        point.dataLabel[showHideStr]();
                    }
                    //traker
                    if (point.tracker && point.tracker.attr) {
                        point.tracker.attr({
                            x : plotX
                        });
                        point.tracker[showHideStr]();
                    }
                    
                    
                    //create graph command
                    if(!pointHidden) {                            
                        if (point && point.plotY) {
                            if (seriesConf.addLine) {
                                graphPath.push(M, seriesConf.lastMovePoint[0], seriesConf.lastMovePoint[1], L);
                                seriesConf.addLine = false;
                            }
                            if (seriesConf.addMove) {
                                seriesConf.addLine = true;
                                seriesConf.addMove = false
                                seriesConf.lastMovePoint[0] = plotX;
                                seriesConf.lastMovePoint[1] = point.plotY;
                            }
                            else {
                                graphPath.push(plotX, point.plotY);
                            }
                        }
                        else if (!seriesConf.connectNullData){
                            seriesConf.addMove = true;
                        }
                    }
                }
            }
            for (j = 0; j < seriesLength; j += 1) {
                seriesConf = seriesPath[j] || (seriesPath[j] = {
                    path : [M], 
                    isLastMoveComand : true
                });
                graphPath = seriesConf.path;
                series[j].graphLine.attr({
                    d : graphPath
                });
            }

            optionsStep.scroller.setScrollRatio(scrollRatio);
            optionsStep.scroller.setScrollPosition(scrollPosition);

        };



        //this function conver the PX position to corrosponding point index
        var stepZoomNormalizeEvent = function (event) {
            var optionsStep = chart.stepZoom,
            zoomHistory = optionsStep.zoomHistory,
            currentZLIndex = optionsStep.currentZoomLevelIndex,
            zoomLavelObj = zoomHistory[currentZLIndex],
            perPointPixelDistance = zoomLavelObj.perPointPixelDistance,
            selectionLeft = event.selectionLeft,
            selectionWidth = event.selectionWidth,
            maxIndex = optionsStep.maxIndex,
            min, max;
            //get the px length
            min = (zoomLavelObj.scrollablePXLength * zoomLavelObj.scrollPosition) + selectionLeft;
            max = min + selectionWidth;
            min = Math.floor(min / perPointPixelDistance);
            max = Math.ceil(max / perPointPixelDistance);
            if (max > maxIndex) {
                max = maxIndex;
            }
            if (max > min) {
                stepZoom(min, max);
            }
        }

        /**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
        zoom = function (event) {

            // add button to reset selection
            var lang = defaultOptions.lang,
            animate = chart.pointCount < 100;
            chart.toolbar.add('zoom', lang.resetZoom, lang.resetZoomTitle, zoomOut);

            if (chart.stepZoom && stepZoom) {
                stepZoomNormalizeEvent(event);
            }

            else {
                // if zoom is called with no arguments, reset the axes
                if (!event || event.resetSelection) {
                    each(axes, function(axis) {
                        axis.setExtremes(null, null, false, animate);
                    });
                }

                // else, zoom in on all axes
                else {
                    each(event.xAxis.concat(event.yAxis), function(axisData) {
                        var axis = axisData.axis;

                        // don't zoom more than maxZoom
                        if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
                            axis.setExtremes(axisData.min, axisData.max, false, animate);
                        }
                    });
                }

                // redraw chart
                redraw();
            }
        };

        /**
         * Show the title and subtitle of the chart
         *
         * @param titleOptions {Object} New title options
         * @param subtitleOptions {Object} New subtitle options
         *
         */
        function setTitle (titleOptions, subtitleOptions) {

            chartTitleOptions = merge(options.title, titleOptions);
            chartSubtitleOptions = merge(options.subtitle, subtitleOptions);

            // add title and subtitle
            each([
                ['title', titleOptions, chartTitleOptions],
                ['subtitle', subtitleOptions, chartSubtitleOptions]
                ], function(arr) {
                    var name = arr[0],
                    title = chart[name],
                    titleOptions = arr[1],
                    chartTitleOptions = arr[2];

                    if (title && titleOptions) {
                        title.destroy(); // remove old
                        title = null;
                    }
                    if (chartTitleOptions && chartTitleOptions.text && !title) {
                        chart[name] = renderer.text(
                            chartTitleOptions.text,
                            0,
                            0
                            )
                        .attr({
                            align: chartTitleOptions.align,
                            'class': 'highcharts-'+ name,
                            zIndex: 1
                        })
                        .css(chartTitleOptions.style)
                        .add()
                        .align(chartTitleOptions, false, spacingBox);
                    }
                });

        }

        /**
         * Get chart width and height according to options and container size
         */
        function getChartSize() {

            containerWidth = (renderToClone || renderTo).offsetWidth;
            containerHeight = (renderToClone || renderTo).offsetHeight;
            chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
            /**^
             * handle the limit of height in Highcharts
             */
            chart.chartHeight = chartHeight = optionsChart.height ||containerHeight || 400;
        // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
        //(containerHeight > 19 ? containerHeight : 400);
        /*EOP^*/
        }


        /**
         * Get the containing element, determine the size and create the inner container
         * div to hold the chart
         */
        function getContainer() {
            renderTo = optionsChart.renderTo;
            containerId = PREFIX + idCounter++;

            if (isString(renderTo)) {
                renderTo = doc.getElementById(renderTo);
            }

            // remove previous chart
            renderTo.innerHTML = '';

            // If the container doesn't have an offsetWidth, it has or is a child of a node
            // that has display:none. We need to temporarily move it out to a visible
            // state to determine the size, else the legend and tooltips won't render
            // properly
            if (!renderTo.offsetWidth) {
                renderToClone = renderTo.cloneNode(0);
                css(renderToClone, {
                    position: ABSOLUTE,
                    top: '-9999px',
                    display: ''
                });
                doc.body.appendChild(renderToClone);
            }

            // get the width and height
            getChartSize();

            // create the inner container
            chart.container = container = createElement(DIV, {
                className: 'highcharts-container' +
                (optionsChart.className ? ' '+ optionsChart.className : ''),
                id: containerId
            }, extend({
                position: RELATIVE,
                overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
                // content overflow in IE
                width: chartWidth + PX,
                height: chartHeight + PX,
                textAlign: 'left'
            }, optionsChart.style),
            renderToClone || renderTo
            );

            chart.renderer = renderer =
            optionsChart.forExport ? // force SVG, used for SVG export
            new SVGRenderer(container, chartWidth, chartHeight, true) :
            new Renderer(container, chartWidth, chartHeight);

            /**^
             * Add the lighting3d flag in the renderer for global access
             */
            renderer.lighting3D = chart.options.chart.use3DLighting;
            renderer.smartLabel = chartAPI.smartLabel;
            /* EOP ^*/

            // Issue 110 workaround:
            // In Firefox, if a div is positioned by percentage, its pixel position may land
            // between pixels. The container itself doesn't display this, but an SVG element
            // inside this container will be drawn at subpixel precision. In order to draw
            // sharp lines, this must be compensated for. This doesn't seem to work inside
            // iframes though (like in jsFiddle).
            var subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                subPixelFix = function() {
                    css(container, {
                        left: 0,
                        top: 0
                    });
                    rect = container.getBoundingClientRect();
                    css(container, {
                        left: (-(rect.left - pInt(rect.left))) + PX,
                        top: (-(rect.top - pInt(rect.top))) + PX
                    });
                };

                // run the fix now
                subPixelFix();

                // run it on resize
                addEvent(win, 'resize', subPixelFix);

                // remove it on chart destroy
                addEvent(chart, 'destroy', function() {
                    removeEvent(win, 'resize', subPixelFix);
                });
            }
        }

        /**
         * Calculate margins by rendering axis labels in a preliminary position. Title,
         * subtitle and legend have already been rendered at this stage, but will be
         * moved into their final positions
         */
        getMargins = function() {
            var legendOptions = options.legend,
            legendMargin = pick(legendOptions.margin, 10),
            legendX = legendOptions.x,
            legendY = legendOptions.y,
            align = legendOptions.align,
            verticalAlign = legendOptions.verticalAlign,
            titleOffset;

            resetMargins();

            // adjust for title and subtitle
            if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
                titleOffset = mathMax(
                    (chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0,
                    (chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0
                    );
                if (titleOffset) {
                    plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
                }
            }
            // adjust for legend
            if (legendOptions.enabled && !legendOptions.floating) {
                if (align === 'right') { // horizontal alignment handled first
                    if (!defined(optionsMarginRight)) {
                        marginRight = mathMax(
                            marginRight,
                            legendWidth - legendX + legendMargin + spacingRight
                            );
                    }
                } else if (align === 'left') {
                    if (!defined(optionsMarginLeft)) {
                        plotLeft = mathMax(
                            plotLeft,
                            legendWidth + legendX + legendMargin + spacingLeft
                            );
                    }

                } else if (verticalAlign === 'top') {
                    if (!defined(optionsMarginTop)) {
                        plotTop = mathMax(
                            plotTop,
                            legendHeight + legendY + legendMargin + spacingTop
                            );
                    }

                } else if (verticalAlign === 'bottom') {
                    if (!defined(optionsMarginBottom)) {
                        marginBottom = mathMax(
                            marginBottom,
                            legendHeight - legendY + legendMargin + spacingBottom
                            );
                    }
                }
            }

            // pre-render axes to get labels offset width
            if (hasCartesianSeries) {
                each(axes, function(axis) {
                    axis.getOffset();
                });
            }

            if (!defined(optionsMarginLeft)) {
                plotLeft += axisOffset[3];
            }
            if (!defined(optionsMarginTop)) {
                plotTop += axisOffset[0];
            }
            if (!defined(optionsMarginBottom)) {
                marginBottom += axisOffset[2];
            }
            if (!defined(optionsMarginRight)) {
                marginRight += axisOffset[1];
            }

            setChartSize();

        };

        /**
         * Add the event handlers necessary for auto resizing
         *
         */
        function initReflow() {
            var reflowTimeout;
            function reflow() {
                var width = optionsChart.width || renderTo.offsetWidth,
                height = optionsChart.height || renderTo.offsetHeight;

                if (width && height) { // means container is display:none
                    if (width !== containerWidth || height !== containerHeight) {
                        clearTimeout(reflowTimeout);
                        reflowTimeout = setTimeout(function() {
                            resize(width, height, false);
                        }, 100);
                    }
                    containerWidth = width;
                    containerHeight = height;
                }
            }
            addEvent(win, 'resize', reflow);
            addEvent(chart, 'destroy', function() {
                removeEvent(win, 'resize', reflow);
            });
        }

        /**
         * Resize the chart to a given width and height
         * @param {Number} width
         * @param {Number} height
         * @param {Object|Boolean} animation
         */
        resize = function(width, height, animation) {
            var chartTitle = chart.title,
            chartSubtitle = chart.subtitle;

            isResizing += 1;

            // set the animation for the current process
            setAnimation(animation, chart);

            oldChartHeight = chartHeight;
            oldChartWidth = chartWidth;
            chart.chartWidth = chartWidth = mathRound(width);
            chart.chartHeight = chartHeight = mathRound(height);

            css(container, {
                width: chartWidth + PX,
                height: chartHeight + PX
            });
            renderer.setSize(chartWidth, chartHeight, animation);

            // update axis lengths for more correct tick intervals:
            plotWidth = chartWidth - plotLeft - marginRight;
            plotHeight = chartHeight - plotTop - marginBottom;

            // handle axes
            maxTicks = null;
            each(axes, function(axis) {
                axis.isDirty = true;
                axis.setScale();
            });

            // make sure non-cartesian series are also handled
            each(series, function(serie) {
                serie.isDirty = true;
            });

            chart.isDirtyLegend = true; // force legend redraw
            chart.isDirtyBox = true; // force redraw of plot and chart border

            getMargins();

            // move titles
            if (chartTitle) {
                chartTitle.align(null, null, spacingBox);
            }
            if (chartSubtitle) {
                chartSubtitle.align(null, null, spacingBox);
            }

            redraw(animation);


            oldChartHeight = null;
            fireEvent(chart, 'resize');

            // fire endResize and set isResizing back
            setTimeout(function() {
                fireEvent(chart, 'endResize', null, function() {
                    isResizing -= 1;
                });
            }, (globalAnimation && globalAnimation.duration) || 500);
        };

        /**
         * Set the public chart properties. This is done before and after the pre-render
         * to determine margin sizes
         */
        setChartSize = function() {

            chart.plotLeft = plotLeft = mathRound(plotLeft);
            chart.plotTop = plotTop = mathRound(plotTop);
            chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
            chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);

            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;

            spacingBox = {
                x: spacingLeft,
                y: spacingTop,
                width: chartWidth - spacingLeft - spacingRight,
                height: chartHeight - spacingTop - spacingBottom
            };
        };

        /**
         * Initial margins before auto size margins are applied
         */
        resetMargins = function() {
            plotTop = pick(optionsMarginTop, spacingTop);
            marginRight = pick(optionsMarginRight, spacingRight);
            marginBottom = pick(optionsMarginBottom, spacingBottom);
            plotLeft = pick(optionsMarginLeft, spacingLeft);
            axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
        };

        /**
         * Draw the borders and backgrounds for chart and plot area
         */
        drawChartBox = function() {
            var chartBorderWidth = optionsChart.borderWidth || 0,
            chartBackgroundColor = optionsChart.backgroundColor,
            plotBgColor = optionsChart.plotBackgroundColor,
            plotBgImage = optionsChart.plotBackgroundImage,

            /**^
             * Variable like plotBackgroundImage and Logo image for bg image
             */
            bgSWF = optionsChart.bgSWF,
            bgSWFAlpha = optionsChart.bgSWFAlpha / 100,
            bgImageDisplayMode = optionsChart.bgImageDisplayMode,
            bgImageVAlign = optionsChart.bgImageVAlign,
            bgImageHAlign = optionsChart.bgImageHAlign,
            bgImageScale = optionsChart.bgImageScale,

            logoURL = optionsChart.logoURL,
            logoAlpha = optionsChart.logoAlpha / 100,
            logoPosition = optionsChart.logoPosition,
            logoLink = optionsChart.logoLink,
            logoScale = optionsChart.logoScale,
            logoLeftMargin = optionsChart.logoLeftMargin,
            logoTopMargin = optionsChart.logoTopMargin,
            /* EOP ^*/
            // Chart area

            mgn,
            plotSize = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };
            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

            if (chartBorderWidth || chartBackgroundColor) {
                if (!chartBackground) {
                    chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
                        optionsChart.borderRadius, chartBorderWidth)
                    .attr({
                        stroke: optionsChart.borderColor,
                        'stroke-width': chartBorderWidth,
                        fill: chartBackgroundColor || NONE
                    })
                    .add()
                    .shadow(optionsChart.shadow);
                } else { // resize
                    chartBackground.animate(
                        chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
                        );
                }
            }

            /**^
    	     * Code for drawing bg image
 	         * (src, x, y, width, height)
             */
            var imgClipRect = renderer.clipRect(chartBorderWidth, chartBorderWidth,
                chartWidth - chartBorderWidth * 2,
                chartHeight - chartBorderWidth * 2);

            if (bgSWF && !chartBGImage) {
                var referenceImage = new Image(),
                bgImageAttr,
                xRepeatCount = 1,
                yRepeatCount = 1,
                yCount,
                counter,
                imgY;

                if (!chartBGImageGroup) {
                    chartBGImageGroup = renderer.g('group').attr({
                        visibility: HIDDEN
                    })
                    .clip(imgClipRect)
                    .add();
                }
                referenceImage.onload = function () {
                    bgImageAttr = setImageDisplayMode(bgImageDisplayMode,
                        bgImageVAlign, bgImageHAlign,
                        bgImageScale, chartBorderWidth, chartWidth, chartHeight, referenceImage);

                    chartBGImage = [];
                    if (bgImageAttr.tileInfo) {
                        xRepeatCount = bgImageAttr.tileInfo.xCount;
                        yRepeatCount = yCount = bgImageAttr.tileInfo.yCount;
                        imgY = bgImageAttr.y;

                        delete bgImageAttr.tileInfo;

                        for (; xRepeatCount; yCount -= 1) {
                            if (yCount == 0) {
                                yCount = yRepeatCount;
                                xRepeatCount -= 1;
                                bgImageAttr.x += bgImageAttr.width;
                                bgImageAttr.y = imgY;
                            }

                            chartBGImage[counter] = renderer.image(bgSWF)
                            .attr(bgImageAttr)
                            .css({
                                opacity : bgSWFAlpha
                            })
                            .add(chartBGImageGroup.attr({
                                visibility: VISIBLE
                            }));

                            bgImageAttr.y += bgImageAttr.height;
                        }

                    } else {
                        chartBGImage[0] = renderer.image(bgSWF)
                        .attr(bgImageAttr)
                        .css({
                            opacity : bgSWFAlpha
                        })
                        .add(chartBGImageGroup.attr({
                            visibility: VISIBLE
                        }));
                    }
                };
                referenceImage.src = bgSWF;
            }

            /* EOP ^*/

            // Plot background
            if (plotBgColor) {
                if (!plotBackground) {
                    /**^
                     * Introduced the plotBorderRadius attr
                     */
                    plotBackground = renderer.rect(plotLeft, plotTop,
                        plotWidth, plotHeight,
                        pluckNumber(optionsChart.plotBorderRadius, 0))
                    /* EOP ^*/
                    .attr({
                        fill: plotBgColor
                    })
                    .add()
                    /**^
                     * added plotShadow as object to pass options.
                     */
                    .shadow(optionsChart.plotShadow, undefined, optionsChart.plotShadow);
                    /* EOP ^*/
                } else {
                    plotBackground.animate(plotSize);
                }
            }
            if (plotBgImage) {
                if (!plotBGImage) {
                    plotBGImage = renderer.image(plotBgImage, plotLeft, plotTop, plotWidth, plotHeight)
                    .add();
                }else {
                    plotBGImage.animate(plotSize);
                }
            }

            // Plot area border
            if (optionsChart.plotBorderWidth) {
                /**^
                 * Introduced the plotBorderRadius attr.
                 * Added compensation for plotborder thickness.
                 */
                var pbw = optionsChart.plotBorderWidth,
                pbwComp = pbw * 0.5,
                pbSize = {
                    x: plotLeft - pbwComp,
                    y: plotTop - pbwComp,
                    width: plotWidth + pbw,
                    height: plotHeight + pbw,
                    r: pluckNumber(optionsChart.plotBorderRadius, 0)
                };

                if (!plotBorder) {
                    plotBorder = renderer.rect(pbSize.x, pbSize.y, pbSize.width,
                        pbSize.height, pbSize.r, pbw)
                    .attr({
                        stroke: optionsChart.plotBorderColor,
                        'stroke-width': pbw,
                        'stroke-linejoin': 'round', // to make curved stroke
                        zIndex: 2 // modified to push it below data-plot
                    })
                    .add();
                } else {
                    plotBorder.animate(
                        plotBorder.crisp(null, pbSize.x, pbSize.y, pbSize.width, pbSize.height)
                        );
                }
            /* EOP ^*/
            }

            /**^
             * logoURL.
             */

            if (logoURL && !chartLogoImage) {
                var
                logoReferenceImage = new Image(),
                logoImageAttr,
                logoImageVAlign,
                logoImageHAlign,
                logoTracker;

                switch (logoPosition) {
                    case 'tr' :
                        logoImageVAlign = POSITION_TOP;
                        logoImageHAlign = POSITION_RIGHT;
                        break;
                    case 'bl' :
                        logoImageVAlign = POSITION_BOTTOM;
                        logoImageHAlign = POSITION_LEFT;
                        break;
                    case 'br' :
                        logoImageVAlign = POSITION_BOTTOM;
                        logoImageHAlign = POSITION_RIGHT;
                        break;
                    case 'cc' :
                        logoImageVAlign = POSITION_MIDDLE;
                        logoImageHAlign = POSITION_MIDDLE;
                        break;
                    default : // 'tl' :
                        logoImageVAlign = POSITION_TOP;
                        logoImageHAlign = POSITION_LEFT;
                        break;
                }

                if (!chartLogoImageGroup) {
                    chartLogoImageGroup = renderer.g('group').attr({
                        visibility: HIDDEN,
                        zIndex:  7 // just below credit label
                    })
                    .clip(imgClipRect)
                    .add();
                }
                if (logoLink) {
                    logoTracker = renderer.rect(0,0,1,1,0)
                    .attr({
                        isTracker: true,
                        stroke: TRACKER_FILL,
                        fill: TRACKER_FILL,
                        'stroke-width' : 0,
                        visibility: VISIBLE,
                        zIndex: 10
                    })
                    .css({
                        cursor: 'pointer',
                        '_cursor' : 'hand'
                    })
                    .on('mouseover', function () {
                        if (chart.tooltip) {
                            chart.tooltip.hide();
                        }
                    })
                    .on ('click', function () {
                        optionsChart.events.click.call({
                            link : logoLink
                        });
                    })
                    .add();
                }
                logoReferenceImage.onload = function () {
                    logoImageAttr = setImageDisplayMode('none',
                        logoImageVAlign, logoImageHAlign,
                        logoScale, chartBorderWidth, chartWidth, chartHeight, logoReferenceImage);

                    chartLogoImage = renderer.image(logoURL)
                    .attr(logoImageAttr)
                    .translate(logoLeftMargin, logoTopMargin)
                    .css({
                        opacity : logoAlpha
                    })
                    .add(chartLogoImageGroup.attr({
                        visibility: VISIBLE
                    }));

                    if (logoLink) {
                        logoImageAttr.r = 0;
                        logoTracker.attr(logoImageAttr);

                    }

                };
                logoReferenceImage.src = logoURL;
            }
            /* EOP ^*/


            // reset
            chart.isDirtyBox = false;
        };

        /**^
         * Function that will draw the canvas base and the canvas bg 3d effect for 3d chart
         * *
         * this function will draw the 3d base element
         */
        function draw3DBase () {
            var chart = this,
            canvasBaseColor3D = chart.options.chart.canvasBaseColor3D,
            canvasBaseDepth = chart.options.chart.canvasBaseDepth,
            canvasBgDepth = chart.options.chart.canvasBgDepth,
            canvasBgColor = chart.options.chart.canvasBgColor,
            renderer = chart.renderer,
            defaultSeries = chart.options.chart.defaultSeriesType ,
            xDepth = chart.xDepth, yDepth = chart.yDepth;
            if (chart.options.chart.showCanvasBase) {
                if (defaultSeries === 'bar3d') {
                    chart.base3D = renderer.rect3d(chart.plotLeft - xDepth - canvasBaseDepth, chart.plotTop + yDepth,
                        canvasBaseDepth, chart.plotHeight, xDepth, yDepth, 0, 'canvasBase3D');
                }
                else {
                    chart.base3D = renderer.rect3d(chart.plotLeft - xDepth, chart.plotTop + chart.plotHeight + yDepth,
                        chart.plotWidth, canvasBaseDepth, xDepth, yDepth, 0, 'canvasBase3D');
                }

                chart.base3D.attr({
                    fill : canvasBaseColor3D,
                    lighting3D : chart.options.chart.use3DLighting
                }).add();
            }

            //draw the canvas right 3D effect
            if (chart.options.chart.showCanvasBg) {
                if (defaultSeries === 'bar3d') {
                    plotBackground.depth3D = renderer.path(['M', chart.plotLeft, chart.plotTop,
                        'L', chart.plotLeft + (canvasBgDepth * 1.2), chart.plotTop - canvasBgDepth,
                        chart.plotLeft + chart.plotWidth - canvasBgDepth, chart.plotTop - canvasBgDepth,
                        chart.plotLeft + chart.plotWidth, chart.plotTop, 'Z'
                        ]).attr({
                        fill : canvasBgColor
                    }).add();
                }
                else {
                    plotBackground.depth3D = renderer.path(['M', chart.plotLeft + chart.plotWidth, chart.plotTop,
                        'L', chart.plotLeft + chart.plotWidth + canvasBgDepth, chart.plotTop + (canvasBgDepth * 1.2),
                        chart.plotLeft + chart.plotWidth + canvasBgDepth, chart.plotTop + chart.plotHeight - canvasBgDepth,
                        chart.plotLeft + chart.plotWidth, chart.plotTop + chart.plotHeight, 'Z'
                        ]).attr({
                        fill : canvasBgColor
                    }).add();
                }
            }

        }
        /* EOP ^*/

        /**
         * Render all graphics for the chart
         */
        function render () {
            var labels = options.labels,
            credits = options.credits,
            creditsHref,
            /**^
             * Add global variables
             */
            series3D = {},
            seriesType;
            /* EOP ^*/

            // Title
            setTitle();


            // Legend
            legend = chart.legend = new Legend(chart);

            // Get margins by pre-rendering axes
            getMargins();
            each(axes, function(axis) {
                axis.setTickPositions(true); // update to reflect the new margins
            });
            adjustTickAmounts();
            getMargins(); // second pass to check for new labels


            // Draw the borders and backgrounds
            drawChartBox();

            // Axes
            if (hasCartesianSeries) {
                each(axes, function(axis) {
                    axis.render();
                });
            }


            // The series
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g('series-group')
                .attr({
                    zIndex: 3
                })
                .add();
            }
            /**^
             * For 3d chart draw the canvas base and the canvas bg depth
             * also draw series shadow
             */
            each(series, function(serie) {
                serie.translate();
                serie.setTooltipPoints();

                // create array for every series type then render them as per their renduring rule
                if(options.chart.is3D) {
                    seriesType = serie.type;
                    if (!series3D[seriesType]) {
                        series3D[seriesType] = [];
                    }
                    series3D[seriesType].push(serie);
                }
                else {
                    serie.render();
                }
            });

            if (options.chart.is3D) {
                chart.xDepth = pluckNumber(options.chart.xDepth, 10);
                chart.yDepth = pluckNumber(options.chart.yDepth, 10);
                draw3DBase.call(chart);

                // get the 3d series name ordered as per drawing,
                // also count the No. of 3D series type on z axis
                zOrderSetter(chart, series3D)

            // add the no of 2d series type.
            // avaiable Z-axis will de eqally devided among them
            //chart.num3dSeriesType = num3dSeries;
            }


            // Labels
            //change to add text alignment
            //vAlignment works if the first line above issue fixed manualy by y
            if (labels.items) {
                each(labels.items, function() {
                    var style = extend(labels.style, this.style),
                    x = pInt(style.left) + plotLeft,
                    y = pInt(style.top) + plotTop;

                    // delete to prevent rewriting in IE
                    delete style.left;
                    delete style.top;

                    var text = renderer.text(
                        this.html,
                        x,
                        y
                        )
                    .attr({
                        zIndex: pluckNumber(this.zIndex, 2),
                        align : pluck(this.textAlign, 'left')
                    })
                    .css(style)
                    .add();
                    if (this.vAlign === 'bottom') {
                        text.attr({
                            y : y - text.getBBox().height
                        })
                    }
                    if (this.vAlign === 'middle') {
                        text.attr({
                            y : y - (text.getBBox().height / 2)
                        })
                    }

                });
            }
            /* EOP ^*/
            // Toolbar (don't redraw)
            if (!chart.toolbar) {
                chart.toolbar = Toolbar(chart);
            }

            // Credits
            if (credits.enabled && !chart.credits) {
                creditsHref = credits.href;
                renderer.text(
                    credits.text,
                    0,
                    0
                    )
                .on('click', function() {
                    if (creditsHref) {
                        location.href = creditsHref;
                    }
                })
                .attr({
                    align: credits.position.align,
                    zIndex: 8
                })
                .css(credits.style)
                .add()
                .align(credits.position);
            }

            placeTrackerGroup();

            /**^
             * Draw sub-charts
             */
            
            if (options.subCharts && options.subCharts.length && !renderer.forExport) {

                chart.subCharts = [];
                each(options.subCharts, function (subOptions) {

                    var subChart,
                    optionsChart = subOptions.chart,
                    subContainer = optionsChart.renderTo =
                    createElement(DIV, null, {
                        position: 'relative',
                        background: 'transparent',
                        left: optionsChart.left + PX,
                        top: (isIE && !hasSVG ? optionsChart.top :
                            (optionsChart.top - chartHeight)) + PX,
                        width: optionsChart.width + PX,
                        height: optionsChart.height + PX
                    }, container);

                    extend(subOptions, {
                        instanceAPI: options.instanceAPI
                    });

                    chart.subCharts.push(new Chart(subOptions));
                });
            }
            /* EOP ^*/

            // Set flag
            chart.hasRendered = true;

            // If the chart was rendered outside the top container, put it back in
            if (renderToClone) {
                renderTo.appendChild(container);
                discardElement(renderToClone);
            //updatePosition(container);
            }
        }

        /**
         * Clean up memory usage
         */
        function destroy() {
            var i = series.length,
            parentNode = container && container.parentNode;


            /**^
             * Destroy sub-charts
             */
            if (chart.subCharts && chart.subCharts.length) {
                each(chart.subCharts, function (subChart, index) {
                    subChart.destroy && subChart.destroy();
                });
            }
            /* EOP ^*/

            // fire the chart.destoy event
            fireEvent(chart, 'destroy');

            // remove events
            removeEvent(win, 'unload', destroy);
            removeEvent(chart);

            each(axes, function(axis) {
                removeEvent(axis);
            });

            // destroy each series
            while (i--) {
                series[i].destroy();
            }

            // remove container and all SVG
            if (container) { // can break in IE when destroyed before finished loading
                container.innerHTML = '';
                removeEvent(container);
                if (parentNode) {
                    parentNode.removeChild(container);
                }

                // IE6 leak
                container =	null;
            }

            // IE7 leak
            if (renderer) { // can break in IE when destroyed before finished loading
                renderer.alignedObjects = null;
            }

            // memory and CPU leak
            clearInterval(tooltipInterval);

            // clean it all up
            for (i in chart) {
                delete chart[i];
            }

        }
        /**
         * Prepare for first rendering after all data are loaded
         */
        function firstRender() {

            // VML namespaces can't be added until after complete. Listening
            // for Perini's doScroll hack is not enough.
            var ONREADYSTATECHANGE = 'onreadystatechange',
            COMPLETE = 'complete';
            // Note: in spite of JSLint's complaints, win == win.top is required
            if (!hasSVG && win == win.top && doc.readyState !== COMPLETE) {
                doc.attachEvent(ONREADYSTATECHANGE, function() {
                    doc.detachEvent(ONREADYSTATECHANGE, firstRender);
                    if (doc.readyState === COMPLETE) {
                        firstRender();
                    }
                });
                return;
            }

            /**^
             * Set current instance of Highcharts inside chartAPI
             */
            chartAPI.hcInstance = chart;
            /* EOP ^*/

            // create the container
            getContainer();

            resetMargins();
            setChartSize();

            // Initialize the series
            each(options.series || [], function(serieOptions) {
                initSeries(serieOptions);
            });

            // Set the common inversion and transformation for inverted series after initSeries
            chart.inverted = inverted = pick(inverted, options.chart.inverted);


            getAxes();


            chart.render = render;

            // depends on inverted and on margins being set
            chart.tracker = tracker = new MouseTracker(chart, options.tooltip);

            //globalAnimation = false;
            render();

            /*^
             */
            global.raiseEvent('internal.hc.rendered', chartAPI, chartAPI.chartInstance)
            /* EOP ^*/
            fireEvent(chart, 'load');

            //globalAnimation = true;

            // run callbacks
            if (callback) {
                callback.apply(chart, [chart]);
            }
            each(chart.callbacks, function(fn) {
                fn.apply(chart, [chart]);
            });
        }

        // Run chart


        // Destroy the chart and free up memory.
        addEvent(win, 'unload', destroy);

        // Set up auto resize
        if (optionsChart.reflow !== false) {
            addEvent(chart, 'load', initReflow);
        }

        // Chart event handlers
        if (chartEvents) {
            for (eventType in chartEvents) {
                addEvent(chart, eventType, chartEvents[eventType]);
            }
        }


        chart.options = options;
        chart.series = series;





        // Expose methods and variables
        chart.addSeries = addSeries;
        chart.animation = pick(optionsChart.animation, true);
        chart.destroy = destroy;
        chart.get = get;
        chart.getSelectedPoints = getSelectedPoints;
        chart.getSelectedSeries = getSelectedSeries;
        chart.hideLoading = hideLoading;
        chart.isInsidePlot = isInsidePlot;
        chart.redraw = redraw;
        chart.setSize = resize;
        chart.setTitle = setTitle;
        chart.showLoading = showLoading;
        chart.pointCount = 0;
        chart.counters = new ChartCounters();
        /*
	if ($) $(function() {
		$container = $('#container');
		var origChartWidth,
			origChartHeight;
		if ($container) {
			$('<button>+</button>')
				.insertBefore($container)
				.click(function() {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
				});
			$('<button>-</button>')
				.insertBefore($container)
				.click(function() {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
				});
			$('<button>1:1</button>')
				.insertBefore($container)
				.click(function() {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(origChartWidth, origChartHeight);
				});
		}
	})
	*/




        firstRender();


    } // end Chart

    // Hook for exporting module
    Chart.prototype.callbacks = [];
    /**
     * The Point object and prototype. Inheritable and used as base for PiePoint
     */
    var Point = function() {};
    Point.prototype = {

        /**
         * Initialize the point
         * @param {Object} series The series object containing this point
         * @param {Object} options The data in either number, array or object format
         */
        init: function(series, options) {
            var point = this,
            counters = series.chart.counters,
            defaultColors;
            point.series = series;
            point.applyOptions(options);
            point.pointAttr = {};

            if (series.options.colorByPoint) {
                defaultColors = series.chart.options.colors;
                if (!point.options) {
                    point.options = {};
                }
                point.color = point.options.color = point.color || defaultColors[counters.color++];

                // loop back to zero
                counters.wrapColor(defaultColors.length);
            }

            series.chart.pointCount++;
            return point;
        },
        /**
         * Apply the options containing the x and y data and possible some extra properties.
         * This is called on point init or from point.update.
         *
         * @param {Object} options
         */
        applyOptions: function(options) {
            var point = this,
            series = point.series;

            point.config = options;

            // onedimensional array input
            if (isNumber(options) || options === null) {
                point.y = options;
            }

            // object input
            else if (isObject(options) && !isNumber(options.length)) {

                // copy options directly to point
                extend(point, options);
                point.options = options;
            }

            // categorized data with name in first position
            else if (isString(options[0])) {
                point.name = options[0];
                point.y = options[1];
            }

            // two-dimentional array
            else if (isNumber(options[0])) {
                point.x = options[0];
                point.y = options[1];
            }

            /*
			 * If no x is set by now, get auto incremented value. All points must have an
			 * x value, however the y value can be null to create a gap in the series
			 */
            if (point.x === UNDEFINED) {
                point.x = series.autoIncrement();
            }

        },

        /**
         * Destroy a point to clear memory. Its reference still stays in series.data.
         */
        destroy: function() {
            var point = this,
            series = point.series,
            prop;

            series.chart.pointCount--;

            if (point === series.chart.hoverPoint) {
                point.onMouseOut();
            }
            series.chart.hoverPoints = null; // remove reference

            // remove all events
            removeEvent(point);

            each(['graphic', 'tracker', 'group', 'dataLabel', 'connector'], function(prop) {
                if (point[prop]) {
                    point[prop].destroy();
                }
            });

            if (point.legendItem) { // pies have legend items
                point.series.chart.legend.destroyItem(point);
            }

            for (prop in point) {
                point[prop] = null;
            }


        },

        /**
         * Return the configuration hash needed for the data label and tooltip formatters
         */
        getLabelConfig: function() {
            var point = this;
            return {
                x: point.category,
                y: point.y,
                series: point.series,
                point: point,
                percentage: point.percentage,
                total: point.total || point.stackTotal
            };
        },

    /**
     * Toggle the selection status of a point
     * @param {Boolean} selected Whether to select or unselect the point.
     * @param {Boolean} accumulate Whether to add to the previous selection. By default,
     *     this happens if the control key (Cmd on Mac) was pressed during clicking.
     */
        select: function(selected, accumulate) {
            var point = this,
            series = point.series,
            chart = series.chart;

            point.selected = selected = pick(selected, !point.selected);

            //series.isDirty = true;
            point.firePointEvent(selected ? 'select' : 'unselect');
            point.setState(selected && SELECT_STATE);

            // unselect all other points unless Ctrl or Cmd + click
            if (!accumulate) {
                each(chart.getSelectedPoints(), function (loopPoint) {
                    if (loopPoint.selected && loopPoint !== point) {
                        loopPoint.selected = false;
                        loopPoint.setState(NORMAL_STATE);
                        loopPoint.firePointEvent('unselect');
                    }
                });
            }

        },

        onMouseOver: function() {
            var point = this,
            chart = point.series.chart,
            tooltip = chart.tooltip,
            hoverPoint = chart.hoverPoint;

            // set normal state to previous series
            if (hoverPoint && hoverPoint !== point) {
                hoverPoint.onMouseOut();
            }

            // trigger the event
            point.firePointEvent('mouseOver');

            // update the tooltip
            if (tooltip && !tooltip.shared) {
                tooltip.refresh(point);
            }

            /**^
             * Add the tracker css cursor to pointer if it has a link
             */
            if (point.link !== undefined && point.series.tracker) {
                point.series.tracker.css({
                    cursor : 'pointer'
                });
            }
            /* EOP ^*/

            // hover this
            point.setState(HOVER_STATE);
            chart.hoverPoint = point;
        },

        onMouseOut: function() {
            var point = this;
            point.firePointEvent('mouseOut');

            point.setState();
            point.series.chart.hoverPoint = null;

            /**^
             * Remove the traker css cursor to pointer if there has a link
             */
            if (point.link !== undefined && point.series.tracker) {
                point.series.tracker.css({
                    cursor : 'auto'
                });
            }
        /* EOP ^*/
        },

        /**
         * Extendable method for formatting each point's tooltip line
         *
         * @param {Boolean} useHeader Whether a common header is used for multiple series in the tooltip
         *
         * @return {String} A string to be concatenated in to the common tooltip text
         */
        tooltipFormatter: function(useHeader) {
            var point = this,
            series = point.series;

            return ['<span style="color:'+ series.color +'">', (point.name || series.name), '</span>: ',
            (!useHeader ? ('<b>x = '+ (point.name || point.x) + ',</b> ') : ''),
            '<b>', (!useHeader ? 'y = ' : '' ), point.y, '</b>'].join('');

        },

        /**
         * Update the point with new options (typically x/y data) and optionally redraw the series.
         *
         * @param {Object} options Point options as defined in the series.data array
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         *
         */
        update: function(options, redraw, animation) {
            var point = this,
            series = point.series,
            dataLabel = point.dataLabel,
            graphic = point.graphic,
            chart = series.chart;

            redraw = pick(redraw, true);

            // fire the event with a default handler of doing the update
            point.firePointEvent('update', {
                options: options
            }, function() {

                point.applyOptions(options);

                // update visuals
                if (isObject(options)) {
                    series.getAttribs();
                    if (graphic) {
                        graphic.attr(point.pointAttr[series.state]);
                    }
                }

                // redraw
                series.isDirty = true;
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },

        /**
         * Remove a point and optionally redraw the series and if necessary the axes
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        remove: function(redraw, animation) {
            var point = this,
            series = point.series,
            chart = series.chart,
            data = series.data;

            setAnimation(animation, chart);
            redraw = pick(redraw, true);

            // fire the event with a default handler of removing the point
            point.firePointEvent('remove', null, function() {

                erase(data, point);

                point.destroy();


                // redraw
                series.isDirty = true;
                if (redraw) {
                    chart.redraw();
                }
            });


        },

        /**
         * Fire an event on the Point object. Must not be renamed to fireEvent, as this
         * causes a name clash in MooTools
         * @param {String} eventType
         * @param {Object} eventArgs Additional event arguments
         * @param {Function} defaultFunction Default event handler
         */
        firePointEvent: function(eventType, eventArgs, defaultFunction) {
            var point = this,
            series = this.series,
            seriesOptions = series.options;

            // load event handlers on demand to save time on mouseover/out
            if (seriesOptions.point.events[eventType] || (
                point.options && point.options.events && point.options.events[eventType])) {
                this.importEvents();
            }

            // add default handler if in selection mode
            if (eventType === 'click' && seriesOptions.allowPointSelect) {
                defaultFunction = function (event) {
                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                };
            }

            fireEvent(this, eventType, eventArgs, defaultFunction);
        },
        /**
         * Import events from the series' and point's options. Only do it on
         * demand, to save processing time on hovering.
         */
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var point = this,
                options = merge(point.series.options.point, point.options),
                events = options.events,
                eventType;

                point.events = events;

                for (eventType in events) {
                    addEvent(point, eventType, events[eventType]);
                }
                this.hasImportedEvents = true;

            }
        },

        /**
         * Set the point's state
         * @param {String} state
         */
        setState: function(state) {
            var point = this,
            series = point.series,
            stateOptions = series.options.states,
            markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
            normalDisabled = markerOptions && !markerOptions.enabled,
            markerStateOptions = markerOptions && markerOptions.states[state],
            stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
            stateMarkerGraphic = series.stateMarkerGraphic,
            chart = series.chart,
            pointAttr = point.pointAttr;

            state = state || NORMAL_STATE; // empty string

            if (
                // already has this state
                state === point.state ||
                // selected points don't respond to hover
                (point.selected && state !== SELECT_STATE) ||
                // series' state options is disabled
                (stateOptions[state] && stateOptions[state].enabled === false) ||
                // point marker's state options is disabled
                (state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))

                ) {
                return;
            }

            // apply hover styles to the existing point
            if (point.graphic) {
                point.graphic.attr(pointAttr[state]);
            }
            // if a graphic is not applied to each point in the normal state, create a shared
            // graphic for the hover state
            else {
                if (state) {
                    if (!stateMarkerGraphic) {
                        series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.circle(
                            0, 0, pointAttr[state].r
                            )
                        .attr(pointAttr[state])
                        .add(series.group);
                    }

                    stateMarkerGraphic.translate(
                        point.plotX,
                        point.plotY
                        );
                }

                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state ? 'show' : 'hide']();
                }
            }

            point.state = state;
        }
    };

    /**
     * The base function which all other series types inherit from
     * @param {Object} chart
     * @param {Object} options
     */
    var Series = function() {};

    Series.prototype = {

        isCartesian: true,
        type: 'line',
        pointClass: Point,
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'lineColor',
            'stroke-width': 'lineWidth',
            fill: 'fillColor',
            r: 'radius'
        },
        init: function(chart, options) {
            var series = this,
            eventType,
            events,
            //pointEvent,
            index = chart.series.length;

            series.chart = chart;
            options = series.setOptions(options); // merge with plotOptions

            // set some variables
            extend(series, {
                index: index,
                options: options,
                /**^
                 * Stop the default series 1 like name
                 */
                name: pluck(options.name) === undefined ? '' : options.name,
                /* EOP ^*/
                state: NORMAL_STATE,
                pointAttr: {},
                visible: options.visible !== false, // true by default
                selected: options.selected === true // false by default
            });

            // register event listeners
            events = options.events;
            for (eventType in events) {
                addEvent(series, eventType, events[eventType]);
            }
            if (
                (events && events.click) ||
                (options.point && options.point.events && options.point.events.click) ||
                options.allowPointSelect
                ) {
                chart.runTrackerClick = true;
            }
            series.getColor();
            series.getSymbol();


            // set the data
            series.setData(options.data, false);

        },


        /**
         * Return an auto incremented x value based on the pointStart and pointInterval options.
         * This is only used if an x value is not given for the point that calls autoIncrement.
         */
        autoIncrement: function() {
            var series = this,
            options = series.options,
            xIncrement = series.xIncrement;

            xIncrement = pick(xIncrement, options.pointStart, 0);

            series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

            series.xIncrement = xIncrement + series.pointInterval;
            return xIncrement;
        },

        /**
         * Sort the data and remove duplicates
         */
        cleanData: function() {
            var series = this,
            chart = series.chart,
            data = series.data,
            closestPoints,
            smallestInterval,
            chartSmallestInterval = chart.smallestInterval,
            interval,
            i;

            // sort the data points
            data.sort(function(a, b){
                return (a.x - b.x);
            });

            // remove points with equal x values
            // record the closest distance for calculation of column widths
            /*for (i = data.length - 1; i >= 0; i--) {
			if (data[i - 1]) {
				if (data[i - 1].x == data[i].x)	{
					data[i - 1].destroy();
					data.splice(i - 1, 1); // remove the duplicate
				}
			}
		}*/

            // connect nulls
            if (series.options.connectNulls) {
                for (i = data.length - 1; i >= 0; i--) {
                    if (data[i].y === null && data[i - 1] && data[i + 1]) {
                        data.splice(i, 1);
                    }
                }
            }

            // find the closes pair of points
            for (i = data.length - 1; i >= 0; i--) {
                if (data[i - 1]) {
                    interval = data[i].x - data[i - 1].x;
                    if (interval > 0 && (smallestInterval === UNDEFINED || interval < smallestInterval)) {
                        smallestInterval = interval;
                        closestPoints = i;
                    }
                }
            }

            if (chartSmallestInterval === UNDEFINED || smallestInterval < chartSmallestInterval) {
                chart.smallestInterval = smallestInterval;
            }
            series.closestPoints = closestPoints;
        },

        /**
         * Divide the series data into segments divided by null values. Also sort
         * the data points and delete duplicate values.
         */
        getSegments: function() {
            var lastNull = -1,
            segments = [],
            data = this.data;

            /**^
             * Connect null data support
             */
            var connectNullData = this.options.connectNullData;
            if (connectNullData) {
                // create the segments
                each (data, function(point, i) {
                    
                    // while it is a null value in data
                    // fix the following condition if its a null value
                    // fix has to be done in merge function
                    //if (point.y === null) {
                    if (typeof point.y == 'number') {
                        segments.push(data[i]);
                    }
                });
                segments = [segments];
            }
            else {
                // create the segments
                each(data, function(point, i) {
                    
                    // while it is a null value in data
                    // fix the following condition if its a null value
                    // fix has to be done in merge function
                    //if (point.y === null) {
                    if (typeof point.y != 'number') {
                        if (i > lastNull + 1) {
                            segments.push(data.slice(lastNull + 1, i));
                        }
                        lastNull = i;
                    }else if (i == data.length - 1) { // last value
                        segments.push(data.slice(lastNull + 1, i + 1));
                    }
                });
            }
            /* EOP ^*/

            this.segments = segments;


        },
        /**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
        setOptions: function(itemOptions) {
            var plotOptions = this.chart.options.plotOptions,
            options = merge(
                plotOptions[this.type],
                plotOptions.series,
                itemOptions
                );

            return options;

        },
        /**
	 * Get the series' color
	 */
        getColor: function(){
            var defaultColors = this.chart.options.colors,
            counters = this.chart.counters;
            this.color = this.options.color || defaultColors[counters.color++] || '#0000ff';
            counters.wrapColor(defaultColors.length);
        },
        /**
	 * Get the series' symbol
	 */
        getSymbol: function(){
            var defaultSymbols = this.chart.options.symbols,
            counters = this.chart.counters;
            this.symbol = this.options.marker.symbol || defaultSymbols[counters.symbol++];
            counters.wrapSymbol(defaultSymbols.length);
        },

        /**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
        addPoint: function(options, redraw, shift, animation) {
            var series = this,
            data = series.data,
            graph = series.graph,
            area = series.area,
            chart = series.chart,
            point = (new series.pointClass()).init(series, options);

            setAnimation(animation, chart);

            if (graph && shift) { // make graph animate sideways
                graph.shift = shift;
            }
            if (area) {
                area.shift = shift;
                area.isArea = true;
            }

            redraw = pick(redraw, true);

            data.push(point);
            if (shift) {
                data[0].remove(false);
            }
            series.getAttribs();


            // redraw
            series.isDirty = true;
            if (redraw) {
                chart.redraw();
            }
        },

        /**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
        setData: function(data, redraw) {
            var series = this,
            oldData = series.data,
            initialColor = series.initialColor,
            chart = series.chart,
            i = (oldData && oldData.length) || 0;

            series.xIncrement = null; // reset for new data
            if (defined(initialColor)) { // reset colors for pie
                chart.counters.color = initialColor;
            }

            data = map(splat(data || []), function(pointOptions) {
                return (new series.pointClass()).init(series, pointOptions);
            });

            // destroy old points
            while (i--) {
                oldData[i].destroy();
            }

            // set the data
            series.data = data;

            series.cleanData();
            series.getSegments();


            // cache attributes for shapes
            series.getAttribs();

            // redraw
            series.isDirty = true;
            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        },

        /**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

        remove: function(redraw, animation) {
            var series = this,
            chart = series.chart;
            redraw = pick(redraw, true);

            if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
                series.isRemoving = true;

                // fire the event with a default handler of removing the point
                fireEvent(series, 'remove', null, function() {


                    // destroy elements
                    series.destroy();


                    // redraw
                    chart.isDirtyLegend = chart.isDirtyBox = true;
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });

            }
            series.isRemoving = false;
        },

        /**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
        translate: function() {
            var series = this,
            chart = series.chart,
            stacking = series.options.stacking,
            categories = series.xAxis.categories,
            yAxis = series.yAxis,
            data = series.data,
            i = data.length;

            // do the translation
            while (i--) {
                var point = data[i],
                xValue = point.x,
                yValue = point.y,
                yBottom = point.low,
                stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
                pointStack,
                pointStackTotal;
                point.plotX = series.xAxis.translate(xValue);

                // calculate the bottom y value for stacked series
                /**^
                 * Removed visibility check of series while calculation
                 *
                 * @code
                 * if (stacking && series.visible && stack && stack[xValue]) {

                 */
                if (stacking && stack && stack[xValue]) {
                    /* EOP ^*/
                    pointStack = stack[xValue];
                    pointStackTotal = pointStack.total;
                    /**^
                     * @source 10098/2.1.4
                     * @code
                     * pointStack.cum = yBottom = pointStack.cum - yValue;
                     */
                    var min = yAxis.options.min;
                    yBottom = pointStack.cum;
                    pointStack.cum +=  yValue; // start from buttom
                    yValue = mathMax(min, yBottom + yValue);
                    yBottom = mathMax(min, yBottom);
                    /* EOP 10098/2.1.4 ^*/

                    if (stacking === 'percent') {
                        yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
                        yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
                    }

                    point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
                    point.stackTotal = pointStackTotal;
                }

                if (defined(yBottom)) {
                    point.yBottom = yAxis.translate(yBottom, 0, 1, 0, 1);
                }

                // set the y value
                if (yValue !== null) {
                    point.plotY = yAxis.translate(yValue, 0, 1, 0, 1);
                }

                // set client related positions for mouse tracking
                point.clientX = chart.inverted ?
                chart.plotHeight - point.plotX :
                point.plotX; // for mouse tracking

                // some API data
                point.category = categories && categories[point.x] !== UNDEFINED ?
                categories[point.x] : point.x;

            }
        },
        /**
	 * Memorize tooltip texts and positions
	 */
        setTooltipPoints: function (renew) {
            var series = this,
            chart = series.chart,
            inverted = chart.inverted,
            data = [],
            plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
            low,
            high,
            tooltipPoints = []; // a lookup array for each pixel in the x dimension

            // renew
            if (renew) {
                series.tooltipPoints = null;
            }

            // concat segments to overcome null values
            each(series.segments, function(segment){
                data = data.concat(segment);
            });

            // loop the concatenated data and apply each point to all the closest
            // pixel positions
            if (series.xAxis && series.xAxis.reversed) {
                data = data.reverse();//reverseArray(data);
            }

            each(data, function(point, i) {

                low = data[i - 1] ? data[i - 1]._high + 1 : 0;
                high = point._high = data[i + 1] ? (
                    mathFloor((point.plotX + (data[i + 1] ?
                        data[i + 1].plotX : plotSize)) / 2)) :
                    /**^
                     * Patched for scroll
                     */
                    mathFloor(point.plotX + 30);
                    /* EOP ^*/

                while (low <= high) {
                    tooltipPoints[inverted ? plotSize - low++ : low++] = point;
                }
            });
            series.tooltipPoints = tooltipPoints;
        },




        /**
	 * Series mouse over handler
	 */
        onMouseOver: function() {
            var series = this,
            chart = series.chart,
            hoverSeries = chart.hoverSeries;

            if (!hasTouch && chart.mouseIsDown) {
                return;
            }

            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }

            // trigger the event, but to save processing time,
            // only if defined
            if (series.options.events.mouseOver) {
                fireEvent(series, 'mouseOver');
            }


            // bring to front
            
            // Can the tracking be done otherwise?
            if (series.tracker) {
                series.tracker.toFront();
            }

            // hover this
            series.setState(HOVER_STATE);
            chart.hoverSeries = series;
        },

        /**
	 * Series mouse out handler
	 */
        onMouseOut: function() {
            // trigger the event only if listeners exist
            var series = this,
            options = series.options,
            chart = series.chart,
            tooltip = chart.tooltip,
            hoverPoint = chart.hoverPoint;

            // trigger mouse out on the point, which must be in this series
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }

            // fire the mouse out event
            if (series && options.events.mouseOut) {
                fireEvent(series, 'mouseOut');
            }


            // hide the tooltip
            if (tooltip && !options.stickyTracking) {
                tooltip.hide();
            }

            // set normal state
            series.setState();
            chart.hoverSeries = null;
        },

        /**
	 * Animate in the series
	 */
        animate: function(init) {
            var series = this,
            chart = series.chart,
            clipRect = series.clipRect,
            animation = series.options.animation;

            if (animation && !isObject(animation)) {
                animation = {};
            }
            /**^
             * handle the cliprect for not to hide line anchors
             */


            if (init) { // initialize the animation
                if (!clipRect.isAnimating) { // apply it only for one of the series
                    clipRect.attr( {
                        width : 0
                    });
                    clipRect.isAnimating = true;
                }

            } else { // run the animation
                clipRect.animate({
                    width: clipRect.cliprectW
                }, animation);

                // delete this function to allow it only once
                this.animate = null;
            }
        /*EOP^*/
        },


        /**
         * Draw the markers
         */
        drawPoints: function(){
            var series = this,
            pointAttr,
            data = series.data,
            chart = series.chart,
            options = series.options,
            plotX,
            plotY,
            i,
            point,
            radius,
            graphic;

            if (series.options.marker.enabled) {
                i = data.length;
                while (i--) {
                    point = data[i];
                    plotX = point.plotX;
                    plotY = point.plotY;
                    graphic = point.graphic;

                    // only draw the point if y is defined
                    if (plotY !== UNDEFINED && !isNaN(plotY)) {

                        /* && removed this code because points stayed after zoom
						point.plotX >= 0 && point.plotX <= chart.plotSizeX &&
						point.plotY >= 0 && point.plotY <= chart.plotSizeY*/

                        /**^
                         * Drawing Error Chart
                         */
                        //------  Drawing Error values -----//
                        var
                        errorValue, errorBarHeight, errorBarWidth, errorTopY,
                        errorBottomY, x, y, barCenter, errorPath = [], errorWidth,
                        errorHalfW, errorGraph, attribute, drawErrorBar = false;

                        //----- Error-Line ----//
                        if (point.errorValue) {
                            errorValue = point.errorValue;
                            x = plotX;
                            y = plotY;
                            barCenter = x;
                            errorWidth = options.errorBarWidth;
                            errorHalfW = errorWidth / 2;

                            errorPath.push(M, barCenter, y, L);
                            errorBarHeight = series.yAxis.translate(errorValue, 0, 0, 0, 0, 1);
                            errorTopY = y - errorBarHeight;
                            errorBottomY = y + errorBarHeight;
                            errorPath.push(barCenter, errorTopY,
                                M, barCenter + errorHalfW, errorTopY,
                                L, barCenter - errorHalfW, errorTopY);


                            if (options.halfErrorBar === 0) {
                                errorPath.push(M, barCenter, y,
                                    L, barCenter, errorBottomY,
                                    M, barCenter - errorHalfW, errorBottomY,
                                    L, barCenter + errorHalfW, errorBottomY);
                            }


                            point.errorPath = errorPath;
                            errorGraph = point.errorGraph;
                            if (errorGraph) { // update
                                stop(errorGraph);
                                errorGraph.animate({
                                    d : errorPath
                                });
                            } else {
                                point.errorGraph = chart.renderer.path(errorPath)
                                .attr({
                                    'stroke-width': options.errorBarThickness,
                                    stroke: options.errorBarColor
                                })
                                .add(series.group);
                            }
                        }

                        //----- Error-Scatter (Vertical Error) ----//
                        if (point.vErrorValue) {
                            errorValue = point.vErrorValue;
                            x = plotX;
                            y = plotY;
                            barCenter = x;
                            errorWidth = options.verticalErrorBarWidth;
                            errorHalfW = errorWidth / 2;

                            errorPath.push(M, barCenter, y, L);

                            errorBarHeight = series.yAxis.translate(errorValue, 0, 0, 0, 0, 1);
                            errorTopY = y - errorBarHeight;
                            errorBottomY = y + errorBarHeight;
                            errorPath.push(barCenter, errorTopY,
                                M, barCenter + errorHalfW, errorTopY,
                                L, barCenter - errorHalfW, errorTopY);


                            if (options.halfVerticalErrorBar === 0) {
                                errorPath.push(M, barCenter, y,
                                    L, barCenter, errorBottomY,
                                    M, barCenter - errorHalfW, errorBottomY,
                                    L, barCenter + errorHalfW, errorBottomY);
                            }

                            point.vErrorPath = errorPath;
                            errorGraph = point.vErrorGraph;
                            if (errorGraph) { // update
                                stop(errorGraph);
                                errorGraph.animate({
                                    d : errorPath
                                });
                            } else {
                                point.vErrorGraph = chart.renderer.path(errorPath)
                                .attr({
                                    'stroke-width': options.verticalErrorBarThickness,
                                    stroke: options.verticalErrorBarColor
                                })
                                .add(series.group);
                            }
                        }

                        //----- Error-Scatter (Horizontal Error) ----//
                        if (point.hErrorValue) {
                            errorValue = point.hErrorValue;
                            x = plotX;
                            y = plotY;
                            barCenter = x;
                            errorWidth = options.horizontalErrorBarWidth;
                            errorHalfW = errorWidth / 2;

                            errorPath.push(M, x, y, L);
                            errorBarWidth = series.xAxis.translate(errorValue, 0, 0, 0, 0, 1);
                            errorTopY = y - errorBarWidth;
                            errorBottomY = y + errorBarWidth;
                            errorPath.push(x + errorBarWidth, y,
                                M, x + errorBarWidth, y + errorHalfW,
                                L, x + errorBarWidth, y - errorHalfW);

                            if (options.halfHorizontalErrorBar === 0) {
                                errorPath.push(M, x, y,
                                    L, x - errorBarWidth, y,
                                    M, x - errorBarWidth, y + errorHalfW,
                                    L, x - errorBarWidth, y - errorHalfW);
                            }

                            point.hErrorPath = errorPath;
                            errorGraph = point.hErrorGraph;
                            if (errorGraph) { // update
                                stop(errorGraph);
                                errorGraph.animate({
                                    d : errorPath
                                });
                            } else {
                                point.hErrorGraph = chart.renderer.path(errorPath)
                                .attr({
                                    'stroke-width': options.verticalErrorBarThickness,
                                    stroke: options.verticalErrorBarColor
                                })
                                .add(series.group);
                            }
                        }

                        /*EOP^*/

                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        radius = pointAttr.r;

                        if (graphic) { // update
                            graphic.animate({
                                x: plotX,
                                y: plotY,
                                r: radius
                            });
                        } else {
                            point.graphic = chart.renderer.symbol(
                                pick(point.marker && point.marker.symbol, series.symbol),
                                plotX,
                                plotY,
                                radius
                                )
                            .attr(pointAttr)
                            .add(series.group);
                        }
                    }
                }
            }

        },

        /**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
        convertAttribs: function(options, base1, base2, base3) {
            var conversion = this.pointAttrToOptions,
            attr,
            option,
            obj = {};

            options = options || {};
            base1 = base1 || {};
            base2 = base2 || {};
            base3 = base3 || {};

            for (attr in conversion) {
                option = conversion[attr];
                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
            }
            return obj;
        },

        /**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
        getAttribs: function() {
            var series = this,
            normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
            stateOptions = normalOptions.states,
            stateOptionsHover = stateOptions[HOVER_STATE],
            pointStateOptionsHover,
            seriesColor = series.color,
            normalDefaults = {
                stroke: seriesColor,
                fill: seriesColor
            },
            data = series.data,
            i,
            point,
            seriesPointAttr = [],
            pointAttr,
            pointAttrToOptions = series.pointAttrToOptions,
            hasPointSpecificOptions,
            key;

            // series type specific modifications
            if (series.options.marker) { // line, spline, area, areaspline, scatter

                // if no hover radius is given, default to normal radius + 2
                stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;

            } else { // column, bar, pie

                // if no hover color is given, brighten the normal color
                stateOptionsHover.color = stateOptionsHover.color ||
                Color(stateOptionsHover.color || seriesColor)
                .brighten(stateOptionsHover.brightness).get();
            }

            // general point attributes for the series normal state
            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

            // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
            each([HOVER_STATE, SELECT_STATE], function(state) {
                seriesPointAttr[state] =
                series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
            });

            // set it
            series.pointAttr = seriesPointAttr;


            // Generate the point-specific attribute collections if specific point
            // options are given. If not, create a referance to the series wide point
            // attributes
            i = data.length;
            while (i--) {
                point = data[i];
                normalOptions = (point.options && point.options.marker) || point.options;
                if (normalOptions && normalOptions.enabled === false) {
                    normalOptions.radius = 0;
                }
                hasPointSpecificOptions = false;

                // check if the point has specific visual options
                if (point.options) {
                    for (key in pointAttrToOptions) {
                        if (defined(normalOptions[pointAttrToOptions[key]])) {
                            hasPointSpecificOptions = true;
                        }
                    }
                }



                // a specific marker config object is defined for the individual point:
                // create it's own attribute collection
                if (hasPointSpecificOptions) {

                    pointAttr = [];
                    stateOptions = normalOptions.states || {}; // reassign for individual point
                    pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

                    // if no hover color is given, brighten the normal color
                    if (!series.options.marker) { // column, bar, point
                        pointStateOptionsHover.color =
                        Color(pointStateOptionsHover.color || point.options.color)
                        .brighten(pointStateOptionsHover.brightness ||
                            stateOptionsHover.brightness).get();

                    }

                    // normal point state inherits series wide normal state
                    pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);

                    // inherit from point normal and series hover
                    pointAttr[HOVER_STATE] = series.convertAttribs(
                        stateOptions[HOVER_STATE],
                        seriesPointAttr[HOVER_STATE],
                        pointAttr[NORMAL_STATE]
                        );
                    // inherit from point normal and series hover
                    pointAttr[SELECT_STATE] = series.convertAttribs(
                        stateOptions[SELECT_STATE],
                        seriesPointAttr[SELECT_STATE],
                        pointAttr[NORMAL_STATE]
                        );



                // no marker config object is created: copy a reference to the series-wide
                // attribute collection
                } else {
                    pointAttr = seriesPointAttr;
                }

                point.pointAttr = pointAttr;

            }

        },


        /**
	 * Clear DOM objects and free up memory
	 */
        destroy: function() {
            var series = this,
            chart = series.chart,
            //chartSeries = series.chart.series,
            clipRect = series.clipRect,
            issue134 = /\/5[0-9\.]+ (Safari|Mobile)\//.test(userAgent), 
            destroy,
            prop;

            // add event hook
            fireEvent(series, 'destroy');

            // remove all events
            removeEvent(series);

            // remove legend items
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }

            // destroy all points with their elements
            each(series.data, function(point) {
                point.destroy();
            });
            /**^
             * destroy all points with their elements, for line series only
             * graphLine is a custom array containing each elements of line drawn as point wise
             */
            if (series.graphLine) {
                each(series.graphLine, function(point) {
                    point.destroy();
                });
            }
            /*EOP^*/
            // destroy all SVGElements associated to the series
            each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function(prop) {
                if (series[prop]) {

                    // issue 134 workaround
                    destroy = issue134 && prop === 'group' ?
                    'hide' :
                    'destroy';

                    series[prop][destroy]();
                }
            });

            // remove from hoverSeries
            if (chart.hoverSeries === series) {
                chart.hoverSeries = null;
            }
            erase(chart.series, series);

            // clear all members
            for (prop in series) {
                delete series[prop];
            }
        },

        /**^
         * drawDataLabels function completely changed, FusionCharts valueLabel format added.
         */
        // Draw the data labels
        drawDataLabels: function() {
            if (this.options.dataLabels.enabled) {
                var series = this,
                x,
                y,
                data = series.data,
                options = series.options.dataLabels,
                str,
                dataLabelsGroup = series.dataLabelsGroup,
                chart = series.chart,
                renderer = chart.renderer,
                HCChartObj = chart.options.chart,
                inverted = chart.inverted,
                seriesType = series.type,
                color,
                stacking = series.options.stacking,
                isBarLike = /^(column|column3d|bar|bar3d|floatedcolumn)$/.test(seriesType),
                vAlignIsNull = options.verticalAlign === null,
                yIsNull = options.y === null,
                canvasWidth = chart.plotWidth,
                canvasHeight = chart.plotHeight,
                smartLabel = renderer.smartLabel,
                placeValuesInside,
                labelTextWidth, labelTextHeight, rotateValues, plotHeight, plotTopHeight,
                smartTextObj, oriStr, containerSize,
                lineSeries = /^(line)$/.test(seriesType),
                depthYDisplacement = series.depthYDisplacement || 0,
                depthXDisplacement = series.depthXDisplacement || 0,
                lineHeight,
                fontLineHeight = options.style.fontSize.replace(/px/, ''),
                isSVG = renderer.box.nodeName == 'svg',
                // rotateLabelsErrorCenter to place the labels center
                // FIX for SVG renderer place center
                rotatedLabelsCenterError = (isSVG && !stacking) ? 2 : 0,
                RIGHTSTRING = 'right',
                CENTER = 'center',
                LEFT = 'left',
                valuePosition = HCChartObj.valuePosition && HCChartObj.valuePosition.toLowerCase(),
                negativeValue = false,
                valuePadding = HCChartObj.valuePadding,
                individualXDelta = 2 + valuePadding,
                isFloatedColumn = seriesType == 'floatedcolumn';

                // Setting style for smartLabel
                smartLabel.setStyle(options.style);

                if (isBarLike) {
                    if (stacking) {
                        // In stacked series the default label placement is inside the bars
                        if (vAlignIsNull) {
                            options = merge(options, {
                                verticalAlign: 'middle'
                            });
                        }

                        // If no y delta is specified, try to create a good default
                        if (yIsNull) {
                            options = merge(options, {
                                y: {
                                    top: 14,
                                    middle: 4,
                                    bottom: -6
                                }
                                [options.verticalAlign]
                            });
                        }
                        
                        // data object
                        options.align = 'center';
                    } else {
                        // In non stacked series the default label placement is on top of the bars
                        if (vAlignIsNull) {
                            options = merge(options, {
                                verticalAlign: 'top'
                            });
                        }
                    }
                }

                // Whether to rotate the valueLabels
                // Bar chart can't have rotated valueLabels
                if (!/^(bar|pie|bar3d)$/.test(seriesType)) {
                    options.rotation = rotateValues = (HCChartObj.rotateValues == 1) ? 270 : undefined;
                }

                // Whether to rotate the dataLabels
                if (/^(column|column3d|bar|bar3d|floatedcolumn)$/.test(seriesType)) {
                    placeValuesInside = HCChartObj.placeValuesInside;
                } else if (lineSeries) {
                    placeValuesInside = valuePosition === 'below';
                }

                // create a separate group for the data labels to avoid rotation
                if (!dataLabelsGroup) {
                    dataLabelsGroup = series.dataLabelsGroup =
                    renderer.g('data-labels')
                    .attr({
                        visibility: series.visible ? VISIBLE : HIDDEN,
                        zIndex: 6
                    })
                    .translate(chart.plotLeft, chart.plotTop)
                    .add();
                    //clip for scroll
                    /**^
                     *
                     */
                    if (chart.options.chart.hasScroll) {
                        dataLabelsGroup.clip(series.clipRect);
                    }
                /*EOP^*/
                }

                // determine the color
                color = options.color;
                if (color === 'auto') { // 1.0 backwards compatibility
                    color = null;
                }
                options.style.color = pick(color, series.color);

                // make the labels for each point
                each(data, function(point, i) {
                    var barX = point.barX,
                    plotX = (barX && barX + (point.barW / 2)) || (point.plotX != null ? point.plotX : -999),
                    //plotX = (barX && barX + point.barW / 2) || point.plotX || -999,
                    plotY = pick(point.plotY, -999),
                    dataLabel = point.dataLabel,
                    align = options.align,
                    individualYDelta = yIsNull ? (point.y >= 0 ? -6 : 12) : options.y;

                    // get the string
                    oriStr = options.formatter.call(point.getLabelConfig());

                    if (oriStr == null) {
                        return;
                    }

                    // Fix for WATERFALL chart value actual y
                    if (isFloatedColumn) {
                        plotY = pluckNumber(point.barY, plotY);
                    }
                    // Get the displayValue text according to the canvas width.
                    smartTextObj = smartLabel.getOriSize(oriStr, undefined, undefined, false);
                    str = smartTextObj.text;
                    x = (inverted ? canvasWidth - plotY : plotX) + options.x;

                    y = (inverted ? canvasHeight - plotX : plotY) + individualYDelta;
                    containerSize = undefined;

                    // Creating Zig Zag style of line labeles
                    if (lineSeries && !valuePosition) {
                        placeValuesInside = 0;
                        if (data[i - 1] && data[i - 1].plotY < point.plotY) {
                            placeValuesInside = 1;
                        }
                    }

                    // Negative value or not
                    negativeValue = (point.y < 0);

                    // Fix for WATERFALL chart value actual y
                    var _pointY = Number(isFloatedColumn ? point.barY : point.plotY);

                    // IF the value labels is in rotate mode.
                    if(rotateValues) {
                        //align = undefined;
                        align = LEFT;

                        individualYDelta = (negativeValue ? -4 - valuePadding : individualYDelta + 2 - valuePadding);
                        labelTextHeight = smartTextObj.width - individualYDelta;
                        labelTextWidth = smartTextObj.height - individualYDelta;
                        lineHeight = smartTextObj.width;
                        plotHeight = pluckNumber(point.barH, canvasHeight - _pointY);
                        plotTopHeight = _pointY;


                        // If the labels can fit on top of the data
                        if (labelTextHeight <= plotTopHeight) {
                            y = plotTopHeight + individualYDelta;
                            if (negativeValue) {
                                y =  plotY - individualYDelta + depthYDisplacement;
                                align = RIGHTSTRING;
                                if ((placeValuesInside && plotHeight > labelTextHeight) ||
                                    (labelTextHeight > canvasHeight - plotY)) {
                                    y =  plotY + individualYDelta + depthYDisplacement;
                                    align = LEFT;
                                }
                                x += depthXDisplacement;
                            }
                            if (placeValuesInside && !negativeValue && (point.y != 0)) {
                                // IF plotValuesInside
                                // Check if its fit inside the plot area
                                if (labelTextHeight <= plotHeight) {
                                    align = negativeValue ? CENTER : RIGHTSTRING;
                                    y = plotTopHeight - individualYDelta + depthYDisplacement;
                                    x += depthXDisplacement;
                                }
                            }
                        }
                        // If the labels can fit below the data
                        else if (labelTextHeight <= plotHeight) {
                            align = RIGHTSTRING;
                            y = plotTopHeight - individualYDelta + depthYDisplacement;
                            x += depthXDisplacement;
                            if(negativeValue) {
                                y = plotTopHeight - individualYDelta + depthYDisplacement;
                            }
                        }
                        // Original string can't fit either top or bottom
                        // We find the which has the maximum height
                        // and will render the label to that height.
                        else {
                            // Find which one has gretter height
                            // and put label into that
                            y = plotTopHeight + individualYDelta;
                            containerSize = plotTopHeight;

                            if (plotHeight > plotTopHeight && isFloatedColumn) {
                                y = canvasHeight + depthYDisplacement;
                                x += depthXDisplacement;
                                containerSize = plotHeight;
                            }
                            // Due to more padding if label goes beyond the canvas
                            if (y < lineHeight) {
                                y = 0;
                                align = RIGHTSTRING;
                            }
                        }
                        // Align the line to center only for line series
                        x += (fontLineHeight / 2) - rotatedLabelsCenterError;
                    }
                    // Non-rotate mode labels.
                    else {
                        individualYDelta = (negativeValue ? -4 - valuePadding : individualYDelta + 2 - valuePadding);
                        labelTextWidth = smartTextObj.width + individualXDelta;
                        labelTextHeight = fontLineHeight - individualYDelta;
                        lineHeight = fontLineHeight;
                        plotHeight = canvasHeight - _pointY;
                        plotTopHeight = _pointY;

                        if (/^(bar|bar3d)$/.test(seriesType)) {
                            // Fix to show bar chart label vertically aligned
                            y -= rotatedLabelsCenterError;
                            plotHeight = point.barH;
                            plotTopHeight = canvasWidth - point.barH;


                            if (negativeValue) {
                                plotTopHeight = canvasWidth - _pointY;
                                if ((placeValuesInside && plotHeight > labelTextWidth)
                                    || ((labelTextWidth > plotTopHeight) && (plotHeight > labelTextWidth))) {
                                    x = plotTopHeight + valuePadding + 2 + depthXDisplacement;
                                    y +=  depthYDisplacement;
                                } else if (labelTextWidth < plotTopHeight) {
                                    x = plotTopHeight - (valuePadding + 2) + depthXDisplacement;
                                    y +=  depthYDisplacement;
                                    align = RIGHTSTRING;
                                } else {
                                    x = 6;
                                    align = LEFT;
                                }
                            } else {
                                plotTopHeight = _pointY;

                                if ((placeValuesInside && plotHeight > labelTextWidth)
                                    || (labelTextWidth > plotTopHeight) && (plotHeight > labelTextWidth)) {
                                    // IF plotValuesInside
                                    // Check if its fit inside the plot area
                                    x = canvasWidth - plotTopHeight - (valuePadding + 2) + depthXDisplacement;
                                    align = RIGHTSTRING;
                                    y +=  depthYDisplacement;
                                } else if (labelTextWidth < plotTopHeight) {
                                    x = canvasWidth - plotTopHeight + (valuePadding + 2);
                                } else {
                                    x = canvasWidth - 6;
                                    y +=  depthYDisplacement;
                                    align = RIGHTSTRING;
                                }
                            }

                            if (x < 0) {
                                x = 6;
                                align = LEFT;
                            }
                            if (x > canvasWidth) {
                                x = canvasWidth - 6;
                                align = RIGHTSTRING;
                            }

                        }
                        // Chart is not a Bar chart
                        else {
                            
                            if (negativeValue) {
                                plotTopHeight = pluckNumber(point.barH, _pointY);
                                if ((placeValuesInside && plotTopHeight > labelTextHeight)
                                    || (labelTextHeight > plotHeight)) {
                                    y =  plotY + individualYDelta + depthYDisplacement;
                                } else {
                                    y =  plotY + labelTextHeight + depthYDisplacement;
                                }
                                x += depthXDisplacement;
                            }
                            // For all positive values
                            else {
                                plotHeight = pluckNumber(point.barH, canvasHeight - _pointY);
                                // If placeValuesInside is enabled and there is space to show a single line string
                                if ((placeValuesInside &&
                                    (plotHeight >= labelTextHeight) && (point.y != 0)) || (labelTextHeight > plotTopHeight)) {
                                    y = plotY + labelTextHeight + depthYDisplacement;
                                    x += depthXDisplacement;
                                } else {
                                    y = plotY + individualYDelta;
                                }

                                // Fix for bubble label middle alignment
                                if (seriesType == 'bubble') {
                                    y = plotY - individualYDelta / 2;
                                }
                            }

                            // Fix for zero values goes outside the canvas
                            if (y > canvasHeight) {
                                y = canvasHeight;
                            }
                            if (y < 0) {
                                y = lineHeight;
                            }
                        }
                    }

                    // For all stacked charts align the labels to center
                    align = stacking ? 'center' : align;

                    // Regenerate text
                    if (containerSize) {
                        smartTextObj = smartLabel.getOriSize(oriStr, containerSize, undefined, true);
                        str = smartTextObj.text;
                    }

                    // update existing label
                    if (dataLabel) {
                        // vertically centered
                        if (inverted && !options.y) {
                            y = y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2;
                        }
                        dataLabel
                        .attr({
                            text: str
                        }).animate({
                            x: x,
                            y: y
                        });
                    // create new label
                    } else if (defined(str)) {
                        dataLabel = point.dataLabel = renderer.text(
                            str,
                            x,
                            y
                            )
                        .attr({
                            align: align,
                            rotation: options.rotation,
                            zIndex: 1
                        })
                        .css(options.style)
                        .add(dataLabelsGroup);
                        // vertically centered
                        if (inverted && !options.y) {
                            dataLabel.attr({
                                y: y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2
                            });
                        }

                        /*if (series.isCartesian) {
                            dataLabel[chart.isInsidePlot(plotX, plotY) ? 'show' : 'hide']();
                        }*/

                        if (isBarLike && series.options.stacking) {
                            var barY = point.barY,
                            barW = point.barW,
                            barH = point.barH;

                            dataLabel.align(options, null,
                            {
                                x: inverted ? canvasWidth - barY - barH : barX + depthXDisplacement,
                                y: inverted ? canvasHeight - barX - barW +
                                (fontLineHeight / 2) + depthYDisplacement : barY,
                                width: inverted ? barH : barW,
                                height: inverted ? barW : barH
                            });
                        }
                    }
                });
            }
        },
        /*EOP^*/


        /**
	 * Draw the actual graph
	 */
        drawGraph: function(state) {
            var series = this,
            options = series.options,
            chart = series.chart,
            graph = series.graph,
            graphPath = [],
            fillColor,
            area = series.area,
            group = series.group,
            color = options.lineColor || series.color,
            lineWidth = options.lineWidth,
            dashStyle =  options.dashStyle,
            segmentPath,
            renderer = chart.renderer,
            translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
            useArea = /^area/.test(series.type),
            singlePoints = [], // used in drawTracker
            areaPath = [],
            attribs;

            //FC_CHANGED: To draw area and line point by point
            // old code: no code
            // Declaring variables to be use to draw area and line chart point by point
            // newSegmentPath: stores the path to be draw the area and line of individual data point
            // configArr: stores the configuration of individual data point
            // pointIndex: to indicate the individual data point index
            var newSegmentPath = [], configArr = [], singlePointConfig,
            pointIndex = 0, lastM = [], splinePath,
            shadowGroup = series.shadowGroup;

            // Put all shadows inside a group to avoid them to get sandwiched
            // between overlapping plot segments.
            if (!shadowGroup && options.shadow) {
                shadowGroup = series.shadowGroup = renderer.g('shadow')
                .add(group);
                shadowGroup.floated = true;
            }
            // End FC_CHANGED

            // divide into segments and build graph and area paths
            each(series.segments, function(segment) {
                segmentPath = [];

                // build the segment line
                each(segment, function(point, i) {

                    if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
                        //segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
                        // FC_CHANGED: Calculation the path for Spline Chart
                        // old code:
                        /*
                         *    segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
                         */
                        segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
                        var newSplinePath = series.getPointSpline(segment, point, i);
                        if(newSplinePath[0] == "C") {
                            lastPoint = segment[i - 1];
                            newSegmentPath.push(lastM.concat(newSplinePath));
                            configArr.push(lastPoint.config);
                            pointIndex++;
                            lastM = ["M"].concat(newSplinePath.slice(newSplinePath.length - 2));
                        } else {
                            lastM = newSplinePath;
                        }
                        // End FC_CHANGED

                    } else {

                        // moveTo or lineTo
                        segmentPath.push(i ? L : M);

                        // step line?
                        if (i && options.step) {
                            var lastPoint = segment[i - 1];
                            segmentPath.push(
                                point.plotX,
                                lastPoint.plotY
                            );
                        }

                        //FC_CHANGED: To draw area and line point by point
                        // old code : no code
                        // calculating the path of individual data points
                        if (i) {
                            lastPoint = segment[i - 1];
                            newSegmentPath[pointIndex] = [];
                            // IF its a step-line chart
                            if (options.step) {
                                newSegmentPath[pointIndex].push(M, lastPoint.plotX, lastPoint.plotY,
                                    L, point.plotX, lastPoint.plotY);
                                if (options.drawVerticalJoins) {
                                    newSegmentPath[pointIndex].push(point.plotX, point.plotY);
                                }
                            } else {
                                newSegmentPath[pointIndex].push(M, lastPoint.plotX, lastPoint.plotY,
                                    L, point.plotX, point.plotY);
                            }
                            configArr.push(lastPoint.config);
                            pointIndex++;
                        }
                        // End FC_CHANGED

                        // normal line to next point
                        segmentPath.push(
                            point.plotX,
                            point.plotY
                        );
                    }
                });

                // add the segment to the graph, or a single point for tracking
                if (segment.length > 1) {
                    graphPath = graphPath.concat(segmentPath);
                } else {
                    singlePoints.push(segment[0]);
                }

                // build the area
                if (useArea) {
                    var areaSegmentPath = [],
                    i,
                    segLength = segmentPath.length;
                    for (i = 0; i < segLength; i++) {
                        areaSegmentPath.push(segmentPath[i]);
                    }
                    if (segLength === 3) { // for animation from 1 to two points
                        areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
                    }
                    if (options.stacking && series.type !== 'areaspline') {
                        // follow stack back. Todo: implement areaspline
                        for (i = segment.length - 1; i >= 0; i--) {
                            areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
                        }

                    }else { // follow zero line back
                        areaSegmentPath.push(
                            L,
                            segment[segment.length - 1].plotX,
                            translatedThreshold,
                            L,
                            segment[0].plotX,
                            translatedThreshold
                            );
                    }
                    areaPath = areaPath.concat(areaSegmentPath);
                }
            });


            //FC_CHANGED: To draw area and line point by point
            // old code : no code
            // calculating the Area path of individual data points
            // build the area
            if (useArea) {
                var newAreaPath = [];
                each(newSegmentPath, function(segment) {

                    var areaSegmentPath = [],
                    i,
                    segLength = segment.length;
                    for (i = 0; i < segLength; i++) {
                        areaSegmentPath.push(segment[i]);
                    }
                    if (options.stacking && series.type !== 'areaspline') {
                        // follow stack back. Todo: implement areaspline
                        for (i = newSegmentPath.length - 1; i >= 0; i--) {
                        //areaSegmentPath.push(newSegmentPath[i].plotX, newSegmentPath[i].yBottom);
                        }

                    } else { // follow zero line back
                        areaSegmentPath.push(
                            L,
                            segment[segment.length - 2],
                            translatedThreshold,
                            L,
                            segment[1],
                            translatedThreshold
                            );
                    }
                    newAreaPath.push(areaSegmentPath);
                })
            }
            // End FC_CHANGED

            // used in drawTracker:
            series.graphPath = graphPath;
            series.singlePoints = singlePoints;

            // draw the area if area series or areaspline
            if (useArea) {
                fillColor = pick(
                    options.fillColor,
                    Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
                    );
                if (area) {
                    area.animate({
                        d: areaPath
                    });

                } else {

                    // draw the area
                    //FC_CHANGED: To draw area point by point
                    // old code

                    series.area = series.chart.renderer.path(areaPath)
                    .attr({
                        fill: fillColor
                    }).add(group);

                    // NEW CODE
                    var areaLineColor = color;

                /* // commented for current release
                      if (!hasSVG) {
                        series.area = series.chart.renderer.path(areaPath)
                        .attr({
                            fill: fillColor
                        }).add(group);
                    } else {

                        each(newAreaPath, function(path, i) {
                            fillColor.FCcolor.color  = configArr[i].color.FCcolor.color || fillColor.FCcolor.color;
                            fillColor.FCcolor.alpha  = configArr[i].color.FCcolor.alpha || fillColor.FCcolor.alpha;
                            fillColor.FCcolor.gradientUnits  = 'userSpaceOnUse';

                            series.area = series.chart.renderer.path(path)
                            .attr({
                                fill: fillColor,
                                stroke: fillColor,
                                'stroke-width': 1
                            }).add(group);
                        });
                    }*/
                //END NEW CODE
                // End FC_CHANGED
                }
            }

            /**^
             *  Drawing the line point wise and storing the path elements in series.graphLine array
             *  graphLine is a custom key to store the path elements
             */
            var graphLineArr, graphLine;

            // IF its an Area or Spline chart we draw the solid line instead of pointwise
            // remove the following checking ro Spline to draw spline point by point
            if(useArea || series.getPointSpline) {
                graphLine = series.graphLine;

                attribs = {
                    'stroke': color,
                    'stroke-width': lineWidth,
                    'stroke-linecap': 'round',
                    dashstyle: dashStyle
                };

                // draw the graph
                if (graphLine) {
                    graphLine.animate({
                        d: segmentPath
                    });
                }else {
                    if (lineWidth) {
                        singlePointConfig = configArr;

                        series.graphLine = renderer.path(segmentPath)
                        .attr(attribs).add(group).shadow(options.shadow, shadowGroup,
                            singlePointConfig.shadow);
                    }
                }
            } else { // Draw the line pointwise
                if (!series.graphLine) {
                    series.graphLine = [];
                }
                each(newSegmentPath, function (path, i) {
                    graphLineArr = series.graphLine;
                    graphLine = graphLineArr[i];
                    // draw the graph
                    if (graphLine) {
                        graphLine.animate({
                            d: path
                        });
                    } else {
                        if (lineWidth) {
                            singlePointConfig = configArr[i];

                            attribs = {
                                stroke: pluck(singlePointConfig.color, color),
                                'stroke-width': lineWidth,
                                'stroke-linecap': 'round',
                                dashstyle: pluck(singlePointConfig.dashStyle, dashStyle)
                            };

                            graphLineArr[i] = renderer.path(path)
                            .attr(attribs).add(group).shadow(options.shadow, shadowGroup,
                                singlePointConfig.shadow);
                        }
                    }
                });
            }
            /*EOP^*/
        },


        /**
	 * Render the graph and markers
	 */
        render: function() {
            var series = this,
            chart = series.chart,
            group,
            setInvert,
            options = series.options,
            animation = options.animation,
            doAnimation = animation && series.animate,
            duration = doAnimation ? (animation && animation.duration) || 500 : 0,
            clipRect = series.clipRect,
            renderer = chart.renderer;


            // Add plot area clipping rectangle. If this is before chart.hasRendered,
            // create one shared clipRect.
            if (!clipRect) {
                /**^
                 * handle the cliprect for not to hide line anchors
                 */
                var cliprectX = 0, cliprectY = 0, cliprectW = chart.plotSizeX, cliprectH = chart.plotSizeY;
                if (!chart.options.chart.hasScroll) {
                    cliprectX = -(chart.inverted ? chart.plotTop : chart.plotLeft);
                    cliprectY = -(chart.inverted ? chart.plotLeft : chart.plotTop);
                    cliprectW = chart.inverted ? chart.chartHeight : chart.chartWidth;
                    cliprectH = chart.inverted ? chart.chartWidth : chart.chartHeight;
                }
                clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
                chart.clipRect : renderer.clipRect(cliprectX, cliprectY, cliprectW, cliprectH);
                clipRect.cliprectX = cliprectX;
                clipRect.cliprectY = cliprectY;
                clipRect.cliprectW = cliprectW;
                clipRect.cliprectH = cliprectH;
                /*EOP^*/
                if (!chart.clipRect) {
                    chart.clipRect = clipRect;
                }
            }

            // the group
            if (!series.group) {
                group = series.group = renderer.g('series');

                if (chart.inverted) {
                    setInvert = function() {
                        group.attr({
                            width: chart.plotWidth,
                            height: chart.plotHeight
                        }).invert();
                    };

                    setInvert(); // do it now
                    addEvent(chart, 'resize', setInvert); // do it on resize
                    addEvent(series, 'destroy', function() {
                        removeEvent(chart, 'resize', setInvert);
                    });
                }
                group.clip(series.clipRect)
                .attr({
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    zIndex: options.zIndex
                })
                .translate(chart.plotLeft, chart.plotTop)
                .add(chart.seriesGroup);

            }

            series.drawDataLabels();

            // initiate the animation
            if (doAnimation) {
                series.animate(true);
            }

            // cache attributes for shapes
            //series.getAttribs();

            // draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
            }

            // draw the points
            series.drawPoints();

            // draw the mouse tracking area
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }

            // run the animation
            if (doAnimation) {
                series.animate();
            }

            // finish the individual clipRect
            setTimeout(function() {
                clipRect.isAnimating = false;
                group = series.group; // can be destroyed during the timeout
                if (group && clipRect !== chart.clipRect && clipRect.renderer) {
                    group.clip((series.clipRect = chart.clipRect));
                    clipRect.destroy();
                }
            }, duration);


            series.isDirty = false; // means data is in accordance with what you see

        },

        /**
	 * Redraw the series after an update in the axes.
	 */
        redraw: function() {
            var series = this,
            chart = series.chart,
            clipRect = series.clipRect,
            group = series.group;

            /*if (clipRect) {
			stop(clipRect);
			clipRect.animate({ // for chart resize
				width: chart.plotSizeX,
				height: chart.plotSizeY
			});
		}*/

            // reposition on resize
            if (group) {
                if (chart.inverted) {
                    group.attr({
                        width: chart.plotWidth,
                        height: chart.plotHeight
                    });
                }

                group.animate({
                    translateX: chart.plotLeft,
                    translateY: chart.plotTop
                });
            }

            series.translate();
            series.setTooltipPoints(true);
            series.render();
        },

        /**
	 * Set the state of the graph
	 */
        setState: function(state) {
            var series = this,
            options = series.options,
            graph = series.graph,
            stateOptions = options.states,
            lineWidth = options.lineWidth;

            state = state || NORMAL_STATE;

            if (series.state !== state) {
                series.state = state;

                if (stateOptions[state] && stateOptions[state].enabled === false) {
                    return;
                }

                if (state) {
                    lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
                }

                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
                    graph.attr({ // use attr because animate will cause any other animation on the graph to stop
                        'stroke-width': lineWidth
                    }, state ? 0 : 500);
                }
            }
        },

        /**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *        the visibility is toggled.
	 */
        setVisible: function(vis, redraw) {
            var series = this,
            chart = series.chart,
            legendItem = series.legendItem,
            seriesGroup = series.group,
            seriesTracker = series.tracker,
            dataLabelsGroup = series.dataLabelsGroup,
            /**^
             * add hiding of shadow groups
             */
            shadowGroup = series.shadowGroup,
            /*EOP^*/
            showOrHide,
            i,
            data = series.data,
            point,
            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
            oldVisibility = series.visible;

            // if called without an argument, toggle visibility
            series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? 'show' : 'hide';

            // show or hide series
            if (seriesGroup) { // pies don't have one
                seriesGroup[showOrHide]();
            }

            /**^
             * Especially show hide shadow group that are drawn outside the
             * series
             */
            if (shadowGroup && shadowGroup.floated) {
                shadowGroup[showOrHide]();
            }
            /* EOP ^*/

            // show or hide trackers
            if (seriesTracker) {
                seriesTracker[showOrHide]();
            } else {
                i = data.length;
                while (i--) {
                    point = data[i];
                    if (point.tracker) {
                        point.tracker[showOrHide]();
                    }
                }
            }


            if (dataLabelsGroup) {
                dataLabelsGroup[showOrHide]();
            }

            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }


            // rescale or adapt to resized chart
            series.isDirty = true;
            // in a stack, all other series are affected
            if (series.options.stacking) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }

            fireEvent(series, showOrHide);
        },

        /**
	 * Show the graph
	 */
        show: function() {
            this.setVisible(true);
        },

        /**
	 * Hide the graph
	 */
        hide: function() {
            this.setVisible(false);
        },

        /**^
         *
         */
        scroll: function (xShift, yShift, resetTooltip) {
            var series = this,
            chart = series.chart,
            options = series.options,
            animation = options.animation,
            doAnimation = animation && series.animate,
            duration = doAnimation ? (animation && animation.duration) || 500 : 0,
            clipRect = series.clipRect,
            newX = chart.plotLeft - xShift,
            newY = chart.plotTop - yShift,
            data = series.data,
            i = 0, len = data.length,
            point;
            //translate group, datalabels group, trackerGroup and reset clip
            series.group
            .translate(newX, newY);

            series.dataLabelsGroup
            .translate(newX, newY);

            chart.trackerGroup
            .translate(newX, newY);

            clipRect.attr({
                x : xShift,
                y : yShift
            });

            resetTooltip = resetTooltip === undefined ? true : resetTooltip
            //reset the tooltip position per point
            if (resetTooltip) {
                var toolTipX, toolTipY;
                for (; i < len; i += 1) {
                    point = data[i];
                    if (point.y !== null) {
                        toolTipX = point.plotX - xShift + 20;
                        toolTipY = point.plotY - yShift - 15;
                        toolTipX = toolTipX < 0 ? 0 : toolTipX;
                        toolTipY = toolTipY < 0 ? 0 : toolTipY;
                        point.tooltipPos = [toolTipX, toolTipY];
                    }
                }

                series.xShift = mathRound(xShift);
                series.yShift = mathRound(yShift);
            }

        },
        /*EOP^*/


        /**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *        UNDEFINED, the selection state is toggled.
	 */
        select: function(selected) {
            var series = this;
            // if called without an argument, toggle
            series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

            if (series.checkbox) {
                series.checkbox.checked = selected;
            }

            fireEvent(series, selected ? 'select' : 'unselect');
        },


        /**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
        drawTracker: function() {
            var series = this,
            options = series.options,
            trackerPath = [].concat(series.graphPath),
            trackerPathLength = trackerPath.length,
            chart = series.chart,
            snap = chart.options.tooltip.snap,
            tracker = series.tracker,
            cursor = options.cursor,
            css = cursor && {
                cursor: cursor
            },
            singlePoints = series.singlePoints,
            singlePoint,
            i;

            //clip for scroll
            /**^
             *
             */
            if (chart.options.chart.hasScroll) {
                chart.trackerGroup.clip(series.clipRect);
            }

            // draw the tracker (For Error Line)
            var  points = series.data, errorValue, errorShapeArgs, errorTracker,
            errorPoint, trackerLabel = +new Date();

            each(points, function(point) {
                errorValue = point.errorValue;
                if (errorValue) {

                    errorShapeArgs = point.errorPath;
                    errorTracker = point.errorTracker;

                    if (errorTracker) {// update
                        errorTracker.attr({
                            d: errorShapeArgs
                        });
                    } else {
                        errorPoint = {///build the point for error tooltip
                            series : series,
                            chart : chart,
                            id : point.id,
                            label : point.label,
                            options : point.options,
                            svgElm : point.svgElm,
                            toolText: errorValue + '',
                            getLabelConfig : point.getLabelConfig
                        };

                        point.errorTracker = chart.renderer.path(errorShapeArgs)
                        .attr({
                            'stroke-width': options.errorBarThickness,
                            stroke: TRACKER_FILL,
                            isTracker: trackerLabel,
                            fill: TRACKER_FILL,
                            visibility: series.visible ? VISIBLE : HIDDEN,
                            zIndex: 1
                        })
                        .on(hasTouch ? 'touchstart' : 'mouseover', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mousemove', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mouseout', (function(chart) {
                            return function() {
                                //hide the tooltip
                                chart.tooltip.hide();
                            };
                        }(chart)))
                        .css(css)
                        .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                    }
                }
            });
            /*EOP^*/

            // Extend end points. A better way would be to use round linecaps,
            // but those are not clickable in VML.
            if (trackerPathLength) {
                i = trackerPathLength + 1;
                while (i--) {
                    if (trackerPath[i] === M) { // extend left side
                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                    }
                    if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                    }
                }
            }

            // handle single points
            for (i = 0; i < singlePoints.length; i++) {
                singlePoint = singlePoints[i];
                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
                    L, singlePoint.plotX + snap, singlePoint.plotY);
            }

            // draw the tracker
            if (tracker) {
                tracker.attr({
                    d: trackerPath
                });

            }else { // create
                series.tracker = chart.renderer.path(trackerPath)
                .attr({
                    isTracker: true,
                    stroke: TRACKER_FILL,
                    fill: NONE,
                    'stroke-width' : options.lineWidth + 2 * snap,
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    zIndex: 1
                })
                .on(hasTouch ? 'touchstart' : 'mouseover', function() {
                    if (chart.hoverSeries !== series) {
                        series.onMouseOver();
                    }
                })
                .on('mouseout', function() {
                    if (!options.stickyTracking) {
                        series.onMouseOut();
                    }
                })
                .css(css)
                .add(chart.trackerGroup);
            }

        }

    }; // end Series prototype


    /**
     * LineSeries object
     */
    var LineSeries = extendClass(Series);
    seriesTypes.line = LineSeries;

    /**
     * AreaSeries object
     */
    var AreaSeries = extendClass(Series, {
        type: 'area'
    });
    seriesTypes.area = AreaSeries;




    /**
     * SplineSeries object
     */
    var SplineSeries = extendClass( Series, {
        type: 'spline',

        /**
	 * Draw the actual graph
	 */
        getPointSpline: function(segment, point, i) {
            var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
            denom = smoothing + 1,
            plotX = point.plotX,
            plotY = point.plotY,
            lastPoint = segment[i - 1],
            nextPoint = segment[i + 1],
            leftContX,
            leftContY,
            rightContX,
            rightContY,
            ret;

            // find control points
            if (i && i < segment.length - 1) {
                var lastX = lastPoint.plotX,
                lastY = lastPoint.plotY,
                nextX = nextPoint.plotX,
                nextY = nextPoint.plotY,
                correction;

                leftContX = (smoothing * plotX + lastX) / denom;
                leftContY = (smoothing * plotY + lastY) / denom;
                rightContX = (smoothing * plotX + nextX) / denom;
                rightContY = (smoothing * plotY + nextY) / denom;

                // have the two control points make a straight line through main point
                correction = ((rightContY - leftContY) * (rightContX - plotX)) /
                (rightContX - leftContX) + plotY - rightContY;

                leftContY += correction;
                rightContY += correction;

                // to prevent false extremes, check that control points are between
                // neighbouring points' y values
                if (leftContY > lastY && leftContY > plotY) {
                    leftContY = mathMax(lastY, plotY);
                    rightContY = 2 * plotY - leftContY; // mirror of left control point
                } else if (leftContY < lastY && leftContY < plotY) {
                    leftContY = mathMin(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                }
                if (rightContY > nextY && rightContY > plotY) {
                    rightContY = mathMax(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                } else if (rightContY < nextY && rightContY < plotY) {
                    rightContY = mathMin(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                }

                // record for drawing in next point
                point.rightContX = rightContX;
                point.rightContY = rightContY;

            }

            // moveTo or lineTo
            if (!i) {
                ret = [M, plotX, plotY];
            }

            // curve from last point to this
            else {
                ret = [
                'C',
                lastPoint.rightContX || lastPoint.plotX,
                lastPoint.rightContY || lastPoint.plotY,
                leftContX || plotX,
                leftContY || plotY,
                plotX,
                plotY
                ];
                lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
            }
            return ret;
        }
    });
    seriesTypes.spline = SplineSeries;



    /**
     * AreaSplineSeries object
     */
    var AreaSplineSeries = extendClass(SplineSeries, {
        type: 'areaspline'
    });
    seriesTypes.areaspline = AreaSplineSeries;

    /**
     * ColumnSeries object
     */
    var ColumnSeries = extendClass(Series, {
        type: 'column',
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'borderColor',
            'stroke-width': 'borderWidth',
            fill: 'color',
            r: 'borderRadius',
            dashstyle: 'dashStyle'
        },
        init: function() {
            Series.prototype.init.apply(this, arguments);

            var series = this,
            chart = series.chart;

            // flag the chart in order to pad the x axis
            chart.hasColumn = true;

            // if the series is added dynamically, force redraw of other
            // series affected by a new column
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        },

        /**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
        translate: function() {
            var series = this,
            chart = series.chart,
            options = series.options,
            stacking = options.stacking,
            borderWidth = options.borderWidth,
            columnCount = 0,
            reversedXAxis = series.xAxis.reversed,
            categories = series.xAxis.categories,
            stackGroups = {},
            stackKey,
            columnIndex;

            Series.prototype.translate.apply(series);

            // Get the total number of column type series.
            // This is called on every series. Consider moving this logic to a
            // chart.orderStacks() function and call it on init, addSeries and removeSeries
            each(chart.series, function(otherSeries) {
                /**^
                 * Removed visibility check of series while calculation
                 *
                 * @code
                 * if (otherSeries.type === series.type && otherSeries.visible) {
                 */
                if (otherSeries.type === series.type) {
                    /* EOP ^*/
                    if (otherSeries.options.stacking) {
                        stackKey = otherSeries.stackKey;
                        if (stackGroups[stackKey] === UNDEFINED) {
                            stackGroups[stackKey] = columnCount++;
                        }
                        columnIndex = stackGroups[stackKey];
                    } else {
                        columnIndex = columnCount++;
                    }
                    otherSeries.columnIndex = columnIndex;
                }
            });

            // calculate the width and position of each column based on
            // the number of column series in the plot, the groupPadding
            // and the pointPadding options
            var data = series.data,
            closestPoints = series.closestPoints,
            categoryWidth = mathAbs(
                data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX :
                chart.plotSizeX / ((categories && categories.length) || 1)
                ),
            groupPadding = categoryWidth * options.groupPadding,
            groupWidth = categoryWidth - 2 * groupPadding,
            pointOffsetWidth = groupWidth / columnCount,
            optionPointWidth = options.pointWidth,
            pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
            pointOffsetWidth * options.pointPadding,
            pointWidth = mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1);

            /**^
             * Implemente the FC point max width of 50ps feature if there
             * has grouppadding to 0.1
             */
            var maxColWidth = mathAbs(pluckNumber(options.maxColWidth, 50)) || 1;

            if (pointWidth > maxColWidth && options.groupPadding === 0.1) {
                groupPadding += ((pointWidth - maxColWidth) * columnCount) / 2;
                pointOffsetWidth = pointWidth = maxColWidth;

            }

            var colIndex = (reversedXAxis ? columnCount -
                series.columnIndex : series.columnIndex) || 0,
            pointXOffset = pointPadding + (groupPadding + colIndex *
                pointOffsetWidth -(categoryWidth / 2)) *
            (reversedXAxis ? -1 : 1),
            threshold = pluckNumber(options.threshold, mathMax(series.yAxis.options.min, 0), 0),
            translatedThreshold = series.yAxis.getThreshold(threshold),
            minPointLength = pick(options.minPointLength, 5);
            /* EOP ^*/

            // record the new values
            each(data, function(point) {
                var plotY = point.plotY,
                /**^
                 * stack issue #1744 fix
                 */
                yBottom = pluckNumber(point.yBottom, translatedThreshold),
                /* EOP ^*/
                barX = point.plotX + pointXOffset,
                barY = mathCeil(mathMin(plotY, yBottom)),
                barH = mathCeil(mathMax(plotY, yBottom) - barY),
                stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
                trackerY,
                shapeArgs;

                // Record the offset'ed position and width of the bar to be able to align the stacking total correctly
                /**^
                 * Removed visibility check of series while calculation
                 *
                 * @code
                 * if (stacking && series.visible && stack && stack[point.x]) {
                 */
                if (stacking && stack && stack[point.x]) {
                    /* EOP ^*/
                    stack[point.x].setOffset(pointXOffset, pointWidth);
                }

                // handle options.minPointLength and tracker for small points
                if (mathAbs(barH) < minPointLength) {
                    if (minPointLength) {
                        barH = minPointLength;
                        barY =
                        mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
                        yBottom - minPointLength : // keep position
                        translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
                    }
                    trackerY = barY - 3;
                }


                extend(point, {
                    barX: barX,
                    barY: barY,
                    barW: pointWidth,
                    barH: barH
                });

                // create shape type and shape args that are reused in drawPoints and drawTracker
                point.shapeType = 'rect';
                /**
                 * 1px offset added for drawing compensation
                 */
                shapeArgs = {
                    x : mathRound(barX),
                    y : mathRound(barY),
                    width : mathRound(pointWidth),
                    height: mathRound(barH),
                    r: options.borderRadius
                };
                /* EOP ^*/

                if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
                    shapeArgs.y -= 1;
                    shapeArgs.height += 1;
                }
                point.shapeArgs = shapeArgs;

                // make small columns responsive to mouse
                point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
                    height: mathMax(6, barH + 3),
                    y: trackerY
                });
            });

        },

        getSymbol: function(){
        },

        /**
	 * Columns have no graph
	 */
        drawGraph: function() {},

        /**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
        /**^
         * Added Error Value Feature[whole function changed]
         */
        drawPoints: function() {
            var series = this,
            options = series.options,
            renderer = series.chart.renderer,
            graphic,
            shapeArgs,
            /**^
             * Variable declararions and globalshadowGroup
             */
            shadowGroup = series.shadowGroup,
            r, x, y, width, height, strokeWidth,
            yaxis = series.yAxis,
            reversedYaxisColorChange = (yaxis.reversed && yaxis.options.min < 0)? true : false,
            isVMLRenderer = renderer.box.nodeName.toLowerCase() === 'div' ? true : false,
            inverted = series.inverted;
            /* EOP ^*/

            // draw the columns
            each(series.data, function(point) {
                var plotY = point.plotY;
                if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                    graphic = point.graphic;
                    shapeArgs = point.shapeArgs;
                    if (graphic) { // update
                        stop(graphic);
                        graphic.animate(shapeArgs);

                    }else {
                        /**^
                         * Fix to show solid plot border in Column2D charts
                         * passing the strokeWidth argument to rect function
                         * according to plotBorderThickness
                         * handling the color issue in VML for Bar
                         * handling the color issue in inversedChart
                         */
                        y = shapeArgs.y;
                        width = shapeArgs.width;
                        height = shapeArgs.height;
                        r = shapeArgs.r;
                        x = shapeArgs.x;
                        strokeWidth = point.pointAttr[point.selected ?
                        SELECT_STATE : NORMAL_STATE]['stroke-width'] % 2 === 0
                        ? undefined : 1;
                        //handle the color issue in inversedChart
                        if (reversedYaxisColorChange && point.color && point.color.FCcolor) {
                            point.color.FCcolor.angle += 180;
                        }
                        //handle the color issue in VML for Bar
                        if (isVMLRenderer && inverted && point.color && point.color.FCcolor) {
                            point.color.FCcolor.angle += 90;
                        }



                        point.graphic = renderer[point.shapeType](x, y, width, height, r, strokeWidth)
                        .attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
                        .add(series.group)
                        .shadow(options.shadow, shadowGroup, point.shadow);

                    /* EOP ^*/
                    }
                    //------  Drawing Error values -----//
                    if (point.errorValue) {
                        var errorGraph = point.errorGraph,
                        errorValue = point.errorValue, errorHeight, errorTopY, errorBottomY,
                        barCenter = x + (width / 2), errorPath = [M, barCenter, plotY, L],
                        errorWidth = width * options.errorBarWidthPercent / 100,
                        errorHalfW = errorWidth / 2;

                        errorHeight = series.yAxis.translate(errorValue, 0, 0, 0, 0, 1);
                        errorTopY = plotY - errorHeight;
                        errorBottomY = plotY + errorHeight;
                        errorPath.push(barCenter, errorTopY,
                            M, barCenter + errorHalfW, errorTopY,
                            L, barCenter - errorHalfW, errorTopY);



                        if (options.halfErrorBar === 0) {
                            errorPath.push(M, barCenter, plotY,
                                L, barCenter, errorBottomY,
                                M, barCenter - errorHalfW, errorBottomY,
                                L, barCenter + errorHalfW, errorBottomY
                                );
                        }
                        point.errorPath = errorPath;
                        if (errorGraph) { // update
                            stop(errorGraph);
                            graphic.animate({
                                d : errorPath
                            });

                        } else {
                            point.errorGraph = renderer.path(errorPath)
                            .attr({
                                'stroke-width': options.errorBarThickness,
                                stroke: options.errorBarColor
                            })
                            .add(series.group);
                        }
                    }

                }
            });
        },
        /* EOP ^*/
        /**
	 * Draw the individual tracker elements.
	 * This method is inherited by scatter and pie charts too.
	 */
        /**^
         *Whole Function Changed to add Error Tracker
         */
        drawTracker: function() {
            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            shapeArgs,
            tracker,
            trackerLabel = +new Date(),
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            rel;

            //clip for scroll
            /**^
             *
             */
            if (chart.options.chart.hasScroll) {
                chart.trackerGroup.clip(series.clipRect);
            }
            /*EOP^*/

            each(series.data, function(point) {
                tracker = point.tracker;
                var errorTracker = point.errorTracker,
                errorValue = point.errorValue, errorShapeArgs, errorPoint;
                shapeArgs = point.trackerArgs || point.shapeArgs;
                delete shapeArgs.strokeWidth;
                if (point.y !== null) {
                    if (tracker) {// update
                        tracker.attr(shapeArgs);

                    } else {
                        /**^
                         * Add cursor pointer if there has link
                         *modify the parent scope css variable with a local variable
                         */
                        if (point.link !== undefined) {
                            var css = {
                                cursor : 'pointer',
                                '_cursor': 'hand'
                            };
                        }
                        /* EOP ^*/
                        point.tracker =
                        renderer[point.shapeType](shapeArgs)
                        .attr({
                            isTracker: trackerLabel,
                            fill: TRACKER_FILL,
                            visibility: series.visible ? VISIBLE : HIDDEN,
                            zIndex: 1
                        })
                        .on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
                            rel = event.relatedTarget || event.fromElement;
                            if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
                                series.onMouseOver();
                            }
                            point.onMouseOver();

                        })
                        .on('mouseout', function(event) {
                            if (!series.options.stickyTracking) {
                                rel = event.relatedTarget || event.toElement;
                                if (attr(rel, 'isTracker') !== trackerLabel) {
                                    series.onMouseOut();
                                }
                            }
                        })
                        .css(css)
                        .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                    }
                    if (errorValue) {
                        errorShapeArgs = point.errorPath;

                        if (errorTracker) {// update
                            errorTracker.attr({
                                d: errorShapeArgs
                            });

                        } else {
                            errorPoint = {///build the point for error tooltip
                                series : series,
                                chart : chart,
                                id : point.id,
                                label : point.label,
                                options : point.options,
                                svgElm : point.svgElm,
                                toolText: point.errorValue + '',
                                getLabelConfig : point.getLabelConfig
                            };
                            point.errorTracker = renderer.path(errorShapeArgs)
                            .attr({
                                'stroke-width': mathMax(series.options.errorBarThickness, 10),
                                stroke: TRACKER_FILL,
                                isTracker: trackerLabel,
                                fill: TRACKER_FILL,
                                visibility: series.visible ? VISIBLE : HIDDEN,
                                zIndex: 1
                            })
                            .on(hasTouch ? 'touchstart' : 'mouseover', (function(point, chart) {
                                return function(e) {
                                    var plotLeft = chart.plotLeft,
                                    plotTop = chart.plotTop;
                                    point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                    //show the tooltext
                                    chart.tooltip.refresh(point);
                                };
                            }(errorPoint, chart)))
                            .on('mousemove', (function(point, chart) {
                                return function(e) {
                                    var plotLeft = chart.plotLeft,
                                    plotTop = chart.plotTop;
                                    point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                    //show the tooltext
                                    chart.tooltip.refresh(point);
                                };
                            }(errorPoint, chart)))
                            .on('mouseout', (function(chart) {
                                return function() {
                                    //hide the tooltip
                                    chart.tooltip.hide();
                                };
                            }(chart)))
                            .css(css)
                            .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                        }
                    }
                }
            });
        },
        /*EOP^*/

        /**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
        animate: function(init) {
            var series = this,
            data = series.data;

            if (!init) { // run the animation
                /*
			 * Note: Ideally the animation should be initialized by calling
			 * series.group.hide(), and then calling series.group.show()
			 * after the animation was started. But this rendered the shadows
			 * invisible in IE8 standards mode. If the columns flicker on large
			 * datasets, this is the cause.
			 */

                each(data, function(point) {
                    var graphic = point.graphic,
                    shapeArgs = point.shapeArgs;

                    if (graphic) {
                        // start values
                        graphic.attr({
                            height: 0,
                            /**^
                             * proper animation for inverse chart
                             */
                            y: series.yAxis.getThreshold(series.options.threshold || 0)
                        /* EOP ^*/
                        });

                        // animate
                        graphic.animate({
                            height: shapeArgs.height,
                            y: shapeArgs.y
                        }, series.options.animation);
                    }
                });


                // delete this function to allow it only once
                series.animate = null;
            }

        },
        /**
	 * Remove this series from the chart
	 */
        remove: function() {
            var series = this,
            chart = series.chart;

            // column and bar series affects other series of the same type
            // as they are either stacked or grouped
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            Series.prototype.remove.apply(series, arguments);
        }
    });
    seriesTypes.column = ColumnSeries;

    var BarSeries = extendClass(ColumnSeries, {
        type: 'bar',
        init: function(chart) {
            chart.inverted = this.inverted = true;
            ColumnSeries.prototype.init.apply(this, arguments);
        }
    });
    seriesTypes.bar = BarSeries;

    /**
     * The scatter series class
     */
    var ScatterSeries = extendClass(Series, {
        type: 'scatter',

        /**
	 * Extend the base Series' translate method by adding shape type and
	 * arguments for the point trackers
	 */
        translate: function() {
            var series = this;

            Series.prototype.translate.apply(series);

            each(series.data, function(point) {
                point.shapeType = 'circle';
                point.shapeArgs = {
                    x: point.plotX,
                    y: point.plotY,
                    r: series.chart.options.tooltip.snap
                };
            });
        },


        /**
         * Create individual tracker elements for each point
         */
        //drawTracker: ColumnSeries.prototype.drawTracker,
        drawTracker: function() {
            var series = this,
            chart = series.chart,
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            graphic;

            each(series.data, function(point) {

                /**^
                 *  To draw the tracker for Error-Scatter chart
                 */
                //----- Drawing Tracker for Error-Scatter charts -----//
                var errorShapeArgs, errorTracker, errorPoint,
                trackerLabel,
                renderer = chart.renderer,
                hErrorValue = point.hErrorValue,
                vErrorValue = point.vErrorValue;

                if (hErrorValue) {
                    errorShapeArgs = point.hErrorPath;
                    errorTracker = point.hErrorTracker;

                    if (errorTracker) {// update
                        errorTracker.attr({
                            d: errorShapeArgs
                        });

                    } else {
                        errorPoint = {///build the point for error tooltip
                            series : series,
                            chart : chart,
                            id : point.id,
                            label : point.label,
                            options : point.options,
                            svgElm : point.svgElm,
                            toolText: hErrorValue + '',
                            getLabelConfig : point.getLabelConfig
                        };

                        point.hErrorTracker = renderer.path(errorShapeArgs)
                        .attr({
                            'stroke-width': series.options.verticalErrorBarThickness,
                            stroke: TRACKER_FILL,
                            isTracker: trackerLabel,
                            fill: TRACKER_FILL,
                            visibility: series.visible ? VISIBLE : HIDDEN,
                            zIndex: 1
                        })
                        .on(hasTouch ? 'touchstart' : 'mouseover', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mousemove', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mouseout', (function(chart) {
                            return function() {
                                //hide the tooltip
                                chart.tooltip.hide();
                            };
                        }(chart)))
                        .css(css)
                        .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                    }
                }

                if (vErrorValue) {
                    errorShapeArgs = point.vErrorPath;
                    errorTracker = point.vErrorTracker;

                    if (errorTracker) {// update
                        errorTracker.attr({
                            d: errorShapeArgs
                        });

                    } else {
                        errorPoint = {///build the point for error tooltip
                            series : series,
                            chart : chart,
                            id : point.id,
                            label : point.label,
                            options : point.options,
                            svgElm : point.svgElm,
                            toolText: vErrorValue + '',
                            getLabelConfig : point.getLabelConfig
                        };

                        point.vErrorTracker = renderer.path(errorShapeArgs)
                        .attr({
                            'stroke-width': series.options.horizontalErrorBarThickness,
                            stroke: TRACKER_FILL,
                            isTracker: trackerLabel,
                            fill: TRACKER_FILL,
                            visibility: series.visible ? VISIBLE : HIDDEN,
                            zIndex: 1
                        })
                        .on(hasTouch ? 'touchstart' : 'mouseover', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mousemove', (function(point, chart) {
                            return function(e) {
                                var plotLeft = chart.plotLeft,
                                plotTop = chart.plotTop;
                                point.tooltipPos = [pluck(e.layerX,e.x) - plotLeft + 20, pluck(e.layerY, e.y) - plotTop - 15];
                                //show the tooltext
                                chart.tooltip.refresh(point);
                            };
                        }(errorPoint, chart)))
                        .on('mouseout', (function(chart) {
                            return function() {
                                //hide the tooltip
                                chart.tooltip.hide();
                            };
                        }(chart)))
                        .css(css)
                        .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                    }
                }
                //----- End of drawing Tracker for ErrorScatter chart -----//

                // Add cursor pointer if there has link
                // modify the parent scope css variable with a local variable
                if (point.link !== undefined) {
                    var css = {
                        cursor : 'pointer',
                        '_cursor': 'hand'
                    };
                }
                /* EOP ^*/

                graphic = point.graphic;
                if (graphic) { // doesn't exist for null points
                    graphic
                    .attr({
                        isTracker: true
                    })
                    .on('mouseover', function(event) {
                        series.onMouseOver();
                        point.onMouseOver();
                    })
                    .on('mouseout', function(event) {
                        if (!series.options.stickyTracking) {
                            series.onMouseOut();
                        }
                    })
                    .css(css);
                }
            });

        },

        /**
	 * Cleaning the data is not necessary in a scatter plot
	 */
        cleanData: function() {}
    });
    seriesTypes.scatter = ScatterSeries;

    /**
     * Extended point object for pies
     */
    var PiePoint = extendClass(Point, {
        /**
	 * Initiate the pie slice
	 */
        init: function () {

            Point.prototype.init.apply(this, arguments);

            var point = this,
            toggleSlice;

            //visible: options.visible !== false,
            extend(point, {
                visible: point.visible !== false,
                name: pick(point.name, 'Slice')
            });

            // add event listener for select
            toggleSlice = function() {
                /**^ do not rotate if click is fired while the series is
                 * rotating.
                 */
                if (point.series && point.series.rotationStartInstanceAngle) {
                    // Click was fired, indicating that rotation has
                    // stopped.
                    delete point.series.rotationStartInstanceAngle;
                }
                else {
                    point.slice();
                }
            /* EOP ^*/
            };
            /**^
             * Make the slicing effect same as FC
             * for MLPie remove the slicing effect
             */
            if (!point.link && !point.doNotSlice) {
                addEvent(point, 'click', toggleSlice);
            }
            /* EOP ^*/

            return point;
        },

        /**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
        setVisible: function(vis) {
            var point = this,
            chart = point.series.chart,
            tracker = point.tracker,
            dataLabel = point.dataLabel,
            connector = point.connector,
            shadowGroup = point.shadowGroup,
            method;

            // if called without an argument, toggle visibility
            point.visible = vis = vis === UNDEFINED ? !point.visible : vis;

            method = vis ? 'show' : 'hide';

            point.group[method]();
            if (tracker) {
                tracker[method]();
            }
            if (dataLabel) {
                dataLabel[method]();
            }
            if (connector) {
                connector[method]();
            }
            if (shadowGroup) {
                shadowGroup[method]();
            }
            if (point.legendItem) {
                chart.legend.colorizeItem(point, vis);
            }
        },

        /**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
        slice: function(sliced, redraw, animation) {
            var point = this,
            series = point.series,
            chart = series.chart,
            slicedTranslation = point.slicedTranslation,
            translation;

            setAnimation(animation, chart);

            // redraw is true by default
            redraw = pick(redraw, true);

            // if called without an argument, toggle
            sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;

            translation = {
                translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
                translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
            };
            point.group.animate(translation);
            if (point.shadowGroup) {
                point.shadowGroup.animate(translation);
            }

            /**^
             * added translation for the tracker
             */
            //animate the connectors
            var transX = slicedTranslation[0] - chart.plotLeft,
            transY = slicedTranslation[1] - chart.plotTop;
            if (point.connectorPath) {
                point.connectorPath[1] += sliced ? transX : -transX;
                point.connectorPath[2] += sliced ? transY : -transY;
                point.connectorPath[4] += sliced ? transX : -transX;
                point.connectorPath[6] += sliced ? transX : -transX;
                point.connector.animate({
                    d : point.connectorPath
                });
            }
            //animate the dataLabels
            if (point.dataLabel) {
                point.dataLabel.animate({
                    x : sliced ? point.dataLabel._x +  transX : point.dataLabel._x
                });

                if (point.dataLabelBG) {
                    point.dataLabelBG.animate({
                        x : sliced ? point.dataLabelBG.x +  transX : point.dataLabelBG.x
                    }, undefined, function () {
                        if (!sliced) {
                            point.dataLabel.textBound();
                        }
                    });
                }
            }
        /* EOP ^*/
        }
    });



    /**
     * Function that returns the arcTangent of a mouse-click with respect to a point.
     * @param {Array} center has the x,y point for which the tangent has to be
     * calculated.
     * @param {object} ref is the reference frame ofsset w.r.t the current page.
     * {left, top}
     */
    var getClickArcTangent = function (center, ref) {
        return mathATan2(center[1] - this.pageY + ref.top,
            center[0] - this.pageX + ref.left);
    };
    /* EOP ^*/

    /**
     * The Pie series class
     */
    var PieSeries = extendClass(Series, {
        type: 'pie',
        isCartesian: false,
        pointClass: PiePoint,
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'borderColor',
            'stroke-width': 'borderWidth',
            fill: 'color'
        },

        /**
	 * Pies have one color each point
	 */
        getColor: function() {
            // record first color for use in setData
            this.initialColor = this.chart.counters.color;
        },

        /**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
        animate: function(init) {
            var series = this,
            data = series.data;

            each(data, function(point) {
                var graphic = point.graphic,
                args = point.shapeArgs,
                /**^
                 * To map the pie animation same as FC
                 */
                up = 2 * mathPI;
                // start values
                if (graphic) {
                    graphic.attr({
                        start: up,
                        end: up
                    });
                    /* EOP ^*/

                    // animate
                    graphic.animate({
                        r: args.r,
                        start: args.start,
                        end: args.end
                    }, series.options.animation);
                }
            });

            // delete this function to allow it only once
            series.animate = null;

        },

        /**^
	 * To support rotating animation
	 * @source 10256/2.1.4
	 */
        /*
	 * this function will rotate the series
	 */
        rotate: function (setAngle) {
            var series = this,
            data = series.data,
            options = series.options,
            slicedOffset = options.slicedOffset,
            chartPlotLeft = series.chart.plotLeft,
            chartPlotTop = series.chart.plotTop,
            startingAngle = pluckNumber(this.chart.options.chart.startingAngle, 0),
            angle;
            setAngle = setAngle;
            angle = (setAngle - startingAngle) % 360;
            this.chart.options.chart.startingAngle = pluckNumber(setAngle,
                this.chart.options.chart.startingAngle) % 360;

            /*
                 * Code has been commented to implement a quick fix for rotation
                 * angle overflow issue.
                 *//*
		if (angle < 0) {
			angle = 360 + angle;
		}
                */

            angle = (angle * mathPI) / 180;


            each(data, function(point) {
                var graphic = point.graphic,
                shadow = point.shadowGroup,
                tracker = point.tracker,
                args = point.shapeArgs,
                newAngleArgs = {
                    start: args.start = args.start + angle,
                    end: args.end = args.end + angle
                },
                pointAngle = point.centerAngle = ((newAngleArgs.start + newAngleArgs.end) / 2) % math2PI,
                sliced = point.sliced,
                tooltipPosFactor = args.r * 0.7,
                slicedTranslation;

                /*
                         * Code has been commented to implement a quick fix for rotation
                         * angle overflow issue.
                         *//*
                        if (newAngleArgs.start > math2PI && newAngleArgs.end  > math2PI) {
                                newAngleArgs.start = newAngleArgs.start % math2PI;
                                newAngleArgs.end = newAngleArgs.end % math2PI;
                        }
                        */

                //set the  slicedTranslation
                point.slicedTranslation = map([
                    mathCos(pointAngle) * slicedOffset + chartPlotLeft,
                    mathSin(pointAngle) * slicedOffset + chartPlotTop
                    ], mathRound);

                slicedTranslation = {
                    translateX:  point.slicedTranslation[0],
                    translateY: point.slicedTranslation[1]
                };

                //set the tooltip position
                point.tooltipPos = [
                args.x + mathCos(pointAngle) * tooltipPosFactor,
                args.y + mathSin(pointAngle) * tooltipPosFactor
                ];

                //rotate the traker
                if (tracker) {
                    tracker.attr(newAngleArgs);
                }

                // rotate grapic
                if (graphic) {
                    graphic.attr(newAngleArgs);
                    // if sliced point then remove the slice
                    if (sliced) {
                        point.group.attr(slicedTranslation);
                    }
                }

                // adjust shadow rotation in sliced state
                if (shadow && sliced) {
                    point.shadowGroup.attr(slicedTranslation);
                }


            });

            this.drawDataLabels(true)

        },
        /* EOP 10256/2.1.4 ^*/

        /**
	 * Do translation for pie slices
	 */
        translate: function() {
            var total = 0,
            series = this,
            /**^
             * @source 10263/2.1.4
             * @code
             * cumulative = -0.25, // start at top
             * options = series.options,
             */
            precision = 1000, // issue #172
            options = series.options,
            startingAngle = (pluck(this.chart.options.chart.startingAngle, 0) % 360),
            cumulative = -1 * (startingAngle / 360), // start at top
            labelsDistance = pluckNumber(options.dataLabels.distance, 20),
            fontSize,
            slicedOffset = options.slicedOffset,
            connectorOffset = slicedOffset + options.borderWidth,
            positions = options.center,
            chart = series.chart,
            /* EOP 10263/2.1.4 ^*/
            plotWidth = chart.plotWidth,
            plotHeight = chart.plotHeight,
            start,
            end,
            angle,
            data = series.data,
            circ = 2 * mathPI,
            fraction,
            smallestSize = mathMin(plotWidth, plotHeight),
            isPercent,
            radiusX, // the x component of the radius vector for a given point
            radiusY,
            labelDistance = options.dataLabels.distance;

            // get positions - either an integer or a percentage string must be given
            positions.push(options.size, options.innerSize || 0);
            positions = map(positions, function(length, i) {

                isPercent = /%$/.test(length);
                return isPercent ?
                // i == 0: centerX, relative to width
                // i == 1: centerY, relative to height
                // i == 2: size, relative to smallestSize
                // i == 4: innerSize, relative to smallestSize
                [plotWidth, plotHeight, smallestSize, smallestSize][i] *
                pInt(length) / 100:
                length;
            });

            // utility for getting the x value from a given y, used for anticollision logic in data labels
            series.getX = function(y, left) {

                angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));

                return positions[0] +
                (left ? -1 : 1) *
                (mathCos(angle) * (positions[2] / 2 + labelDistance));
            };

            // set center for later use
            series.center = positions;

            // get the total sum
            each(data, function(point) {
                total += point.y;
            });

            /**^
             * Save the labels radius
             * @source 10315/2.1.4
             */
            series.labelsRadius = (positions[2] / 2) + labelsDistance;
            series.quadrantHeight = plotHeight / 2;
            series.quadrantWidth = plotWidth / 2;

            var labelsOptions = options.dataLabels;

            fontSize = pluckNumber(parseInt(labelsOptions.style.fontSize, 10), 10) + 4,//2px padding
            series.maxLabels = Math.floor(series.quadrantHeight / fontSize); //max labels per quarter
            series.labelFontSize = fontSize;
            series.connectorPadding = pluckNumber(labelsOptions.connectorPadding, 5);
            series.isSmartLineSlanted = pluck(labelsOptions.isSmartLineSlanted, true);
            series.connectorWidth = pluckNumber(labelsOptions.connectorWidth, 1);
            series.enableSmartLabels = labelsOptions.enableSmartLabels;
            /* EOP 10315/2.1.4 ^*/

            each(data, function(point) {
                // set start and end angle
                fraction = total ? point.y / total : 0;
                start = mathRound(cumulative * circ * precision) / precision;
                cumulative += fraction;
                end = mathRound(cumulative * circ * precision) / precision;

                // set the shape
                point.shapeType = 'arc';
                point.shapeArgs = {
                    x: positions[0],
                    y: positions[1],
                    r: positions[2] / 2,
                    innerR: positions[3] / 2,
                    start: start,
                    end: end
                };

                /**^
                 * added center and radius for radiul gradient
                 * @source 10333/2.1.4
                 */
                if (point.color.FCcolor) {
                    point.color.FCcolor.cx = positions[0]
                    point.color.FCcolor.cy = positions[1],
                    point.color.FCcolor.r = positions[2] / 2
                }
                /* EOP 10333/2.1.4 ^*/

                // center for the sliced out slice
                point.centerAngle = angle = ((end + start) / 2) % math2PI;
                point.slicedTranslation = map([
                    mathCos(angle) * slicedOffset + chart.plotLeft,
                    mathSin(angle) * slicedOffset + chart.plotTop
                    ], mathRound);

                // set the anchor point for tooltips
                radiusX = mathCos(angle) * positions[2] / 2;
                series.radiusY = radiusY = mathSin(angle) * positions[2] / 2;
                point.tooltipPos = [
                positions[0] + radiusX * 0.7,
                positions[1] + radiusY * 0.7
                ];

                // set the anchor point for data labels
                point.labelPos = [
                positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
                positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
                positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
                positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
                positions[0] + radiusX, // landing point for connector
                positions[1] + radiusY, // a/a
                labelDistance < 0 ? // alignment
                'center' :
                angle < circ / 4 ? 'left' : 'right', // alignment
                angle // center angle
                ];

                // API properties
                point.percentage = fraction * 100;
                point.total = total;

            });


            this.setTooltipPoints();
        },

        /**
	 * Render the slices
	 */
        render: function() {
            var series = this;

            // cache attributes for shapes
            //series.getAttribs();

            this.drawPoints();

            // draw the mouse tracking area
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }

            this.drawDataLabels();

            if (series.options.animation && series.animate) {
                series.animate();
            }

            series.isDirty = false; // means data is in accordance with what you see
        },

        /**
	 * Draw the data points
	 */
        drawPoints: function() {
            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            groupTranslation,
            //center,
            graphic,
            group,
            shadow = series.options.shadow,
            shadowGroup,
            shapeArgs;


            // draw the slices
            each(series.data, function(point) {
                graphic = point.graphic;
                shapeArgs = point.shapeArgs;
                group = point.group;
                shadowGroup = point.shadowGroup;

                // put the shadow behind all points
                if (shadow && !shadowGroup) {
                    shadowGroup = point.shadowGroup = renderer.g('shadow')
                    .attr({
                        zIndex: 4
                    })
                    .add();
                }

                // create the group the first time
                if (!group) {
                    group = point.group = renderer.g('point')
                    .attr({
                        zIndex: 5
                    })
                    .add();
                }

                // if the point is sliced, use special translation, else use plot area traslation
                groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
                group.translate(groupTranslation[0], groupTranslation[1]);
                if (shadowGroup) {
                    shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
                }


                // draw the slice
                if (graphic) {
                    graphic.animate(shapeArgs);
                } else {
                    point.graphic =
                    renderer.arc(shapeArgs)
                    .attr(extend(
                        point.pointAttr[NORMAL_STATE],
                        {
                            'stroke-linejoin': 'round'
                        }
                        ))
                    .add(point.group)
                    /**^
                     * Pass shadow configuration per-point
                     */
                    .shadow(shadow, shadowGroup, point.shadow);
                /* EOP ^*/
                }

                // detect point specific visibility
                if (point.visible === false) {
                    point.setVisible(false);
                }

            });

        },

        /**^
         * Modified data labels function
         */
        /**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
        drawDataLabels: (function () {
            /*
             * Pie Helper Functions.
             */
            var sortArrayByPoint = function (a, b) {
                return a.point.y - b.point.y;
            },
            sortArrayByAngle = function (a, b) {
                return a.angle - b.angle;
            },
            alignments = ['left', 'left', 'right', 'right'],
            alignCenter = 'center',
            ySign = [-1, 1, 1, -1],
            xSign = [1, 1, -1, -1];

            return function(isRotating) {
                var series = this,
                data = series.data,
                point,
                angle,
                chart = series.chart,
                options = series.options.dataLabels,
                placeInside = options.placeInside,
                connectorPadding = series.connectorPadding,
                connectorWidth = series.connectorWidth,
                connector,
                connectorPath,
                outside = options.distance > 0,
                remainingHeight,
                centerY = series.center[1],
                centerX = series.center[0],
                radius = series.center[2] / 2,
                quarters = [// divide the points into quarters for anti collision
                [], // top right
                [], // bottom right
                [], // bottom left
                [] // top left
                ],
                quarter,
                align,
                i,
                plotLeft = chart.plotLeft,
                plotTop = chart.plotTop,
                j,
                oriY,
                maxYmayHave,
                spaceRequired,
                length,
                k,
                sliced,
                x1, x2, x3, y1, y2, y3,
                points,
                dataLabelsRadius = series.labelsRadius,
                excess,
                excessArr,
                fontSize = series.labelFontSize,
                halfSize = fontSize / 2,
                xDisplacement = [connectorPadding, connectorPadding, -connectorPadding, -connectorPadding],
                maxLabels = series.maxLabels,
                isSmartLineSlanted = series.isSmartLineSlanted,
                enableSmartLabels = series.enableSmartLabels,
                labelQuardentHeight, maxQuardentLabel, dataLabel;

                // run parent method
                /**^
                 * Introduced the isRotating argument too to detect
                 * whether this is called during rotation.
                 * @source 10489/2.1.4
                 * @code
                 * Series.prototype.drawDataLabels.apply(series);
                 */
                if (!isRotating) {
                    Series.prototype.drawDataLabels.apply(series);
                }
                /* EOP 10489/2.1.4 ^*/

                // arrange points for detection collision
                // Creates an array of quarter containing labels of each quarter
                //if there has only one label the draw it inside
                if (data.length == 1) {
                    point = data[0];
                    dataLabel = point.dataLabel;
                    point.slicedTranslation = [plotLeft, plotTop];
                    if (dataLabel) {
                        dataLabel.attr({
                            visibility: VISIBLE,
                            align: alignCenter,
                            x: centerX,
                            y: centerY + halfSize - 2
                        });
                        dataLabel.x = centerX;
                    }
                }
                else {
                    if (placeInside){
                        var innerRadius = pluckNumber(series.center[3], 0) / 2,
                        centerDistence = innerRadius + ((radius - innerRadius) / 2);
                        each(data, function (point) {
                            dataLabel = point.dataLabel;
                            if (dataLabel) {
                                var angle = point.centerAngle;
                                y3 = centerY + (centerDistence * mathSin(angle)) + halfSize - 2;
                                x3 = centerX + (centerDistence * mathCos(angle));
                                dataLabel.x = x3;
                                // storing original x value
                                // to use while slicing in (IE Issue original x get changed form animate)
                                dataLabel._x = x3;

                                dataLabel.y = y3
                                if (point.sliced) {
                                    var slicedTranslation = point.slicedTranslation,
                                    transX = slicedTranslation[0] - plotLeft,
                                    transY = slicedTranslation[1] - plotTop;
                                    x3 = x3 + transX;
                                    y3 = y3 + transY;
                                }
                                dataLabel.attr({
                                    visibility: VISIBLE,
                                    align: alignCenter,
                                    x: x3,
                                    y: y3
                                });

                                // Creating text bound for dataLabels of Pie chart
                                point.dataLabelBG = dataLabel.textBound();
                            }
                        });
                    }
                    else {
                        each(data, function(point) {
                            dataLabel = point.dataLabel;
                            if (dataLabel) {
                                var angle = point.centerAngle,
                                quarter;

                                if (angle < 0) {
                                    angle = math2PI + angle;
                                }
                                // Calculate top right quarter labels
                                if (angle < mathHalfPI) {
                                    quarter = 1;
                                } else
                                // Calculate bottom right quarter labels
                                if (angle < mathPI) {
                                    quarter = 2;
                                } else
                                // Calculate bottom left quarter labels
                                if (angle < (quarterPI)) {
                                    quarter = 3;
                                }
                                // Calculate bottom left quarter labels
                                else {
                                    quarter = 0;
                                }
                                // Now put labels according to each quarter
                                quarters[quarter].push({
                                    point : point,
                                    angle : angle
                                });
                            }
                        });

                        i = k = 4;
                        //if excess then remove the low value slice first
                        while (i --) {
                            // Find labels can fit into the quarters or not
                            excess = quarters[i].length - maxLabels;
                            if (excess > 0) {
                                quarters[i].sort(sortArrayByPoint); // sort by point.y
                                // remove extra data form the array
                                // which labels can not be fitted into the quarters
                                excessArr = quarters[i].splice(0, excess);
                                //hide all removed labels
                                for (j = 0, length = excessArr.length; j < length; j += 1) {
                                    point = excessArr[j].point;
                                    point.dataLabel.attr({
                                        visibility: HIDDEN
                                    });
                                    if (point.connector) {
                                        point.connector.attr({
                                            visibility: HIDDEN
                                        });
                                    }
                                }
                            }
                            // now we sort the data labels by its label angle
                            quarters[i].sort(sortArrayByAngle);
                        }

                        maxQuardentLabel = mathMax(quarters[0].length, quarters[1].length, quarters[2].length, quarters[3].length);
                        labelQuardentHeight = mathMax(maxQuardentLabel * fontSize, dataLabelsRadius)

                        // reverse 1st and 3rd quardent points
                        quarters[1].reverse();
                        quarters[3].reverse();
                        while (k --) {
                            points = quarters[k];
                            length = points.length;

                            //1st pass
                            //place all labels at 1st quarter

                            // calculate the total available space to put labels
                            spaceRequired = (length * fontSize) - halfSize;
                            // calculate the remaining height
                            remainingHeight = labelQuardentHeight + halfSize;
                            //place all child point
                            for (i = 0; i < length; i += 1, spaceRequired -= fontSize) {
                                // Get the y position of the label (radius where data label is to draw)
                                oriY = mathAbs(labelQuardentHeight * mathSin(points[i].angle));
                                if (remainingHeight - oriY < fontSize) {
                                    oriY = remainingHeight - fontSize;
                                }
                                else if (oriY < spaceRequired) {
                                    oriY = spaceRequired;
                                }
                                remainingHeight = points[i].oriY = oriY;
                            }

                            //2nd pass(reverse)
                            align = alignments[k];
                            //place all labels at 1st quarter
                            maxYmayHave = labelQuardentHeight - (length * fontSize) + halfSize;
                            remainingHeight = - halfSize;

                            //place all child point
                            for (i = points.length - 1; i >= 0; i -= 1, maxYmayHave += fontSize) {
                                point = points[i].point;
                                angle = points[i].angle;
                                sliced = point.sliced;
                                dataLabel = point.dataLabel;
                                oriY = mathAbs(labelQuardentHeight * mathSin(angle));
                                if (oriY - remainingHeight < fontSize) {
                                    oriY = remainingHeight + fontSize;
                                }
                                else if (oriY > maxYmayHave) {
                                    oriY = maxYmayHave;
                                }
                                remainingHeight = oriY;

                                y1 = ((oriY + points[i].oriY) / 2);
                                //y1 = ySiagn[k] *  (0 + points[i].oriY);
                                x1 = centerX + xSign[k] * dataLabelsRadius * mathCos(math.asin(y1 / labelQuardentHeight));
                                //x1 = centerX + xSiagn[k] * dataLabelsRadius * mathSqrt(quadrantHeightSqrt - y1 * y1);
                                y1 *= ySign[k];
                                y1 += centerY;


                                y2 = centerY + (radius * mathSin(angle));
                                x2 = centerX + (radius * mathCos(angle));

                                x3 = x1 + xDisplacement[k];
                                y3 = y1 + halfSize - 2;
                                dataLabel.x = x3;
                                // storing original x value
                                // to use while slicing in (IE Issue original x get changed form animate)
                                dataLabel._x = x3;

                                dataLabel.y = y3
                                if (sliced) {
                                    var slicedTranslation = point.slicedTranslation,
                                    transX = slicedTranslation[0] - plotLeft,
                                    transY = slicedTranslation[1] - plotTop;
                                    x3 = x3 + transX;
                                    x1 = x1 + transX;
                                    x2 = x2 + transX;
                                    y2 = y2 + transY;
                                }
                                dataLabel.attr({
                                    visibility: VISIBLE,
                                    align: align,
                                    x: x3,
                                    y: y3
                                });

                                // Creating text bound for dataLabels of Pie chart
                                point.dataLabelBG = dataLabel.textBound();

                                //draw the connector
                                // draw the connector
                                if (outside && connectorWidth && enableSmartLabels) {
                                    connector = point.connector;

                                    point.connectorPath = connectorPath = [
                                    M,
                                    x2, y2, // base
                                    L,
                                    isSmartLineSlanted ? x1 : x2, y1, // first break, next to the label
                                    x3, y1  // end of the string at the label
                                    ];

                                    if (connector) {
                                        connector.attr({
                                            d: connectorPath
                                        });
                                        connector.attr('visibility', VISIBLE);

                                    } else {
                                        point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                            'stroke-width': connectorWidth,
                                            stroke: options.connectorColor || '#606060',
                                            visibility: VISIBLE,
                                            zIndex: 3
                                        })
                                        .translate(plotLeft, plotTop)
                                        .add();
                                    }
                                }
                            }
                        }
                    }
                }
            };
        }()),
        /* EOP ^*/

        /**^
	 * Draw point specific tracker objects.
	 */
        drawTracker: function () {

            var series = this,
            tracker,
            // Compute the pixel center of the pie series. This will later
            // be used while pie rotation calculation upon drag.
            pieCenter = [series.center[0] + series.chart.plotLeft,
            series.center[1] + series.chart.plotTop],
            chartPosition,
            rotationEnabled = series.options.enableRotation,
            rotationTrigger;

            if (rotationEnabled) {
                // Event handler to mark that pie rotation has changed upon
                // drag.
                rotationTrigger = function (event) {
                    // Log the chart position for calculating mouse xy.
                    chartPosition = getPosition(series.chart.container);
                    // Record the angle of point of drag start with respect
                    // to starting angle.
                    series.rotationStartInstanceAngle =
                    getClickArcTangent.call(event, pieCenter, chartPosition) -
                    series.chart.options.chart.startingAngle * deg2rad;
                    // Hide tooltip on dragstart
                    if (series.chart.tooltip) {
                        if (event.type === 'dragstart') {
                            series.chart.tooltip.block(true);
                        }
                        else {
                            series.chart.tooltip.block(false);
                            series.chart.tooltip.refresh(event.data, true);
                        }
                    }
                };
            }

            // Call the parent tracker from coulmn.
            ColumnSeries.prototype.drawTracker.apply(this, arguments);

            each(series.data, function(point) {
                // Process if tracker exists and rotation not ready.
                if (point.y === null || !(tracker = point.tracker) || tracker.canRotate === true) {
                    return true;
                }

                // Fire rotation start and stop trigger.
                if (rotationEnabled) {
                    addEvent(tracker.element, 'dragstart dragend',
                        rotationTrigger, point);

                    // rotate series upon drag.
                    addEvent(tracker.element, 'drag', function (event) {
                        series.rotate((getClickArcTangent.call(event, pieCenter,
                            chartPosition) - series.rotationStartInstanceAngle) /
                        deg2rad);
                    });
                }
            });
        },
        /* EOP ^*/

        /**
	 * Pies don't have point marker symbols
	 */
        getSymbol: function() {}

    });
    seriesTypes.pie = PieSeries;


    // global variables
    var Highcharts = lib.Highcharts = {
        Chart: Chart,
        dateFormat: dateFormat,
        pathAnim: pathAnim,
        getOptions: getOptions,
        numberFormat: numberFormat,
        Point: Point,
        Color: Color,
        Renderer: Renderer,
        seriesTypes: seriesTypes,
        setOptions: setOptions,
        Series: Series,

        // Expose utility funcitons for modules
        addEvent: addEvent,
        createElement: createElement,
        discardElement: discardElement,
        css: css,
        each: each,
        extend: extend,
        map: map,
        merge: merge,
        pick: pick,
        extendClass: extendClass,
        product: 'Highcharts',
        version: '2.1.6',
        /**^
	 * @source 10669/2.1.4
	 */
        pvt: {

        },
        attr : attr,
        FusionChartsModified: '3.2.2'
    /*EOP 10669/2.1.4 ^*/
    };






    //////////////////////////////////////////////////////////////////////////////////
    ///////                Add Extra Serieses for FusionCharts                 ///////
    //////////////////////////////////////////////////////////////////////////////////


    /*!
     * Section containing all extensions required for HighCharts base in order to
     * render FusionCharts and PowerCharts.
     *
     * @section
     * FusionCharts Series Extensions for HighCHarts
     *
     * @since 3.2
     * @version 1.0
     */




    /* ****************************************************************************
     * Start floatedcolumn series code                                            *
     *****************************************************************************/

    // 1 - Set default options
    defaultPlotOptions.floatedcolumn = merge(defaultPlotOptions.column, {
        states: {
            hover: { }
        }
    });

    // 2- Create the floatedcolumn point object

    //// NO code

    // 3 - Create the floatedcolumn series constractor
    var floatedcolumn = Highcharts.extendClass(seriesTypes.column, {
        type: 'floatedcolumn',

        translate: function () {
            var series = this,
            chart = series.chart,
            columnCount = 0,
            reversedXAxis = series.xAxis.reversed,
            categories = series.xAxis.categories,
            stackGroups = {},
            stackKey,
            toolTipX,
            toolTipY,
            columnIndex;

            // Call super function.
            Series.prototype.translate.apply(series);

            // Get the total number of column type series.
            // This is called on every series. Consider moving this logic to a
            // chart.orderStacks() function and call it on init, addSeries and removeSeries
            each(chart.series, function(otherSeries) {
                if (otherSeries.type == series.type) {
                    if (otherSeries.options.stacking) {
                        stackKey = otherSeries.stackKey;
                        if (stackGroups[stackKey] === UNDEFINED) {
                            stackGroups[stackKey] = columnCount++;
                        }
                        columnIndex = stackGroups[stackKey];
                    } else {
                        columnIndex = columnCount++;
                    }
                    otherSeries.columnIndex = columnIndex;
                }
            });

            // calculate the width and position of each column based on
            // the number of column series in the plot, the groupPadding
            // and the pointPadding options
            var options = series.options,
            data = series.data,
            closestPoints = series.closestPoints,
            categoryWidth = mathAbs( data[1] ?
                data[closestPoints].plotX - data[closestPoints - 1].plotX :
                chart.plotSizeX / (categories ? categories.length : 1)),
            groupPadding = categoryWidth * options.groupPadding,
            groupWidth = categoryWidth - 2 * groupPadding,
            pointOffsetWidth = groupWidth / columnCount,
            optionPointWidth = options.pointWidth,
            pointPadding = defined(optionPointWidth) ?
            (pointOffsetWidth - optionPointWidth) / 2 :
            pointOffsetWidth * options.pointPadding,
            pointWidth = mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1),
            colIndex = (reversedXAxis ? columnCount -
                series.columnIndex : series.columnIndex) || 0,
            pointXOffset = pointPadding + (groupPadding + colIndex *
                pointOffsetWidth -(categoryWidth / 2)) *
            (reversedXAxis ? -1 : 1),
            threshold = options.threshold || 0,
            xAxis = series.xAxis,
            yAxis = series.yAxis,
            xAxisExtremes = xAxis.getExtremes(),
            yAxisExtremes = yAxis.getExtremes(),
            translatedThreshold = series.yAxis.getThreshold(threshold),
            minPointLength = pick(options.minPointLength, 5);

            // record the new values
            each(data, function(point) {
                var plotY = point.plotY,
                yBottom = point.yBottom || translatedThreshold,
                barX = point.plotX + pointXOffset,
                barY = mathCeil(mathMin(plotY, yBottom)),
                barH = mathCeil(mathMax(plotY, yBottom) - barY),
                trackerY,
                barW;

                //if any special attr supplyred then replace the calculated value
                if (point['_FCX'] !== undefined) {
                    barX = xAxis.translate(point['_FCX'], 0, 0, 0, 1);
                }
                if (point['_FCY'] !== undefined) {
                    barY = series.yAxis.translate(point['_FCY'], 0, 1, 0, 1);
                }
                if (point['_FCH'] !== undefined) {
                    barH = mathRound(point['_FCH'] * Math.abs(chart.plotSizeY / (yAxisExtremes.max - yAxisExtremes.min)) * 100) / 100
                }
                if (point['_FCW'] !== undefined) {
                    barW = mathRound(point['_FCW'] * Math.abs(chart.plotSizeX / (xAxisExtremes.max - xAxisExtremes.min)) * 100) / 100;
                }
                else {
                    barW = pointWidth;
                }

                // handle options.minPointLength and tracker for small points
                if (mathAbs(barH) < minPointLength) {
                    if (minPointLength) {
                        barH = minPointLength;
                        barY =
                        mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
                        yBottom - minPointLength : // keep position
                        translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
                    }
                    trackerY = barY - 3;
                }

                extend(point, {
                    barX: barX,
                    barY: barY,
                    barW: barW,
                    barH: barH
                });
                point.shapeType = 'rect';
                point.shapeArgs = {
                    x: barX,
                    y: barY,
                    width: barW,
                    height: barH,
                    r: options.borderRadius
                };

                toolTipX = barX + barW / 2 + 15;
                toolTipY = barY - 15;
                point.tooltipPos = [toolTipX < 0 ? 0 : toolTipX, toolTipY < 0 ? 0 : toolTipY]

                
                // make small columns responsive to mouse
                point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
                    height: mathMax(6, barH + 3),
                    y: trackerY
                });
            });

        }
    });

    // 4 - add the constractor
    seriesTypes.floatedcolumn = floatedcolumn;

    /* ****************************************************************************
     * Start SSGrid series code                                                   *
     *****************************************************************************/

    // 1 - Set default options
    defaultPlotOptions.ssgrid = merge(defaultPlotOptions.pie, {
        states: {
            hover: {}
        }
    });

    // 2- Create the SSGrid point object

    //NO Code

    //helper Functon for S grid
    var nenagitePage = function (chart, isPrev) {
        var currentIndex = chart.currentSeriesIndex,
        series = chart.series,
        wouldBeIndex = isPrev ? currentIndex -1 : currentIndex + 1;

        if (series[wouldBeIndex]) {
            series[currentIndex].hide();
            series[wouldBeIndex].show();
            chart.currentSeriesIndex = wouldBeIndex;
            placeNaviGator(chart);
        }
    },

    placeNaviGator = function (chart) {
        var noOfSeries = chart.series.length,
        options = chart.options.chart,
        rowHeight = options.rowHeight,
        currentSeriesIndex = chart.currentSeriesIndex,
        pageHeight = chart.series[currentSeriesIndex].data.length * rowHeight,
        naviigator = chart.naviigator;
        naviigator.translate(0, pageHeight);

        if (currentSeriesIndex === 0) {
            naviigator.navElePrv.hide();
        }
        else {
            naviigator.navElePrv.show();
        }
        if (currentSeriesIndex === noOfSeries - 1) {
            naviigator.navEleNxt.hide();
        }else {
            naviigator.navEleNxt.show();
        }
    },

    drawSSGridNavButton = function (chart) {
        var renderer = chart.renderer,
        options = chart.options.chart,
        width = options.width,
        x = 20,
        radius = options.navButtonRadius,
        radiusFregment = radius * 0.67,
        y = options.navButtonPadding + radiusFregment,
        nextEleX = width-x,
        navButtonHoverColor = options.navButtonHoverColor,
        navButtonColor = options.navButtonColor,
        navElePrv, navEleNxt, navElePrvGroup, navEleNxtGroup;

        if (chart.series.length > 1) {
            //create the nevagitor group
            var naviigatorGroup = chart.naviigator = renderer.g('navigator')
            .attr({
                zIndex : 4
            }).add();


            naviigatorGroup.navElePrv = navElePrvGroup = renderer.g('navElePrv').add(naviigatorGroup);
            //DRAW THE ARROW
            navElePrv = renderer.path([
                M, x, y,
                L, x + radius + radiusFregment, y - radiusFregment,
                x + radius, y,
                x + radius + radiusFregment, y + radiusFregment, 'Z'
                ])
            .attr({
                fill: navButtonColor
            }).add(navElePrvGroup);


            // draw the click circle
            renderer.circle(x+radius, y, radius)
            .attr({
                fill: COLOR_TRANSPARENT,
                cursor: 'pointer'
            })
            .on('mouseover', function() {
                navElePrv.attr({
                    fill: navButtonHoverColor,
                    cursor: 'pointer'
                });
            }).on('mouseout', function() {
                navElePrv.attr({
                    fill: navButtonColor
                });
            }).on('click', function() {
                nenagitePage(chart, true);
            }).add(navElePrvGroup);


            naviigatorGroup.navEleNxt = navEleNxtGroup = renderer.g('navEleNxt').add(naviigatorGroup);
            //DRAW THE ARROW
            navEleNxt = renderer.path([
                M, nextEleX, y,
                L, nextEleX - radius - radiusFregment, y - radiusFregment,
                nextEleX - radius, y,
                nextEleX - radius - radiusFregment, y + radiusFregment, 'Z'
                ])
            .attr({
                fill: navButtonColor,
                cursor: 'pointer'
            }).add(navEleNxtGroup)


            // draw the click circle
            renderer.circle(nextEleX - radius, y, radius)
            .attr({
                fill: COLOR_TRANSPARENT,
                cursor: 'pointer'
            })
            .on('mouseover', function() {
                navEleNxt.attr({
                    fill: navButtonHoverColor
                });
            }).on('mouseout', function() {
                navEleNxt.attr({
                    fill: navButtonColor
                });
            }).on('click', function() {
                nenagitePage(chart);
            })
            .attr({
                fill: navButtonColor
            })
            .add(navEleNxtGroup);
        }
    //draw the border
    }

    // 3 - Create the OHLCSeries object
    var SSGrid = Highcharts.extendClass(seriesTypes.pie, {
        type: 'ssgrid',
        translate: function () {
            var series = this,
            chartOptions = series.chart.options.chart,
            data = series.data,
            x = 0, y = 0,
            width = chartOptions.width,
            height = chartOptions.rowHeight,
            colorBoxWidth = chartOptions.colorBoxWidth,
            colorBoxHeight = chartOptions.colorBoxHeight,
            colorBoxX = chartOptions.colorBoxX,
            labelX = chartOptions.labelX,
            valueX = chartOptions.valueX;


            each(data, function(point) {

                // set the shape
                point.shapeType = 'rect';
                point.alternateGradientBox = {
                    x: x,
                    y: y,
                    width : width,
                    height: height,
                    r: 0
                };

                // Path for row divider line
                point.rowDivider = [M, x, y, L, width, y];

                // Path for color box rect
                point.colorBoxArgs = {
                    x: colorBoxX,
                    y: y + (height / 2) - (colorBoxHeight / 2),
                    width : colorBoxWidth,
                    height: colorBoxHeight,
                    r: 0
                };

                point.labelX = labelX;

                point.valueX = valueX;

                y += height;
            });

            // To draw the last RowDivider line
            series.options.lastRowDivider = [M, x, y, L, width, y];
        },
        drawPoints: function() {
            var series = this,
            chartOptions = series.chart.options.chart,
            renderer = series.chart.renderer,
            graphic,
            group = series.group,
            fillAltcolor = chartOptions.alternateRowColor,
            attrib = chartOptions.listRowDividerAttr,
            lastRowDivider = series.options.lastRowDivider,
            rowHeight = chartOptions.rowHeight,
            textStyle = chartOptions.textStyle,
            lineHeight = chartOptions.lineHeight,
            width = chartOptions.width,
            valueColumnPadding = chartOptions.valueColumnPadding,
            rowDivider, colorBoxArgs, alternateGradientBox,
            textEle, textY, valueX, bBox;


            // draw the slices
            each(series.data, function(point, index) {
                graphic = point.graphic;
                rowDivider = point.rowDivider;
                colorBoxArgs = point.colorBoxArgs;
                alternateGradientBox = point.alternateGradientBox;
                valueX = point.valueX;

                // draw the chart
                if (graphic) {
                //graphic.animate(rowDivider);
                } else {

                    // Draw the listRowDivide Lines
                    point.graphic = renderer.path(rowDivider)
                    .attr(attrib)
                    .add(group);

                    if(index % 2 == 0) {
                        renderer.rect(alternateGradientBox)
                        .attr({
                            fill: fillAltcolor,
                            "stroke-width": 0
                        })
                        .add(group);
                    }


                    // Draw the color BOX
                    point.symbol = renderer.rect(colorBoxArgs)
                    .attr({
                        fill : point.color,
                        'stroke-width': 0,
                        stroke: '#000000'
                    })
                    .add(group);


                    // Draw label text
                    textEle = renderer.text(point.label,
                        point.labelX
                        )
                    .css(textStyle)
                    .add(group);
                    // Adjusting text middle alignment
                    textY = (rowDivider[2] + (rowHeight / 2) + lineHeight) - ((textEle.getBBox().height / 2));
                    textEle.attr({
                        y: textY
                    });


                    // Draw value text
                    textEle = renderer.text(point.displayValue,
                        valueX
                        )
                    .css(textStyle)
                    .add(group);

                    bBox = textEle.getBBox();
                    // Adjusting value text to middle
                    textY = (rowDivider[2] + (rowHeight / 2) + lineHeight) - ((bBox.height / 2));
                    textEle.attr({
                        y: textY,
                        // Adjusting value text to right
                        x: valueX + ((width - valueX - valueColumnPadding) - bBox.width)
                    });
                }
            });

            // render the last row divider line
            renderer.path(lastRowDivider)
            .attr(attrib)
            .add(group);
        },

        render: function() {
            var series = this, group, chart = series.chart, renderer = chart.renderer,
            options = series.options;


            if (!chart.naviigator) {
                drawSSGridNavButton(chart);
            }

            // the group
            if (!series.group) {
                group = series.group = renderer.g('series');


                group.attr({
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    zIndex: options.zIndex
                })
                .translate(chart.plotLeft, chart.plotTop)
                .add(chart.seriesGroup);

            }

            this.drawPoints();

            this.drawDataLabels();

            if (series.visible) {
                chart.currentSeriesIndex = series.index;
                if (chart.naviigator) {
                    placeNaviGator(chart);
                }
            }

            if (series.options.animation && series.animate) {
                series.animate();
            }

            series.isDirty = false; // means data is in accordance with what you see
        },

        drawDataLabels: function() {

        },

        drawTracker: function () {

        },
        animate: function(init) {

        }

    });

    // 4 - add the constractor
    seriesTypes.ssgrid = SSGrid;





    /*********************************
     *         Radar Series          *
     *********************************/


    //helper function to draw rhe rader axis
    ////sunction to draw the radar graph
    var plotRadarAxis = function () {
        var chart = this,
        options = chart.options,
        radarAxis = chart.radarAxis,
        categoriesLN = radarAxis.catLength,
        renderer = chart.renderer,
        i,
        CX = chart.plotWidth / 2,
        CY = chart.plotHeight / 2,
        radius = radarAxis.radius,
        xAxis = radarAxis.xAxis,
        yAxis = radarAxis.yAxis,
        plotLines = yAxis.plotLines,
        xPlotLines = xAxis.plotLines,
        yMin = yAxis.min,
        xTrans = radarAxis.xTrans,
        startAngle = radarAxis.startAngle,
        axPath = [],
        borderPath = [M],
        numdivPath = [],
        numDiv = plotLines.length,
        yTrans = radarAxis.yTrans,
        first,
        j, Px, Py, length,
        str, value, angle,
        math2PI = math.PI * 2,
        mathPIBY2 = math.PI / 2,
        math3PIBY2 = math.PI + mathPIBY2,
        modAngle,
        positionIndex,
        labelAlign = ['right', 'center', 'left'],
        tempRad = radius + 10,
        labelOptions = yAxis.labels,
        divLine,
        radarGroup = renderer.g('axis');


        radarGroup.attr({
            zIndex: 2,
            width: chart.plotWidth,
            height: chart.plotHeight
        })
        .translate(chart.plotLeft, chart.plotTop)
        .add();

        radarAxis.divline = [];

        //////draw yaxis labels and divlines


        //create all divline path
        ///also draw the labels for the divline
        for (j = 0; j < numDiv; j += 1) {
            //add the move to
            numdivPath[j] = [M];
            first = true;
            i = categoriesLN;
            divLine = plotLines[j];
            value = divLine.value;
            // do the translation
            while (i --) {
                length = mathAbs(value - yMin) * yTrans;
                Px = CX + (length * mathCos(-(startAngle + (i * xTrans))));
                Py = CY + (length * mathSin(-(startAngle + (i * xTrans))));
                //draw the divline
                numdivPath[j].splice(numdivPath[j].length, 0 , Px, Py);
                if (i == 0) {
                    //draw the yAxis div labels
                    if (divLine.label) {
                        labelOptions = divLine.label
                        str = labelOptions.text;
                        if (str || str === 0) {
                            renderer.text(
                                str,
                                Px,
                                Py
                                )
                            .attr({
                                align: labelOptions.textAlign,
                                rotation: labelOptions.rotation
                            })
                            // without position absolute, IE export sometimes is wrong
                            .css(labelOptions.style)
                            .add(radarGroup);
                        }
                    }
                }
                ///after first move to add the line to
                if (first) {
                    numdivPath[j].push(L);
                    first = false;
                }
            }
            ///close the border
            numdivPath[j].push('Z');
            ///draw the num Div line
            radarAxis.divline[j] = renderer.path(numdivPath[j]).
            attr({
                zIndex: 2,
                'stroke': divLine.color,
                'stroke-width': divLine.width
            }).add(radarGroup);
        }

        //////// draw radarSpike & border //////

        first = true;//set the the first flag for the next loop
        i = xPlotLines.length;
        // draw the axis line
        while (i --) {
            divLine = xPlotLines[i]
            value = divLine.value;
            angle = (startAngle + (value * xTrans));
            modAngle = angle % math2PI;
            Px = CX + (radius * mathCos(- angle));
            Py = CY + (radius * mathSin(-angle));
            ///draw the axis
            axPath.splice(axPath.length, 0 , M, CX, CY, L, Px, Py);
            //draw the border
            borderPath.splice(borderPath.length, 0 , Px, Py);
            if (first) {
                borderPath.push(L);
                first = false;
            }
            //draw the yAxis div labels
            if (divLine.label) {
                labelOptions = divLine.label
                str = labelOptions.text;
                if (str || str === 0) {
                    positionIndex = (modAngle > mathPIBY2 && modAngle < math3PIBY2) ? 0 :
                    ((modAngle == mathPIBY2 || modAngle == math3PIBY2) ? 1 : 2);

                    renderer.text(
                        str,
                        CX + (tempRad * mathCos(- angle)),
                        CY + (tempRad * mathSin(-angle))
                        )
                    .attr({
                        align: labelAlign[positionIndex],
                        rotation: labelOptions.rotation
                    })
                    // without position absolute, IE export sometimes is wrong
                    .css(labelOptions.style)
                    .add(radarGroup);
                }
            }

        }
        ///close the border
        borderPath.push('Z');
        radarAxis.spikeGraph = renderer.path(axPath).
        attr({
            zIndex: 1,
            
            'stroke': xAxis.gridLineColor,
            'stroke-width': pluck(xAxis.gridLineWidth, 1)
        }).add(radarGroup);

        if (xAxis.showRadarBorder) {
            radarAxis.borderGraph = renderer.path(borderPath).
            attr({
                'stroke': xAxis.radarBorderColor,
                'stroke-width': pluck(xAxis.radarBorderThickness, 2),
                'fill': xAxis.radarFillColor
            }).add(radarGroup);
        }

    };



    // 1 - Set default options
    defaultPlotOptions.radar = merge(defaultPlotOptions.area, {
        states: {
            hover: {}
        }
    });

    // 2- Create the floatedcolumn point object

    //// NO code
    // 3 - Create the floatedcolumn series constractor
    var radar = Highcharts.extendClass(seriesTypes.pie, {
        type: 'radar',
        isCartesian: false,
        pointClass : seriesTypes.area.prototype.pointClass,
        pointAttrToOptions : seriesTypes.area.prototype.pointAttrToOptions,
        /**
         * Translate data points from raw data values to chart specific positioning data
         * needed later in drawPoints, drawGraph and drawTracker.
         */
        translate: function() {
            var series = this,
            chart = series.chart,
            data = series.data,
            dataLength = data.length, xTrans,
            yMin, yRange, yTrans, startAngle, centerX,
            centerY;
            if (typeof chart.radarAxis === 'undefined'){
                centerX = chart.plotWidth / 2;
                centerY = chart.plotHeight / 2;

                var options = chart.options,
                xAxis = options.xAxis,
                catLength = (xAxis.max - xAxis.min) + 1,
                yAxis = options.yAxis instanceof Array ? options.yAxis[0] : options.yAxis,
                radius = defined(options.chart.axisRadius) ? options.chart.axisRadius : mathMin(centerX, centerY);
                if (radius < 0 ) {
                    radius = mathMin(centerX, centerY);
                }

                yMin = yAxis.min;
                yRange = mathAbs(yAxis.max - yMin);
                yTrans = radius / yRange;// value to pixel convertation factor
                xTrans = (2 * math.PI) / catLength;//value to angle translation factor
                startAngle = math.PI / 2;

                chart.radarAxis = {};
                chart.radarAxis.yTrans = yTrans;
                chart.radarAxis.xTrans = xTrans;
                chart.radarAxis.yRange = yRange;
                chart.radarAxis.startAngle = startAngle;
                chart.radarAxis.yMin = yMin;
                chart.radarAxis.centerX = centerX;
                chart.radarAxis.centerY = centerY;
                chart.radarAxis.radius = radius;
                chart.radarAxis.categories = [];
                chart.radarAxis.catLength = catLength;
                chart.radarAxis.yAxis = yAxis;
                chart.radarAxis.xAxis = xAxis;
            }
            else {
                centerX = chart.radarAxis.centerX;
                yTrans = chart.radarAxis.yTrans;
                yMin = chart.radarAxis.yMin;
                startAngle = chart.radarAxis.startAngle;
                xTrans = chart.radarAxis.xTrans;
                centerY = chart.radarAxis.centerY;
            }
            // do the translation
            while (dataLength--) {
                var point = data[dataLength],
                //NOTE: null should be y min. but 0 to follow flash
                yValue = defined(point.y) ? point.y : yMin;
                point.plotX = centerX + ((yTrans * mathAbs(yValue - yMin)) * mathCos(-(startAngle + (dataLength * xTrans))));

                point.plotY = centerY + ((yTrans * mathAbs(yValue - yMin)) * mathSin(-(startAngle + (dataLength * xTrans))));
                // set client related positions for mouse tracking
                point.clientX = point.plotX; // for mouse tracking
            }
        },


        /**
         * Draw the actual graph
         */
        drawGraph: function(state) {
            var series = this,
            options = series.options,
            chart = series.chart,
            graph = series.graph,
            graphPath = [],
            group = series.group,
            color = series.color,
            lineWidth = options.lineWidth,
            lineColor = options.lineColor || color,
            fillCOlor = pick(
                options.fillColor,
                Color(color).setOpacity(options.fillOpacity || 0.5).get()
                ),
            segmentPath,
            renderer = chart.renderer,
            singlePoints = []; // used in drawTracker
            if (series.data.length > 1) {
                segmentPath = [];

                // build the segment line
                each(series.data, function(point, i){

                    // moveTo or lineTo
                    if (i < 2) {
                        segmentPath.push([M, L][i]);
                    }

                    // normal line to next point
                    segmentPath.push(
                        point.plotX,
                        point.plotY
                        );
                });
                segmentPath.push('Z');
                graphPath = graphPath.concat(segmentPath);

            } else {
                singlePoints.push(series.segment[0][0]);
            }
            // used in drawTracker:
            series.graphPath = graphPath;
            series.singlePoints = singlePoints;

            // draw the graph
            if (graph) {
                graph.attr({
                    d: graphPath
                });
            } else {
                series.graph = renderer.path(graphPath).
                attr({
                    'stroke': lineColor,
                    'fill': fillCOlor,///hard coded alpha for the radar
                    'stroke-width': lineWidth + PX
                }).add(group).shadow();
            }

        },

        /**
         * Create individual tracker elements for each point
         */
        //drawTracker: ColumnSeries.prototype.drawTracker,
        drawTracker: function() {
            var series = this,
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            graphic;

            each(series.data, function(point) {
                graphic = point.graphic;
                if (graphic) { // doesn't exist for null points
                    graphic
                    .attr({
                        isTracker: true
                    })
                    .on('mouseover', function(event) {
                        series.onMouseOver();
                        point.onMouseOver();
                    })
                    .on('mouseout', function(event) {
                        if (!series.options.stickyTracking) {
                            series.onMouseOut();
                        }
                    })
                    .css(css);
                }
            });

        },
        setVisible: function(vis, redraw) {
            var series = this,
            chart = series.chart,
            legendItem = series.legendItem,
            seriesGroup = series.group,
            seriesTracker = series.tracker,
            dataLabelsGroup = series.dataLabelsGroup,
            /**^
             * add hiding of shadow groups
             */
            shadowGroup = series.shadowGroup,
            /*EOP^*/
            showOrHide,
            i,
            data = series.data,
            point,
            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
            oldVisibility = series.visible;

            // if called without an argument, toggle visibility
            series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? 'show' : 'hide';

            // show or hide series
            if (seriesGroup) { // pies don't have one
                seriesGroup[showOrHide]();
            }

            /**^
             * Especially show hide shadow group that are drawn outside the
             * group
             */

            if (shadowGroup && shadowGroup.floated) {
                shadowGroup[showOrHide]();
            }
            /* EOP ^*/

            // show or hide trackers

            i = data.length;
            while (i--) {
                point = data[i];
                if (point.graphic) {
                    point.graphic[showOrHide]();
                }
            }


            if (dataLabelsGroup) {
                dataLabelsGroup[showOrHide]();
            }

            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }


            // rescale or adapt to resized chart
            series.isDirty = true;
            // in a stack, all other series are affected
            if (series.options.stacking) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }

            fireEvent(series, showOrHide);
        },
        getColor: seriesTypes.area.prototype.getColor,
        //drawPoints: function() {},
        drawDataLabels: seriesTypes.area.prototype.drawDataLabels,
        animate : function () {},
        getSymbol : seriesTypes.area.prototype.getSymbol,
        drawPoints : function () {
            var series = this,
            pointAttr,
            data = series.data,
            chart = series.chart,
            plotX,
            plotY,
            i,
            point,
            radius,
            graphic;

            if (series.options.marker.enabled) {
                i = data.length;
                while (i--) {
                    point = data[i];
                    plotX = point.plotX;
                    plotY = point.plotY;
                    graphic = point.graphic;

                    // only draw the point if y is defined
                    if (plotY !== UNDEFINED && !isNaN(plotY)) {
                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        radius = pointAttr.r;
                        if (graphic) { // update
                            graphic.animate({
                                x: plotX,
                                y: plotY,
                                r: radius
                            });
                        } else {
                            point.graphic = chart.renderer.symbol(
                                pick(point.marker && point.marker.symbol, series.symbol),
                                plotX,
                                plotY,
                                radius
                                )
                            .attr(pointAttr)
                            .add(chart.trackerGroup || series.group);
                        }
                    }
                }
            }

        },
        rotate : function () {},
        /**
         * Render the graph and markers
         */
        render: function() {
            var series = this,
            chart = series.chart,
            group,
            options = series.options,
            animation = options.animation,
            doAnimation = animation && series.animate,
            duration = doAnimation ? (animation && animation.duration) || 500 : 0,
            cliprectX, cliprectY, cliprectW, cliprectH,
            renderer = chart.renderer,clipRect = series.clipRect;


            // Add plot area clipping rectangle. If this is before chart.hasRendered,
            // create one shared clipRect.
            if (!clipRect) {
                cliprectX = -chart.plotLeft;
                cliprectY = -chart.plotTop;
                cliprectW = chart.chartWidth;
                cliprectH = chart.chartHeight;
                clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
                chart.clipRect :
                renderer.clipRect(cliprectX, cliprectY, cliprectW, cliprectH);
                clipRect.cliprectX = cliprectX;
                clipRect.cliprectY = cliprectY;
                clipRect.cliprectW = cliprectW;
                clipRect.cliprectH = cliprectH;

                if (!chart.clipRect) {
                    chart.clipRect = series.clipRect;
                }
            }

            ///draw the axis once only
            if (chart.drawRadarAxis !== true) {
                plotRadarAxis.call(chart);
                chart.drawRadarAxis = true;///flag to draw the radar garh for the first series
            }

            // the group
            if (!series.group) {
                group = series.group = renderer.g('series');

                if (chart.inverted) {
                    group.attr({
                        width: chart.plotWidth,
                        height: chart.plotHeight
                    }).invert();
                }
                group.clip(series.clipRect)
                .attr({
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    zIndex: 3
                })
                .translate(chart.plotLeft, chart.plotTop)
                .add(chart.seriesGroup);
            }


            series.drawDataLabels();

            // initiate the animation
            if (doAnimation) {
                series.animate(true);
            }


            // draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
            }

            // draw the points
            series.drawPoints();

            // draw the mouse tracking area
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }

            // run the animation
            if (doAnimation) {
                series.animate();
            }

            // finish the individual clipRect
            setTimeout(function() {
                clipRect.isAnimating = false;
                group = series.group; // can be destroyed during the timeout
                if (group && clipRect !== chart.clipRect && clipRect.renderer) {
                    group.clip((series.clipRect = chart.clipRect));
                    clipRect.destroy();
                }
            }, duration);

            series.isDirty = false; // means data is in accordance with what you see

        }
    });

    // 4 - add the constractor
    seriesTypes.radar = radar;









    ///////////////// Column 3d series ////////////////

    /* ****************************************************************************
     * Start floatedcolumn series code                                            *
     *****************************************************************************/

    // 1 - Set default options
    defaultPlotOptions.column3d = merge(defaultPlotOptions.column, {
        states: {
            hover: {
        }
        }
    });









    //// NO code

    // 3 - Create the floatedcolumn series constractor
    var column3d = Highcharts.extendClass(seriesTypes.column, {
        type: 'column3d',

        //this function will called onece for a chart
        //this function will create the groups for column3d series
        initGroup : function () {
            // 3d effect as predifined to 15*15
            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            xdepth = series.xDepth,
            ydepth = series.yDepth,
            zeroPlaneColor,
            options = series.options,
            zeroPlaneBorderColor,
            zeroplanewidth,
            xdisp,
            ydisp,
            group,
            yAxis = series.yAxis;

            // the group
            if (!chart.column3DGroups) {
                group = chart.column3DGroups = renderer.g('series-3d');
                group.translate(chart.plotLeft - xdepth, chart.plotTop + ydepth)
                .add(chart.seriesGroup);

            }


            if (yAxis.options.min < 0 && yAxis.options.max >= 0) {
                zeroPlaneColor = chart.options.chart.zeroPlaneColor;
                zeroPlaneBorderColor = chart.options.chart.zeroPlaneBorderColor;
                xdisp = 0;
                ydisp = yAxis.translate(0, 0, 1);
                var shapeH = 1, shapeW = chart.plotSizeX;
                if (chart.inverted) {
                    var tmp;
                    tmp = shapeH;
                    shapeH = shapeW;
                    shapeW = tmp;
                    xdisp = chart.plotSizeY - ydisp - shapeW;
                    ydisp = 0;

                }
                yAxis.zeroPlane = renderer.rect3d(xdisp, ydisp, shapeW, shapeH,
                    xdepth, ydepth, 1,  'zeroPlane')
                .attr({
                    fill : zeroPlaneColor,
                    stroke : zeroPlaneBorderColor,
                    'stroke-width' : 1,
                    zIndex : 2
                }).add(group);
            }

        },
        drawNthPoint : function (position) {
            // 3d effect as predifined to 15*15
            var series = this, chart = series.chart,
            group = chart.column3DGroups,
            renderer = chart.renderer, xDepth = series.xDepth, yDepth = series.yDepth,
            point = series.data[position], x2D, y2D;
            var plotY = point.plotY, shapeArgs, color, graphic, borderWidth,
            shapeX, shapeY, shapeH, shapeW, borderColor;
            if (plotY !== UNDEFINED && !isNaN(plotY)) {
                shapeArgs = point.shapeArgs;
                color = point.color;
                borderColor = point.borderColor;
                borderWidth = point.borderWidth;
                //borderObj = point.borderColor;
                graphic = point.graphic;
                x2D = parseInt(shapeArgs.x, 10);
                y2D = parseInt(shapeArgs.y, 10);
                shapeX = x2D;
                shapeY = y2D;
                shapeH = parseInt(shapeArgs.height, 10);
                shapeW = parseInt(shapeArgs.width, 10);

                if (series.options.enableMouseTracking !== false) {
                    var tracX2D = x2D - xDepth,
                    tracY2D = y2D + yDepth;
                    point.trackerArgs = [M, tracX2D, tracY2D, L, tracX2D, tracY2D + shapeH,
                    tracX2D + shapeW, tracY2D + shapeH, tracX2D + shapeW + xDepth, tracY2D + shapeH - yDepth,
                    tracX2D + shapeW + xDepth, tracY2D - yDepth, tracX2D + xDepth, tracY2D - yDepth, 'Z']
                    series.drawTracker(position);
                }

                if (chart.inverted) {
                    var tmp;
                    tmp = shapeH;
                    shapeH = shapeW;
                    shapeW = tmp;
                    shapeX = chart.plotSizeY - y2D - shapeW;
                    shapeY = chart.plotSizeX - x2D - shapeH;

                }

                if (graphic) { 
                    renderer.attr({
                        x: shapeX,
                        y: shapeY,
                        width: shapeW,
                        height: shapeH,
                        x3D: xDepth,
                        y3D: yDepth,
                        strokeWidth: borderWidth,
                        fill: color,
                        stroke : borderColor,
                        zIndex  : point.y >= 0 ? 3 : 1
                    });
                } else {
                    point.graphic = renderer.rect3d(shapeX, shapeY, shapeW, shapeH,
                        xDepth, yDepth, borderWidth,  'point').attr({
                        fill: color,
                        stroke : borderColor,
                        zIndex  : point.y >= 0 ? 3 : 1
                    }).

                    add(group);
                    point.graphic.shadow(series.options.shadow, undefined, point.shadow);
                }



            }
        },






        /**
	 * Render the graph and markers
	 */
        render: function() {
            var series = this,
            options = series.options,
            animation = options.animation,
            doAnimation = animation && series.animate;

            series.drawDataLabels();

            // initiate the animation
            if (doAnimation) {
                series.animate();
            }

            series.isDirty = false; // means data is in accordance with what you see

        },
        /**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
        animate: function(init) {
            var series = this,
            data = series.data,
            chart = series.chart,
            shapeW, shapeX;

            if (!init) { // run the animation
                /*
                 * Note: Ideally the animation should be initialized by calling
                 * series.group.hide(), and then calling series.group.show()
                 * after the animation was started. But this rendered the shadows
                 * invisible in IE8 standards mode. If the columns flicker on large
                 * datasets, this is the cause.
                 */

                each(data, function(point) {
                    var graphic = point.graphic;

                    if (graphic) {
                        if (chart.inverted) {
                            shapeW = graphic.attr('width');
                            shapeX = graphic.attr('x');
                            graphic.attr({
                                x: chart.plotSizeY - series.yAxis.getThreshold(series.options.threshold || 0),
                                width : 0
                            });

                            // animate
                            graphic.animate({
                                x : shapeX,
                                width : shapeW
                            }, series.options.animation);

                        }
                        else {
                            // start values
                            graphic.attr({
                                height: 0,
                                y: series.yAxis.getThreshold(series.options.threshold || 0)
                            });

                            // animate
                            graphic.animate({
                                height: point.barH,
                                y: point.barY
                            }, series.options.animation);
                        }
                    }
                });


                // delete this function to allow it only once
                series.animate = null;
            }

        },

        drawTracker: function(position) {
            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            shapeArgs,
            tracker,
            trackerLabel = +new Date(),
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            rel,
            point = series.data[position];
            tracker = point.tracker;

            //clip for scroll
            /**^
             *
             */
            if (chart.options.chart.hasScroll) {
                chart.trackerGroup.clip(series.clipRect);
            }
            /*EOP^*/

            shapeArgs = point.trackerArgs || point.shapeArgs;
            if (point.y !== null) {
                if (tracker) {// update
                    tracker.attr(shapeArgs);

                } else {
                    if (point.link !== undefined) {
                        css = {
                            cursor : 'pointer'
                        };
                    }
                    point.tracker =
                    renderer.path(shapeArgs)
                    .attr({
                        isTracker: trackerLabel,
                        fill: TRACKER_FILL,
                        visibility: series.visible ? VISIBLE : HIDDEN,
                        zIndex: point.y > 0 ? -1 : -3 //3d traker must be below other traker
                    })
                    .on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
                        rel = event.relatedTarget || event.fromElement;
                        if (chart.hoverSeries != series && attr(rel, 'isTracker') != trackerLabel) {
                            series.onMouseOver();
                        }
                        point.onMouseOver();

                    })
                    .on('mouseout', function(event) {
                        if (!series.options.stickyTracking) {
                            rel = event.relatedTarget || event.toElement;
                            if (attr(rel, 'isTracker') != trackerLabel) {
                                series.onMouseOut();
                            }
                        }
                    })
                    .css(css)
                    .add(chart.trackerGroup);
                }
            }

        },
        /**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *        the visibility is toggled.
	 */
        setVisible: function(vis, redraw) {
            var series = this,
            chart = series.chart,
            legendItem = series.legendItem,
            dataLabelsGroup = series.dataLabelsGroup,
            showOrHide,
            i,
            data = series.data,
            point,
            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
            oldVisibility = series.visible;

            // if called without an argument, toggle visibility
            series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? 'show' : 'hide';
            i = data.length;
            while (i--) {
                point = data[i];
                if (point.tracker) {
                    point.tracker[showOrHide]();
                }
                if (point.graphic) {
                    point.graphic[showOrHide]();
                }
            }



            if (dataLabelsGroup) {
                dataLabelsGroup[showOrHide]();
            }

            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }


            // rescale or adapt to resized chart
            series.isDirty = true;
            // in a stack, all other series are affected
            if (series.options.stacking) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }

            fireEvent(series, showOrHide);
        }
    });

    // 4 - add the constractor
    seriesTypes.column3d = column3d;

    //////////bae 3d series

    // 1 - Set default options
    defaultPlotOptions.bar3d = merge(defaultPlotOptions.bar, {
        states: {
            hover: {}
        }
    });

    var BarSeries3d = Highcharts.extendClass(column3d, {
        type: 'bar3d',
        init: function(chart) {
            chart.inverted = this.inverted = true;
            seriesTypes.column.prototype.init.apply(this, arguments);
        }
    });
    seriesTypes.bar3d = BarSeries3d;


    //////////Bubble series

    // 1 - Set default options
    defaultPlotOptions.bubble = merge(defaultPlotOptions.scatter, {
        states: {
            hover: {}
        }
    });

    var Bubble = Highcharts.extendClass(seriesTypes.scatter, {
        type: 'bubble',

        /**
         * Draw the markers
         */
        drawPoints: function(){
            var series = this,
            pointAttr,
            data = series.data,
            chart = series.chart,
            plotX,
            plotY,
            i,
            point,
            radius,
            graphic,

            canvasWidth = series.chart.plotWidth,
            canvasHeight = series.chart.plotHeight,
            maxZ = series.options.zMax,
            bubbleScale = series.options.bubbleScale,
            radiusLimit, sqrtMaxZ, sqrtBubbleZ, bubbleRadius;

            // to have diameter of the largest bubble as 25% of the smaller of the two dimensions of canvas
            radiusLimit = ((canvasWidth > canvasHeight) ? canvasHeight : canvasWidth) / 8;
            // taking square root of the maximum z-value of all bubbles
            sqrtMaxZ = Math.sqrt (maxZ);





            if (series.options.marker.enabled) {
                i = data.length;
                while (i--) {
                    point = data[i];
                    plotX = point.plotX;
                    plotY = point.plotY;
                    graphic = point.graphic;

                    // only draw the point if y is defined
                    if (plotY !== UNDEFINED && !isNaN(plotY)) {

                        /* && removed this code because points stayed after zoom
						point.plotX >= 0 && point.plotX <= chart.plotSizeX &&
						point.plotY >= 0 && point.plotY <= chart.plotSizeY*/

                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];

                        // taking square root of the z-value of the bubble
                        sqrtBubbleZ = Math.sqrt (point.z);
                        // calculating radius with scaling
                        bubbleRadius = Math.round (sqrtBubbleZ * radiusLimit / sqrtMaxZ) * bubbleScale;

                        pointAttr.r = radius = bubbleRadius;

                        if (graphic) { // update
                            graphic.animate({
                                x: plotX,
                                y: plotY,
                                r: radius
                            });
                        } else {
                            point.graphic = chart.renderer.symbol(
                                pick(point.marker && point.marker.symbol, series.symbol),
                                plotX,
                                plotY,
                                radius
                                )
                            .attr(pointAttr)
                            .add(series.group);
                        }
                    }
                }
            }

        }
    });
    seriesTypes.bubble = Bubble;



    /**
    * CandleStick chart
    */
    // 1 - Set default options
    defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {
        states: {
            hover: {}
        }
    });
    //
    var candleStick = Highcharts.extendClass(seriesTypes.column, {
        type: 'candlestick',

        /**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
        drawPoints: function() {

            var series = this,
            options = series.options,
            renderer = series.chart.renderer,
            graphic,
            shapeArgs,
            attributes;

            // draw the columns
            each (series.data, function(point) {

                if (defined(point.plotY)) {
                    graphic = point.graphic;
                    shapeArgs = point.shapeArgs;
                    if (graphic) { // update
                        graphic.attr(shapeArgs);
                    } else {
                        //Changed for FC
                        //draw the error bar
                        attributes = {
                            stroke: point.borderColor,
                            fill: point.color,
                            'stroke-width': point.borderWidth,
                            'stroke-linecap': 'round',
                            dashstyle: point.dashStyle
                        };

                        if (point.bar) {
                            point.bar.graphic = renderer[point.bar.shapeType](point.bar.shapeArgs)
                            .attr(attributes)
                            .add(series.group)
                            .shadow(options.shadow, undefined, options.shadow);
                        }

                        if (shapeArgs) {
                            point.graphic = renderer[point.shapeType](shapeArgs)
                            .attr(attributes)
                            .add(series.group)
                            .shadow(options.shadow, undefined, options.shadow);
                        }
                    }
                }
            });
        },

        /**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
        translate: function() {

            var series = this,
            chart = series.chart,
            columnCount = 0,
            reversedXAxis = series.xAxis.reversed,
            categories = series.xAxis.categories,
            stackedIndex, // the index of the first column in a stack
            pricetype = series.options.plotType;
            Series.prototype.translate.apply(series);

            // Get the total number of column type series.
            // This is called on every series. Consider moving this logic to a
            // chart.orderStacks() function and call it on init, addSeries and removeSeries
            each (chart.series, function(otherSeries) {
                if (otherSeries.type == series.type) {
                    if (!otherSeries.options.stacking) {
                        otherSeries.columnIndex = columnCount++;
                    } else {
                        if (!defined(stackedIndex)) {
                            stackedIndex = columnCount++;
                        }
                        otherSeries.columnIndex = stackedIndex;
                    }
                }
            });


            // calculate the width and position of each column based on
            // the number of column series in the plot, the groupPadding
            // and the pointPadding options
            var options = series.options, i, point, pointPrev,
            data = series.data,
            closestPoints = series.closestPoints,
            categoryWidth = mathAbs(
                data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX :
                chart.plotSizeX / (categories && categories.length ? categories.length : 1)
                ),
            groupPadding = categoryWidth * options.groupPadding,
            groupWidth = categoryWidth - 2 * groupPadding,
            pointOffsetWidth = groupWidth / columnCount,
            optionPointWidth = options.pointWidth,
            pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
            pointOffsetWidth * options.pointPadding,
            pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding),
            columnIndex = (reversedXAxis ? columnCount -
                series.columnIndex : series.columnIndex) || 0,
            pointXOffset = pointPadding + (groupPadding + columnIndex *
                pointOffsetWidth -(categoryWidth / 2)) *
            (reversedXAxis ? -1 : 1),
            translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
            minPointLength = options.minPointLength;

            // record the new values
            //Changed For FC:AP
            //MX xy supplyed by FC
            //MWidth width supplyed by FC
            //MY highest point for stacked point from FC
            for (i = 0; i < data.length; i += 1) {
                point = data[i];

                if (pricetype == 'line') {
                    if (i > 0) {
                        pointPrev = data[i -1];
                        pointPrev.shapeType = 'path';
                        pointPrev.shapeArgs = [M, pointPrev.plotX, pointPrev.plotY, L, point.plotX, point.plotY ]
                    }

                    point.trackerShapeType = 'rect';
                    point.trackerArgs = {
                        x: point.plotX - 3,
                        y: point.plotY - 3,
                        width: 6,
                        height: 6
                    };

                }
                else {
                    var barX = point.plotX + pointXOffset,
                    plotY = point.plotY,
                    plotY1 = series.yAxis.getThreshold(point.MY),
                    barY = mathCeil(mathMin(plotY, plotY1)),
                    barH = mathCeil(mathAbs(plotY - plotY1)),
                    barW = pointWidth, barWhlf = barW / 2,
                    trackerY;

                    // handle options.minPointLength and tracker for small points
                    if (barH < (minPointLength || 5)) {
                        if (minPointLength) {
                            barH = minPointLength;
                            barY = translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
                        }
                        trackerY = barY - 3;
                    }

                    if (barH < 1) {
                        barH = 1;
                    }

                    extend (point, {
                        barX: barX,
                        barY: barY,
                        barW: barW,
                        barH: barH
                    });

                    if (pricetype == 'bar') {
                        point.trackerShapeType = 'rect';
                        point.shapeType = 'path';
                        point.shapeArgs = [M, point.plotX, plotY1, L, (point.plotX - barWhlf), plotY1, M, point.plotX, plotY, L, (point.plotX + barWhlf), plotY];
                        // make small columns responsive to mouse
                        point.trackerArgs = {
                            x: barX,
                            y: defined(trackerY) ? trackerY : barY,
                            width: barW,
                            height: defined(trackerY) ? 6 : barH
                        };
                    }
                    else {
                        point.shapeType = 'rect';
                        point.shapeArgs = {
                            x: barX,
                            y: barY,
                            width: barW,
                            height: barH,
                            r: options.borderRadius
                        };
                        point.trackerShapeType = 'rect';
                        // make small columns responsive to mouse
                        point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
                            height: 6,
                            y: trackerY
                        });
                    }

                    //draw the high low graph
                    point.bar = {
                        shapeType: 'path',
                        shapeArgs: [M, point.plotX, series.yAxis.getThreshold(parseFloat(point.high)), L, point.plotX, series.yAxis.getThreshold(parseFloat(point.low))]
                    };

                }
            }
        },
        drawTracker: function () {

            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            shapeArgs,
            tracker,
            trackerLabel = +new Date(),
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            rel;


            each(series.data, function(point) {
                tracker = point.tracker;
                shapeArgs = point.trackerArgs;
                delete shapeArgs.strokeWidth;
                if (point.y !== null) {
                    if (tracker) {// update
                        tracker.attr(shapeArgs);

                    }else {
                        //Add cursor pointer if there has link
                        //modify the parent scope css variable with a local variable
                        if (point.link !== undefined) {
                            var css = {
                                cursor : 'pointer',
                                '_cursor': 'hand'
                            };
                        }
                        point.tracker =
                        renderer[point.trackerShapeType](shapeArgs)
                        .attr({
                            isTracker: trackerLabel,
                            fill: TRACKER_FILL,
                            visibility: series.visible ? VISIBLE : HIDDEN,
                            zIndex: 1
                        })
                        .on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
                            rel = event.relatedTarget || event.fromElement;
                            if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
                                series.onMouseOver();
                            }
                            point.onMouseOver();

                        })
                        .on('mouseout', function(event) {
                            if (!series.options.stickyTracking) {
                                rel = event.relatedTarget || event.toElement;
                                if (attr(rel, 'isTracker') !== trackerLabel) {
                                    series.onMouseOut();
                                }
                            }
                        })
                        .css(css)
                        .add(point.group || chart.trackerGroup); // pies have point group - see issue #118
                    }
                }
            });
        }

    });

    // 4 - add the constractor
    seriesTypes.candlestick = candleStick;


    /**
     * Dragnode chart
     */
    // 1 - Set default options


    ///function to add the arrow point
    function drawArrow (X1, Y1, X2, Y2, R, H) {
        var tanganent = (Y1 - Y2) / (X1 - X2),
        angle = math.atan(tanganent),
        PX, PY, RHlf, HHlf,
        arr = [];


        //make all angle as positive
        if (angle < 0) {
            angle = (2 * math.PI) + angle
        }
        if (Y2 > Y1) {///PI >angle > 0
            if ((X2 >= X1 && angle > math.PI) || (X2 < X1 && angle > math.PI)) {
                angle = angle - math.PI;
            }
        }
        else {/// PI <= angle < 360 || angle == 0
            //angle may not be 360 in that case it will be 0 as atan work
            if ((X2 >= X1 && angle < math.PI && angle != 0) || (X2 < X1 && angle < math.PI)) {
                angle = angle + math.PI;
            }
        }

        if (typeof H == 'undefined') {
            ///arrow start point
            PX = X1 + (R * mathCos(angle));
            PY = Y1 + (R * mathSin(angle));
        }
        else {///rectangle
            RHlf = mathAbs(R) / 2;
            HHlf = mathAbs(H) / 2;

            //asume it will intersect a vertical side
            PX = X1 + (RHlf = X1 < X2 ? RHlf : -RHlf);
            PY = Y1 + (RHlf * math.tan(angle));
            //validate PY
            //if not validate then it will cross the horizontal axis
            if (mathAbs(Y1 - PY) > mathAbs(HHlf)) {
                PY = Y1 + (HHlf = Y1 < Y2 ? HHlf : -HHlf);
                PX = X1 + (HHlf / math.tan(angle));
            }
        }

        arr.push(M);
        ///arrowone half
        arr.push(PX + (10 * mathCos(angle + 0.79)));
        arr.push(PY + (10 * mathSin(angle + 0.79)));
        //return to th eedege
        arr.push(L);
        arr.push(PX);
        arr.push(PY);
        ///arrowone half
        arr.push(PX + (10 * mathCos(angle - 0.79)));
        arr.push(PY + (10 * mathSin(angle - 0.79)));


        return arr;
    }

    // store the points by its point id.
    var pointStore = {};

    defaultPlotOptions.dragnode = merge(defaultPlotOptions.scatter, {
        states: {
            hover: {}
        }
    });
    //
    var DragNode = Highcharts.extendClass(seriesTypes.scatter, {
        type: 'dragnode',
        /**
         * Draw the markers
         */
        drawPoints: function() {
            var series = this,
            pointAttr,
            data = series.data,
            chart = series.chart,
            options = series.options,
            pointOptions,
            plotX,
            plotY,
            i,
            point,
            radius,
            graphic, id, width, height, marker, symbol,
            chartOptions =  chart.options,
            connectors = chartOptions.connectors,
            renderer = chart.renderer,
            style = options.dataLabels.style,
            imageNode, imageURL, imageAlign, imageWidth, imageHeight,
            imageNodeGroup, plotWidth, plotHeight, strokeWidth;

            if (series.options.marker.enabled) {
                i = data.length;

                while (i--) {
                    point = data[i];
                    pointOptions = point.options;
                    plotX = point.plotX;
                    plotY = point.plotY;
                    graphic = point.graphic;
                    marker =  point.marker;
                    height =  pluckNumber(marker && marker.height);
                    width =  pluckNumber(marker && marker.width);
                    radius =  pluckNumber(marker && marker.radius);
                    symbol =  pluck(marker && marker.symbol);
                    id = point.id;
                    imageNode = pointOptions.imageNode;
                    imageURL = pointOptions.imageURL;
                    imageAlign = pointOptions.imageAlign; //TOP, MIDDLE or BOTTOM
                    plotWidth = symbol == 'square' ? width : radius * 1.5;
                    imageWidth = pluckNumber(pointOptions.imageWidth, plotWidth);
                    plotHeight = symbol == 'square' ? height : radius * 1.5;
                    imageHeight = pluckNumber(pointOptions.imageHeight, plotHeight);
                    strokeWidth =  pluck(marker && marker.lineWidth);

                    // only draw the point if y is defined
                    if (plotY !== UNDEFINED && !isNaN(plotY)) {

                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        pointAttr.r = pointAttr.r * 1;
                        radius = pointAttr.r;

                        if (graphic) { // update
                            graphic.animate({
                                x: plotX,
                                y: plotY,
                                r: radius
                            });
                        } else {
                            symbol = pick(marker && marker.symbol, series.symbol);

                            if (symbol == 'square') {
                                point.graphic = renderer.rect(
                                    plotX - (width / 2),
                                    plotY - (height / 2),
                                    width,
                                    height
                                    )
                                .attr(pointAttr)
                                .add(series.group);
                            } else {
                                
                                symbol = symbol === 'triangle' ? 'poly_3' : symbol;
                                symbol = symbol === 'diamond' ? 'poly_4' : symbol;
                                point.graphic = renderer.symbol(
                                    symbol,
                                    plotX,
                                    plotY,
                                    radius
                                    )
                                .attr(pointAttr)
                                .add(series.group);
                            }

                            pointStore[id] = point;
                        }

                        // Draw the imageNode if available
                        if (imageNode && imageURL) {
                            var imageY;

                            switch (imageAlign) {
                                case 'middle' :
                                    imageY = plotY - (imageHeight / 2);
                                    break;
                                case 'bottom' :
                                    imageY = plotHeight > imageHeight ? plotY - imageHeight + plotWidth / 2 : plotY - imageHeight / 2;
                                    break;
                                default :
                                    imageY = plotHeight > imageHeight ? plotY - plotWidth / 2 : plotY - imageHeight / 2;
                                    break;
                            }

                            if (!imageNodeGroup) {
                                imageNodeGroup = renderer.g('group').attr({
                                    visibility: HIDDEN
                                })
                                .add();
                            }

                            point.imageNodeGraph = renderer.image(imageURL)
                            .attr({
                                width: imageWidth,
                                height: imageHeight
                            })
                            .translate(plotX - (imageWidth / 2), imageY)
                            .css({
                                opacity : 1
                            })
                            .add(series.group);
                        }
                    }
                }


                // Drawing the connectors and connectors Labels
                var fromId, toId, label, fromY, fromX, toX, toY, path, connectorsGroup,
                color, labelX, labelY, fromPointObj, toPointObj, fromMarker,
                toMarker, arrowPath, textBgColor;

                for (i = 0; i < connectors.length; i += 1) {
                    if (!connectorsGroup) {
                        connectorsGroup = renderer.g('connectors')
                        .attr({
                            visibility: VISIBLE
                        })
                        .translate(chart.plotLeft, chart.plotTop)
                        .add();
                    }
                    each (connectors[i].connector, function (connector) {
                        fromId = connector.from;
                        toId = connector.to;
                        label = connector.label;
                        strokeWidth = (connector.conStrength * connector.stdThickness);
                        color = connector.color;
                        label = connector.label;
                        fromPointObj = pointStore[fromId];
                        toPointObj = pointStore[toId];

                        if (fromPointObj && toPointObj) {
                            fromY = fromPointObj.plotY;
                            fromX = fromPointObj.plotX;
                            toY = toPointObj.plotY;
                            toX = toPointObj.plotX;
                            fromMarker = fromPointObj.marker;
                            toMarker = toPointObj.marker;
                            labelX = (fromX + toX) / 2;
                            labelY = (fromY + toY) / 2;

                            path = [M, fromX, fromY, L, toX, toY];

                            series.connector = renderer.path(path)
                            .attr({
                                'stroke-width': strokeWidth,
                                stroke: color
                            })
                            .add(connectorsGroup);

                            arrowPath = [];

                            if (connector.arrowAtStart) {
                                if(fromMarker.symbol == 'square') {
                                    radius = fromMarker.width;
                                    H = fromMarker.height;
                                } else {
                                    radius = fromMarker.radius;
                                    H = undefined;
                                }
                                arrowPath = arrowPath.concat(drawArrow(fromX, fromY, toX, toY, radius, H));
                            }

                            // Calculating path for connector Arrow
                            if (connector.arrowAtEnd) {
                                if(toMarker.symbol == 'square') {
                                    radius = toMarker.width;
                                    H = toMarker.height;
                                } else {
                                    radius = toMarker.radius;
                                    H = undefined;
                                }
                                arrowPath = arrowPath.concat(drawArrow(toX, toY, fromX, fromY, radius, H));
                            }

                            // Drawing connector Arrow
                            if (arrowPath.length) {
                                renderer.path(arrowPath)
                                .attr({
                                    'stroke-width': strokeWidth,
                                    stroke: color
                                })
                                .add(connectorsGroup);
                            }

                            // Drawing the connector Label
                            // Fix for IE textBgColor
                            textBgColor = color && color.FCcolor && color.FCcolor.color;
                            point.connectorText = renderer.text(label,labelX, labelY)
                            .attr({
                                align: 'center',
                                rotation: 0
                            })
                            .css(style)
                            .css({
                                backgroundColor: textBgColor,
                                borderColor: textBgColor
                            })
                            .add(connectorsGroup)
                            .textBound();
                        }

                    })
                }
                // End drawing connectors
            }
        }


    });

    // 4 - add the constractor
    seriesTypes.dragnode = DragNode;




    /* ****************************************************************************
     * Start stepzoom series code                                                   *
     *****************************************************************************/

    // 1 - Set default options
    defaultPlotOptions.stepzoom = merge(defaultPlotOptions.line, {
        states: {
            hover: {}
        }
    });

    var subsetStartIndex, subsetEndIndex, numItems, zoomHistory = [],
    subsetStep, scrollPaneSize;

    /**
	 * Sets the subset indexes. It's based on these indexes that the
	 * chart subset is drawn.
	 * @param	startIndex		Starting index of subset
	 * @param	endIndex		Ending index of subset
	*/
    var chartStepZoomScroll = function (pos, animation, resetTooltip) {
        if (pos <= 0.01) {
            pos = 0;
        }
        var chart = this,
        stepZoom = chart.stepZoom,
        series = chart.series,
        width = chart.plotWidth,
        widthHF = width / 2,
        sLn = series.length,
        scrollPosition = pluckNumber(pos, stepZoom.scrollPosition, 0),
        scrollablePXLength = stepZoom.scrollablePXLength,
        xShift = scrollablePXLength * scrollPosition,
        zoomHistory = stepZoom.zoomHistory[stepZoom.currentZoomLevelIndex],
        seriesStart = zoomHistory.seriesStart,
        firstVisiblePoint = seriesStart + (Math.ceil(xShift / zoomHistory.visiblePointDistance) * zoomHistory.stepping),
        lastVisiblePoint = seriesStart + (Math.floor((xShift + width) / zoomHistory.visiblePointDistance) * zoomHistory.stepping),
        yShift = 0,
        toopTipXShift,
        translateX = 'translateX',
        xStr = 'x',
        i, serie, toolTipX, toolTipY, len, data, point, j,
        newX = chart.plotLeft - xShift, labelClipX, labelEndBBox, labelClipW,
        newY = chart.plotTop - yShift;

        stepZoom.catGroup.attr(translateX, newX);
        chart.trackerGroup.attr(translateX , newX);
        stepZoom.catClipRect.attr(xStr, xShift + stepZoom.catLabelClipXDisplacement);
        if (chart.clipRect) {
            chart.clipRect.attr(xStr, xShift);
        }


        for (i = 0 ; i < sLn; i += 1) {
            serie = series[i];
            //serie.scroll(xShift, yShift, resetTooltip);
            if (serie.group) {
                serie.group.attr(translateX , newX);
            }
            if (serie.dataLabelsGroup) {
                serie.dataLabelsGroup.attr(translateX , newX);
            }
            if (serie.clipRect) {
                serie.clipRect.attr(xStr, xShift);
            }

            if (resetTooltip) {
                toopTipXShift = math.min(20, widthHF);
                data = serie.data;
                len = data.length;
                for (j = 0; j < len; j += 1) {
                    point = data[j];
                    if (point.y !== null && point.tooltipPos) {
                        toolTipX = point.plotX - xShift;
                        if (toolTipX >= 0 && toolTipX <= widthHF) {
                            toolTipX += toopTipXShift;
                        }
                        else if (toolTipX > widthHF && toolTipX <= width) {
                            toolTipX -= toopTipXShift;
                        }
                        point.tooltipPos[0] = toolTipX;
                    }
                }
            }
        }

    }



    // 3 - Create the OHLCSeries object
    var stepZoom = Highcharts.extendClass(seriesTypes.line, {
        type: 'stepzoom',


        /**
         * Translate data points from raw data values to chart specific positioning data
         * needed later in drawPoints, drawGraph and drawTracker.
         */
        translate: function() {
            var series = this,
            chart = series.chart,
            stacking = series.options.stacking,
            categories = series.xAxis.categories,
            yAxis = series.yAxis,
            data = series.data,
            i = data.length;

            // do the translation
            while (i--) {
                var point = data[i],
                xValue = point.x,
                yValue = point.y,
                yBottom = point.low,
                stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
                pointStack,
                pointStackTotal;
                point.plotX = series.xAxis.translate(xValue);

                // calculate the bottom y value for stacked series
                /**^
                 * Removed visibility check of series while calculation
                 *
                 * @code
                 * if (stacking && series.visible && stack && stack[xValue]) {

                 */
                if (stacking && stack && stack[xValue]) {
                    /* EOP ^*/
                    pointStack = stack[xValue];
                    pointStackTotal = pointStack.total;
                    /**^
                     * @source 10098/2.1.4
                     * @code
                     * pointStack.cum = yBottom = pointStack.cum - yValue;
                     */
                    var min = yAxis.options.min;
                    yBottom = pointStack.cum;
                    pointStack.cum +=  yValue; // start from buttom
                    yValue = mathMax(min, yBottom + yValue);
                    yBottom = mathMax(min, yBottom);
                    /* EOP 10098/2.1.4 ^*/

                    if (stacking === 'percent') {
                        yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
                        yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
                    }

                    point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
                    point.stackTotal = pointStackTotal;
                }

                if (defined(yBottom)) {
                    point.yBottom = yAxis.translate(yBottom, 0, 1, 0, 1);
                }

                // set the y value
                if (yValue !== null) {
                    point.plotY = yAxis.translate(yValue, 0, 1, 0, 1);
                }

                // set client related positions for mouse tracking
                point.clientX = chart.inverted ?
                chart.plotHeight - point.plotX :
                point.plotX; // for mouse tracking

                // some API data
                point.category = categories && categories[point.x] !== UNDEFINED ?
                categories[point.x] : point.x;

            }
        },

        /**
         * Draw the markers
         */
        drawPoints: function() {
            var series = this,
            pointAttr,
            data = series.data,
            chart = series.chart,
            options = series.options,
            plotX,
            plotY,
            i,
            point, toolTipX, toolTipY,
            radius,
            graphic,
            width = chart.plotWidth,
            length = data.length,
            displayStartIndex = options.displayStartIndex,
            zoomHistory = chart.stepZoom.zoomHistory[chart.stepZoom.currentZoomLevelIndex],
            perPointPixelDistance = zoomHistory.perPointPixelDistance,
            stepping = zoomHistory.stepping,
            seriesStart = zoomHistory.seriesStart, positionIndex,
            displayEndIndex = options.displayEndIndex;

            numItems = length;


            if (series.options.marker.enabled) {
                i = data.length;
                while (i--) {
                    point = data[i];
                    positionIndex = i - seriesStart;
                    plotX = point.plotX = positionIndex * perPointPixelDistance;
                    plotY = point.plotY;
                    graphic = point.graphic;

                    // only draw the point if y is defined
                    if (plotY !== UNDEFINED && !isNaN(plotY)) {

                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        radius = pointAttr.r;
                        toolTipX = plotX + 20;
                        toolTipY = plotY - 15;
                        toolTipX = toolTipX < 0 ? 0 : toolTipX;
                        toolTipY = toolTipY < 0 ? 0 : toolTipY;
                        point.tooltipPos = [toolTipX, toolTipY];

                        if (graphic) { // update
                            graphic.animate({
                                x: plotX,
                                y: plotY,
                                r: radius
                            });
                        } else {
                            point.graphic = chart.renderer.symbol(
                                pick(point.marker && point.marker.symbol, series.symbol),
                                plotX,
                                plotY,
                                radius
                            )
                            .attr(pointAttr)
                            .add(series.group);
                        }
                        if (positionIndex < 0 || positionIndex % stepping !== 0) {
                            point.graphic.hide();
                        }
                    }
                }
            }

        },

        /**
         * Draw the actual graph
         */
        drawGraph: function(state) {
            var series = this,
            options = series.options,
            chart = series.chart,
            graphPath = [],
            group = series.group,
            color = options.lineColor || series.color,
            lineWidth = options.lineWidth,
            dashStyle =  options.dashStyle,
            renderer = chart.renderer,
            singlePoints = [], // used in drawTracker
            data = series.data,
            connectNullData = options.connectNullData,
            attribs;


            var zoomHistory = chart.stepZoom.zoomHistory[chart.stepZoom.currentZoomLevelIndex],
            i, point, commandIndex = 1, plotX = 0, commandArr = [undefined, M, L], lastMovePoint = [], addMove = true, addLine;

            for (i = zoomHistory.seriesStart; i < data.length; i += zoomHistory.stepping, plotX += zoomHistory.visiblePointDistance) {
                point = data[i];
                if (point && point.plotY) {
                    if (addLine) {
                        graphPath.push(M, lastMovePoint[0], lastMovePoint[1], L);
                        addLine = false;
                    }
                    if (addMove) {
                        addLine = true;
                        addMove = false
                        lastMovePoint[0] = plotX;
                        lastMovePoint[1] = point.plotY;
                    }
                    else {
                        graphPath.push(plotX, point.plotY);
                    }
                }
                else if (!connectNullData){
                        addMove = true;
                }
            }

            // used in drawTracker:
            series.graphPath = graphPath;
            series.singlePoints = singlePoints;


            /**^
             *  Drawing the line point wise and storing the path elements in series.graphLine array
             *  graphLine is a custom key to store the path elements
             */
            var graphLine = series.graphLine;


            attribs = {
                'stroke': color,
                'stroke-width': lineWidth,
                'stroke-linecap': 'round',
                dashstyle: dashStyle
            };
            if (graphLine) {
                series.graphLine.animate({
                    d: graphPath
                });
            } else {
                series.graphLine = renderer.path(graphPath)
                .attr(attribs)
                .add(group)
                .shadow(options.shadow, series.shadowGroup);
            }

        /*EOP^*/
        },
        /**^
     * drawDataLabels function completely changed, FusionCharts valueLabel format added.
     */
        // Draw the data labels
        drawDataLabels: function() {
            if (this.options.dataLabels.enabled) {
                var series = this,
                x,
                y,
                data = series.data,
                options = series.options.dataLabels,
                dataLabelsGroup = series.dataLabelsGroup,
                chart = series.chart,
                renderer = chart.renderer,
                HCChartObj = chart.options.chart,
                seriesType = series.type,
                color,
                yIsNull = options.y === null,
                canvasHeight = chart.plotHeight,
                //smartLabel = new lib.SmartLabelManager(HCChartObj.renderTo,
                //    pluckNumber(chart.options.useellipseswhenoverflow, 1)),
                oriStr,
                zoomHistory = chart.stepZoom.zoomHistory[chart.stepZoom.currentZoomLevelIndex],
                stepping = zoomHistory.stepping,
                seriesStart = zoomHistory.seriesStart, positionIndex,
                isFloatedColumn = seriesType == 'floatedcolumn',
                fontLineHeight = pInt(options.style.fontSize),
                stepZoom = chart.stepZoom,
                xShift = stepZoom.scrollPosition * stepZoom.scrollablePXLength,
                newX = chart.plotLeft - xShift,
                valuePadding = HCChartObj.valuePadding;

                options.rotation = (HCChartObj.rotateValues == 1) ? 270 : undefined;


                // create a separate group for the data labels to avoid rotation
                if (!dataLabelsGroup) {
                    dataLabelsGroup = series.dataLabelsGroup =
                    renderer.g('data-labels')
                    .attr({
                        visibility: series.visible ? VISIBLE : HIDDEN,
                        zIndex: 6
                    })
                    .translate(newX, chart.plotTop)
                    .add();
                    //clip for scroll
                    /**^
                     *
                     */
                    if (chart.options.chart.hasScroll) {
                        dataLabelsGroup.clip(series.clipRect);
                    }
                /*EOP^*/
                }

                // determine the color
                color = options.color;
                if (color === 'auto') { // 1.0 backwards compatibility
                    color = null;
                }
                options.style.color = pick(color, series.color);

                // make the labels for each point
                each(data, function(point, i) {
                    positionIndex = i - seriesStart;
                    var plotX = point.plotX != null ? point.plotX : -999,
                    //plotX = (barX && barX + point.barW / 2) || point.plotX || -999,
                    plotY = pick(point.plotY, -999),
                    dataLabel = point.dataLabel,
                    align = options.align,
                    individualYDelta = (yIsNull ? (point.y >= 0 ? -6 : 12) : options.y) - valuePadding;

                    // get the string
                    oriStr = options.formatter.call(point.getLabelConfig());

                    if (oriStr == null) {
                        return;
                    }

                    // Fix for WATERFALL chart value actual y
                    if (isFloatedColumn) {
                        plotY = pluckNumber(point.barY, plotY);
                    }
                    x =  plotX + options.x;

                    y =  plotY + individualYDelta;
                    // Fix for zero values goes outside the canvas
                    if (y > canvasHeight) {
                        y = canvasHeight;
                    }
                    if (y < fontLineHeight) {
                        y = fontLineHeight;
                    }

                    // update existing label
                    if (dataLabel) {

                        dataLabel
                        .attr({
                            text: oriStr
                        }).animate({
                            x: x,
                            y: y
                        });
                    // create new label
                    } else if (defined(oriStr)) {
                        dataLabel = point.dataLabel = renderer.text(
                            oriStr,
                            x,
                            y
                            )
                        .attr({
                            align: align,
                            rotation: options.rotation,
                            zIndex: 1
                        })
                        .css(options.style)
                        .add(dataLabelsGroup);

                    }
                    if (positionIndex < 0 || positionIndex % stepping !== 0 ) {
                        if (dataLabel && dataLabel.hide) {
                            dataLabel.hide();
                        }
                    }
                });

            }
        },

        drawTracker: function() {
            var series = this,
            chart = series.chart,
            trackerLabel = +new Date(),
            cursor = series.options.cursor,
            css = cursor && {
                cursor: cursor
            },
            pointAttr, radius,
            renderer = chart.renderer,
            rel,
            zoomHistory = chart.stepZoom.zoomHistory[chart.stepZoom.currentZoomLevelIndex],
            stepping = zoomHistory.stepping,
            seriesStart = zoomHistory.seriesStart, positionIndex;

            //clip for scroll
            /**^
             *
             */
            if (chart.options.chart.hasScroll) {
                chart.trackerGroup.clip(series.clipRect);
            }
            /*EOP^*/

            each(series.data, function(point, i) {
                if (point.y !== null) {
                    positionIndex = i - seriesStart;
                    /**^
                         * Add cursor pointer if there has link
                         *modify the parent scope css variable with a local variable
                         */
                    if (point.link !== undefined) {
                        var css = {
                            cursor : 'pointer',
                            '_cursor': 'hand'
                        };
                    }
                    // shortcuts
                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                    radius = pointAttr.r + 3;
                    /* EOP ^*/
                    point.tracker = renderer.circle(point.plotX, point.plotY, radius)
                    .attr({
                        fill : TRACKER_FILL
                    })
                    .on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
                        rel = event.relatedTarget || event.fromElement;
                        if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
                            series.onMouseOver();
                        }
                        point.onMouseOver();
                    })
                    .on('mouseout', function(event) {
                        if (!series.options.stickyTracking) {
                            rel = event.relatedTarget || event.toElement;
                            if (attr(rel, 'isTracker') !== trackerLabel) {
                                series.onMouseOut();
                            }
                        }
                    })
                    .css(css)
                    .add(chart.trackerGroup);

                    if (positionIndex < 0 || positionIndex % stepping !== 0 ) {
                        if (point.tracker && point.tracker.hide) {
                            point.tracker.hide();
                        }
                    }
                }
            });
        },


        render : function () {
            var series = this,
            chart = series.chart,
            renderer = chart.renderer,
            chartOptions = chart.options.chart,
            data = series.data,
            scrollablePXLength,
            pbw;

            /// create the step zoom config for the chart if not done
            // var subsetStartIndex, subsetEndIndex, numItems, zoomHistory = [],
            if (!chart.stepZoom) {
                var maxIndex = data.length - 1,
                seriesStart, seriesEnd, visibleStartX,
                stepZoomOptions = chartOptions.stepZoom,
                pixelsPerPoint = pluckNumber(stepZoomOptions.pixelsperpoint, 15),
                displayStartIndex = pluckNumber(stepZoomOptions.displayStartIndex, 0),
                displayEndIndex = pluckNumber(stepZoomOptions.displayEndIndex, maxIndex),
                width = chart.plotWidth,
                scrollLeft = chart.plotLeft,
                scrollHeight = stepZoomOptions.scrollHeight,
                scrollTop = chart.plotHeight + chart.plotTop + pluckNumber(stepZoomOptions.scrollPadding, 0),
                stepping, scrollPosition, scrollRatio, seriesPXLength, seriesLength,
                visibleLength = displayEndIndex - displayStartIndex, scroller,
                perPointPixelDistance = width / visibleLength;
                if (perPointPixelDistance < pixelsPerPoint) {
                    stepping = Math.ceil(pixelsPerPoint / perPointPixelDistance);
                }
                else {
                    stepping = 1;
                }

                // series.xAxis.scroller.setScrollRatio(1, true);

                //recalculate perPointPixelDistance
                perPointPixelDistance = width / (visibleLength - (visibleLength % stepping));

                seriesStart = displayStartIndex % stepping;
                seriesEnd = maxIndex - (maxIndex % stepping);
                seriesLength = seriesEnd - seriesStart,
                seriesPXLength = seriesLength * perPointPixelDistance;
                scrollRatio = width / seriesPXLength;
                scrollablePXLength = seriesPXLength - width;
                if (scrollablePXLength > 0) {
                    scrollPosition = ((displayStartIndex - seriesStart)* perPointPixelDistance) / (seriesPXLength - width);
                }
                else {
                    scrollPosition = 0
                }

                pbw = chartOptions.plotBorderWidth;
                scroller = renderer.scroller(scrollLeft - pbw, scrollTop, width + pbw + pbw, scrollHeight,
                    true, {
                        size: stepZoomOptions.scrollBtnWidth,
                        padding: stepZoomOptions.scrollBtnPadding
                    }, false)
                .attr({
                    fill : stepZoomOptions.scrollColor
                })
                .setScrollRatio(scrollRatio)
                .callback(function (pos, animation, resetTooltip) {
                    chartStepZoomScroll.call(chart, pos, animation, resetTooltip);
                })
                .add (chart.seriesGroup);

                chart.stepZoom = {
                    zoomHistory : [{
                        seriesStart : seriesStart,
                        seriesEnd : seriesEnd,
                        stepping : stepping,
                        perPointPixelDistance : perPointPixelDistance,
                        visiblePointDistance : stepping * perPointPixelDistance,
                        seriesConf : [],
                        scrollRatio: scrollRatio,
                        scrollPosition : scrollPosition,
                        scrollablePXLength: scrollablePXLength
                    }],
                    currentZoomLevelIndex : 0,
                    pixelsPerPoint : pixelsPerPoint,
                    displayStartIndex : displayStartIndex,
                    displayEndIndex : displayEndIndex,
                    scrollRatio: 1,
                    maxIndex : maxIndex,
                    scrollPosition: scrollPosition,
                    scrollablePXLength : scrollablePXLength,
                    scroller: scroller
                };

                //draw the actegories

                var xAxis = series.xAxis,
                axisOptions = xAxis.options,
                catArray = xAxis.categories,
                labelsOptions = axisOptions.labels,
                labelArray, labelY, labelX, align, rotation,
                i = 0 , ln, stepZoomObj = chart.stepZoom, css,
                str, positionIndex, xDisplacement, labelObj, lineHeight,
                labelTop = scrollTop + scrollHeight;
                align = labelsOptions.align;
                rotation = labelsOptions.rotation;
                css = labelsOptions.style;
                lineHeight = pluckNumber(parseInt(css.lineHeight), 12);
                //create the cat group
                stepZoomObj.catClipRect = renderer.clipRect(0, 0, width + lineHeight, chart.chartHeight);
                stepZoomObj.catGroup = renderer.g('catGroup')
                .translate(scrollLeft, labelTop)
                .clip(stepZoomObj.catClipRect)
                .add (chart.seriesGroup);
                if (catArray && catArray.length > 0) {
                    labelArray = stepZoomObj.catLabelArr = [];
                    ln = catArray.length;
                    labelY = labelsOptions.y || 0;
                    xDisplacement = labelsOptions.x || 0;
                    stepZoomObj.catLabelClipXDisplacement = - (lineHeight / 2);
                    stepZoomObj.xDisplacement = xDisplacement;
                    for (i = 0; i < ln; i += 1) {
                        str = catArray[i];
                        if (defined(str)) {
                            positionIndex = i - seriesStart;
                            labelX = (positionIndex * perPointPixelDistance) + xDisplacement;
                            labelObj = labelArray[i] = renderer.text(
                                str,
                                labelX,
                                labelY
                                )
                            .attr({
                                align: align,
                                rotation: rotation
                            })
                            // without position absolute, IE export sometimes is wrong
                            .css(css)
                            .add(stepZoomObj.catGroup);
                            if (positionIndex < 0 || positionIndex % stepping !== 0) {
                                labelObj.hide();
                            }
                        }
                    }

                }
                scroller.setScrollPosition(scrollPosition);
            }

            var group,
            options = series.options,
            animation = options.animation,
            doAnimation = animation && series.animate,
            duration = doAnimation ? (animation && animation.duration) || 500 : 0,
            clipRect = series.clipRect,
            stepZoom = chart.stepZoom,
            xShift = stepZoom.scrollPosition * stepZoom.scrollablePXLength,
            newX = chart.plotLeft - xShift;


            // Add plot area clipping rectangle. If this is before chart.hasRendered,
            // create one shared clipRect.
            if (!clipRect) {
                /**^
                 * handle the cliprect for not to hide line anchors
                 */
                var cliprectX = xShift, cliprectY = 0, cliprectW = chart.plotSizeX, cliprectH = chart.plotSizeY;
                clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
                chart.clipRect : renderer.clipRect(cliprectX, cliprectY, cliprectW, cliprectH);
                clipRect.cliprectX = cliprectX;
                clipRect.cliprectY = cliprectY;
                clipRect.cliprectW = cliprectW;
                clipRect.cliprectH = cliprectH;
                /*EOP^*/
                if (!chart.clipRect) {
                    chart.clipRect = clipRect;
                }
            }

            // the group
            if (!series.group) {
                group = series.group = renderer.g('series');
                group.clip(series.clipRect)
                .attr({
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    zIndex: options.zIndex
                })
                .translate(newX, chart.plotTop)
                .add(chart.seriesGroup);
            }

            // initiate the animation
            if (doAnimation) {
                series.animate(true);
            }

            // cache attributes for shapes
            //series.getAttribs();

            // draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
            }

            // draw the points
            series.drawPoints();

            series.drawDataLabels();

            // draw the mouse tracking area
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }

            // run the animation
            if (doAnimation) {
                series.animate();
            }

            // finish the individual clipRect
            setTimeout(function() {
                clipRect.isAnimating = false;
                group = series.group; // can be destroyed during the timeout
                if (group && clipRect !== chart.clipRect && clipRect.renderer) {
                    group.clip((series.clipRect = chart.clipRect));
                    clipRect.destroy();
                }
            }, duration);


            series.isDirty = false; // means data is in accordance with what you see

        }
    });

    // 4 - add the constractor
    seriesTypes.stepzoom = stepZoom;

    ///////////// End of Series Adition ///////


/**
 * Highcharts JS v2.1.6 (2011-07-08)
 * Exporting module
 */



    // create shortcuts
    var HC = Highcharts,
    Chart = HC.Chart,
    createElement = HC.createElement,
    discardElement = HC.discardElement,
    css = HC.css,

    // Add language and get the defaultOptions
    defaultOptions = HC.setOptions({
        lang: {
            downloadPNG: 'Download PNG image',
            downloadJPEG: 'Download JPEG image',
            downloadPDF: 'Download PDF document',
            downloadSVG: 'Download SVG vector image',
            exportButtonTitle: 'Export to raster or vector image',
            printButtonTitle: 'Print the chart'
        }
    });

    // Buttons and menus are collected in a separate config option set called 'navigation'.
    // This can be extended later to add control buttons like zoom and pan right click menus.
    /**^
     * Menu Visual Upgrades
     */
    defaultOptions.navigation = {
        menuStyle: {
            border: '1px solid #A0A0A0',
            background: '#FFFFFF'
        },
        menuItemStyle: {
            fontFamily: 'Verdana, Arial',
            padding: '3px 5px',
            background: NONE,
            color: '#303030',
            fontSize: hasTouch ? '14px' : '11px'
        },
        menuItemHoverStyle: {
            background: '#999999',
            color: '#FFFFFF'
        },

        buttonOptions: {
            align: 'right',
            backgroundColor: {
                linearGradient: [0, 0, 0, 15],
                stops: [
                [0.4, '#F7F7F7'],
                [0.6, '#E3E3E3']
                ]
            },
            borderColor: '#B0B0B0',
            borderRadius: 2,
            borderWidth: 1,
            //enabled: true,
            height: 15,
            hoverBorderColor: '#909090',
            hoverSymbolFill: '#81A7CF',
            hoverSymbolStroke: '#4572A5',
            symbolFill: '#E0E0E0',
            //symbolSize: 12,
            symbolStroke: '#A0A0A0',
            //symbolStrokeWidth: 1,
            symbolX: 8,
            symbolY: 7.5,
            verticalAlign: 'top',
            width: 16,
            y: 10
        }
    };
    /** EOP ^*/


    // Add the export related options
    defaultOptions.exporting = {
        //enabled: true,
        //filename: 'chart',
        type: 'image/png',
        url: 'http://export.highcharts.com/',
        width: 800,
        enableImages: false,
        buttons: {
            exportButton: {
                //enabled: true,
                symbol: 'exportIcon',
                x: -10,
                symbolFill: '#A8BF77',
                hoverSymbolFill: '#768F3E',
                _titleKey: 'exportButtonTitle',
                menuItems: [{
                    textKey: 'downloadPNG',
                    onclick: function() {
                        this.exportChart();
                    }
                }, {
                    textKey: 'downloadJPEG',
                    onclick: function() {
                        this.exportChart({
                            type: 'image/jpeg'
                        });
                    }
                }, {
                    textKey: 'downloadPDF',
                    onclick: function() {
                        this.exportChart({
                            type: 'application/pdf'
                        });
                    }
                }, {
                    textKey: 'downloadSVG',
                    onclick: function() {
                        this.exportChart({
                            type: 'image/svg+xml'
                        });
                    }
                }/*, {
				text: 'View SVG',
				onclick: function() {
					var svg = this.getSVG()
						.replace(/</g, '\n&lt;')
						.replace(/>/g, '&gt;');

					doc.body.innerHTML = '<pre>'+ svg +'</pre>';
				}
			}*/]

            },
            printButton: {
                //enabled: true,
                symbol: 'printIcon',
                x: -36,
                symbolFill: '#B5C9DF',
                hoverSymbolFill: '#779ABF',
                _titleKey: 'printButtonTitle',
                onclick: function() {
                    this.print();
                }
            }
        }
    };



    extend(Chart.prototype, {
        /**
	 * Return an SVG representation of the chart
	 *
	 * @param additionalOptions {Object} Additional chart options for the generated SVG representation
	 */
        getSVG: function(additionalOptions) {
            var chart = this,
            chartCopy,
            sandbox,
            svg,
            seriesOptions,
            config,
            pointOptions,
            pointMarker,
            options = merge(chart.options, additionalOptions); // copy the options and add extra options

            // IE compatibility hack for generating SVG content that it doesn't really understand
            if (!doc.createElementNS) {
                doc.createElementNS = function(ns, tagName) {
                    var elem = doc.createElement(tagName);
                    elem.getBBox = function() {
                        return HC.Renderer.prototype.Element.prototype.getBBox.apply({
                            element: elem
                        });
                    };
                    return elem;
                };
            }

            // create a sandbox where a new chart will be generated
            sandbox = createElement(DIV, null, {
                position: ABSOLUTE,
                top: '-9999em',
                width: chart.chartWidth + PX,
                height: chart.chartHeight + PX
            }, doc.body);

            // override some options
            extend(options.chart, {
                renderTo: sandbox,
                forExport: true
            });
            options.exporting.enabled = false; // hide buttons in print

            if (!options.exporting.enableImages) {
                options.chart.plotBackgroundImage = null; // the converter doesn't handle images
                /**^
                 * Added other image attributes to prevent in export
                 */
                options.chart.bgSWF = undefined;
                options.chart.bgImage = undefined;
                options.chart.logoURL = undefined;
                /** EOP ^*/
            }

            // prepare for replicating the chart
            options.series = [];
            each(chart.series, function(serie) {
                seriesOptions = serie.options;

                seriesOptions.animation = false; // turn off animation
                seriesOptions.showCheckbox = false;
                seriesOptions.visible = serie.visible;

                if (!options.exporting.enableImages) {
                    // remove image markers
                    if (seriesOptions && seriesOptions.marker && /^url\(/.test(seriesOptions.marker.symbol)) {
                        seriesOptions.marker.symbol = 'circle';
                    }
                }

                seriesOptions.data = [];

                each(serie.data, function(point) {

                    // extend the options by those values that can be expressed in a number or array config
                    config = point.config;
                    pointOptions = {
                        x: point.x,
                        y: point.y,
                        name: point.name
                    };

                    if (typeof config == 'object' && point.config && config.constructor != Array) {
                        extend(pointOptions, config);
                    }

                    pointOptions.visible = point.visible;
                    seriesOptions.data.push(pointOptions); // copy fresh updated data

                    if (!options.exporting.enableImages) {
                        // remove image markers
                        pointMarker = point.config && point.config.marker;
                        if (pointMarker && /^url\(/.test(pointMarker.symbol)) {
                            delete pointMarker.symbol;
                        }
                    }
                });

                options.series.push(seriesOptions);
            });

            // generate the chart copy
            chartCopy = new Highcharts.Chart(options);

            // reflect axis extremes in the export
            each(['xAxis', 'yAxis'], function(axisType) {
                each (chart[axisType], function(axis, i) {
                    var axisCopy = chartCopy[axisType][i],
                    extremes = axis.getExtremes(),
                    userMin = extremes.userMin,
                    userMax = extremes.userMax;

                    if (userMin !== UNDEFINED || userMax !== UNDEFINED) {
                        axisCopy.setExtremes(userMin, userMax, true, false);
                    }
                });
            });

            // get the SVG from the container's innerHTML
            svg = chartCopy.container.innerHTML;

            // free up memory
            options = null;
            chartCopy.destroy();
            discardElement(sandbox);

            // sanitize
            svg = svg
            .replace(/zIndex="[^"]+"/g, '')
            .replace(/isShadow="[^"]+"/g, '')
            .replace(/symbolName="[^"]+"/g, '')
            .replace(/jQuery[0-9]+="[^"]+"/g, '')
            .replace(/isTracker="[^"]+"/g, '')
            .replace(/url\(([\'\"]?)[^#]+#/g, 'url($1#') /*^ Patched for iOS bug */ // #FCXT-28
            .replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ')
            .replace(/ href=/g, ' xlink:href=')
            /*.replace(/preserveAspectRatio="none">/g, 'preserveAspectRatio="none"/>')*/
            /* This fails in IE < 8
			.replace(/([0-9]+)\.([0-9]+)/g, function(s1, s2, s3) { // round off to save weight
				return s2 +'.'+ s3[0];
			})*/

            // IE specific
            .replace(/id=([^" >]+)/g, 'id="$1"')
            .replace(/class=([^" ]+)/g, 'class="$1"')
            .replace(/ transform /g, ' ')
            .replace(/:(path|rect)/g, '$1')
            .replace(/<img ([^>]*)>/gi, '<image $1 />')
            .replace(/<\/image>/g, '') // remove closing tags for images as they'll never have any content
            .replace(/<image ([^>]*)([^\/])>/gi, '<image $1$2 />') // closes image tags for firefox
            .replace(/width=(\d+)/g, 'width="$1"')
            .replace(/height=(\d+)/g, 'height="$1"')
            .replace(/hc-svg-href="/g, 'xlink:href="')
            .replace(/style="([^"]+)"/g, function(s) {
                return s.toLowerCase();
            });

            // IE9 beta bugs with innerHTML. Test again with final IE9.
            svg = svg.replace(/(url\(#highcharts-[0-9]+)&quot;/g, '$1')
            .replace(/&quot;/g, "'");
            if (svg.match(/ xmlns="/g).length == 2) {
                svg = svg.replace(/xmlns="[^"]+"/, '');
            }

            return svg;
        },

        /**
	 * Submit the SVG representation of the chart to the server
	 * @param {Object} options Exporting options. Possible members are url, type and width.
	 * @param {Object} chartOptions Additional chart options for the SVG representation of the chart
	 */
        exportChart: function(options, chartOptions) {
            var form,
            chart = this,
            svg = chart.getSVG(chartOptions);

            // merge the options
            options = merge(chart.options.exporting, options);

            // create the form
            form = createElement('form', {
                method: 'post',
                action: options.url
            }, {
                display: NONE
            }, doc.body);

            // add the values
            each(['filename', 'type', 'width', 'svg'], function(name) {
                createElement('input', {
                    type: HIDDEN,
                    name: name,
                    value: {
                        filename: options.filename || 'chart',
                        type: options.type,
                        width: options.width,
                        svg: svg
                    }
                    [name]
                }, null, form);
            });

            // submit
            form.submit();

            // clean up
            discardElement(form);
        },

        /**
	 * Print the chart
	 */
        print: function() {

            var chart = this,
            container = chart.container,
            origDisplay = [],
            origParent = container.parentNode,
            body = doc.body,
            childNodes = body.childNodes;

            if (chart.isPrinting) { // block the button while in printing mode
                return;
            }

            chart.isPrinting = true;

            // hide all body content
            each(childNodes, function(node, i) {
                if (node.nodeType == 1) {
                    origDisplay[i] = node.style.display;
                    node.style.display = NONE;
                }
            });

            // pull out the chart
            body.appendChild(container);

            // print
            win.print();

            // allow the browser to prepare before reverting
            setTimeout(function() {

                // put the chart back in
                origParent.appendChild(container);

                // restore all body content
                each(childNodes, function(node, i) {
                    if (node.nodeType == 1) {
                        node.style.display = origDisplay[i];
                    }
                });

                chart.isPrinting = false;

            }, 1000);

        },

        /**
	 * Display a popup menu for choosing the export type
	 *
	 * @param {String} name An identifier for the menu
	 * @param {Array} items A collection with text and onclicks for the items
	 * @param {Number} x The x position of the opener button
	 * @param {Number} y The y position of the opener button
	 * @param {Number} width The width of the opener button
	 * @param {Number} height The height of the opener button
	 */
        contextMenu: function(name, items, x, y, width, height) {
            var chart = this,
            navOptions = chart.options.navigation,
            menuItemStyle = navOptions.menuItemStyle,
            chartWidth = chart.chartWidth,
            chartHeight = chart.chartHeight,
            cacheName = 'cache-'+ name,
            menu = chart[cacheName],
            menuPadding = mathMax(width, height), // for mouse leave detection
            boxShadow = '1px 1px 3px rgba(0,0,0,0.5)', /**^ Menu Visual Upgrades ^*/
            innerMenu,
            hide,
            menuStyle;

            // create the menu only the first time
            if (!menu) {

                // create a HTML element above the SVG
                chart[cacheName] = menu = createElement(DIV, {
                    className: PREFIX + name
                }, {
                    position: ABSOLUTE,
                    zIndex: 1000,
                    padding: menuPadding + PX
                }, chart.container);

                innerMenu = createElement(DIV, null,
                    extend({
                        MozBoxShadow: boxShadow,
                        WebkitBoxShadow: boxShadow,
                        boxShadow: boxShadow
                    }, navOptions.menuStyle) , menu);

                // hide on mouse out
                hide = function() {
                    css(menu, {
                        display: NONE
                    });
                };

                addEvent(menu, 'mouseleave', hide);


                // create the items
                each(items, function(item) {
                    if (item) {
                        var div = createElement(DIV, {
                            onmouseover: function() {
                                css(this, navOptions.menuItemHoverStyle);
                            },
                            onmouseout: function() {
                                css(this, menuItemStyle);
                            },
                            innerHTML: item.text || HC.getOptions().lang[item.textKey]
                        }, extend({
                            cursor: 'pointer'
                        }, menuItemStyle), innerMenu);

                        div[hasTouch ? 'ontouchstart' : 'onclick'] = function() {
                            hide();
                            item.onclick.apply(chart, arguments);
                        };

                    }
                });

                chart.exportMenuWidth = menu.offsetWidth;
                chart.exportMenuHeight = menu.offsetHeight;
            }

            menuStyle = {
                display: 'block'
            };

            // if outside right, right align it
            if (x + chart.exportMenuWidth > chartWidth) {
                menuStyle.right = (chartWidth - x - width - menuPadding) + PX;
            } else {
                menuStyle.left = (x - menuPadding) + PX;
            }
            // if outside bottom, bottom align it
            if (y + height + chart.exportMenuHeight > chartHeight) {
                menuStyle.bottom = (chartHeight - y - menuPadding)  + PX;
            } else {
                menuStyle.top = (y + height - menuPadding) + PX;
            }

            css(menu, menuStyle);
        },

        /**
	 * Add the export button to the chart
	 */
        addButton: function(options) {
            var chart = this,
            renderer = chart.renderer,
            btnOptions = merge(chart.options.navigation.buttonOptions, options),
            onclick = btnOptions.onclick,
            menuItems = btnOptions.menuItems,
            /*position = chart.getAlignment(btnOptions),
			buttonLeft = position.x,
			buttonTop = position.y,*/
            buttonWidth = btnOptions.width,
            buttonHeight = btnOptions.height,
            box,
            symbol,
            button,
            borderWidth = btnOptions.borderWidth,
            boxAttr = {
                stroke: btnOptions.borderColor

            },
            symbolAttr = {
                stroke: btnOptions.symbolStroke,
                fill: btnOptions.symbolFill
            };

            if (btnOptions.enabled === false) {
                return;
            }

            // element to capture the click
            function revert() {
                symbol.attr(symbolAttr);
                box.attr(boxAttr);
            }

            // the box border
            box = renderer.rect(
                0,
                0,
                buttonWidth,
                buttonHeight,
                btnOptions.borderRadius,
                borderWidth
                )
            //.translate(buttonLeft, buttonTop) // to allow gradients
            .align(btnOptions, true)
            .attr(extend({
                fill: btnOptions.backgroundColor,
                'stroke-width': borderWidth,
                zIndex: 19
            }, boxAttr)).add();

            // the invisible element to track the clicks
            button = renderer.rect(
                0,
                0,
                buttonWidth,
                buttonHeight,
                0
                )
            .align(btnOptions)
            .attr({
                fill: 'rgba(255, 255, 255, 0.001)',
                title: HC.getOptions().lang[btnOptions._titleKey],
                zIndex: 21
            }).css({
                cursor: 'pointer'
            })
            .on('mouseover', function() {
                symbol.attr({
                    stroke: btnOptions.hoverSymbolStroke,
                    fill: btnOptions.hoverSymbolFill
                });
                box.attr({
                    stroke: btnOptions.hoverBorderColor
                });
            })
            .on('mouseout', revert)
            .on('click', revert)
            .add();

            //addEvent(button.element, 'click', revert);

            // add the click event
            if (menuItems) {
                onclick = function(e) {
                    revert();
                    var bBox = button.getBBox();
                    chart.contextMenu('export-menu', menuItems, bBox.x, bBox.y, buttonWidth, buttonHeight);
                };
            }
            /*addEvent(button.element, 'click', function() {
			onclick.apply(chart, arguments);
		});*/
            button.on('click', function() {
                onclick.apply(chart, arguments);
            });

            // the icon
            symbol = renderer.symbol(
                btnOptions.symbol,
                btnOptions.symbolX,
                btnOptions.symbolY,
                (btnOptions.symbolSize || 8) / 2 /**^ Menu Visual Upgrades ^*/
                )
            .align(btnOptions, true)
            .attr(extend(symbolAttr, {
                'stroke-width': btnOptions.symbolStrokeWidth || 1,
                zIndex: 20
            })).add();



        }
    });

    // Create the export icon
    HC.Renderer.prototype.symbols.exportIcon = function(x, y, radius) {
        return [
        M, // the disk
        x - radius, y + radius,
        L,
        x + radius, y + radius,
        x + radius, y + radius * 0.5,
        x - radius, y + radius * 0.5,
        'Z',
        M, // the arrow
        x, y + radius * 0.5,
        L,
        x - radius * 0.5, y - radius / 3,
        x - radius / 6, y - radius / 3,
        x - radius / 6, y - radius,
        x + radius / 6, y - radius,
        x + radius / 6, y - radius / 3,
        x + radius * 0.5, y - radius / 3,
        'Z'
        ];
    };
    // Create the print icon
    HC.Renderer.prototype.symbols.printIcon = function(x, y, radius) {
        return [
        M, // the printer
        x - radius, y + radius * 0.5,
        L,
        x + radius, y + radius * 0.5,
        x + radius, y - radius / 3,
        x - radius, y - radius / 3,
        'Z',
        M, // the upper sheet
        x - radius * 0.5, y - radius / 3,
        L,
        x - radius * 0.5, y - radius,
        x + radius * 0.5, y - radius,
        x + radius * 0.5, y - radius / 3,
        'Z',
        M, // the lower sheet
        x - radius * 0.5, y + radius * 0.5,
        L,
        x - radius * 0.75, y + radius,
        x + radius * 0.75, y + radius,
        x + radius * 0.5, y + radius * 0.5,
        'Z'
        ];
    };


    // Add the buttons on chart load
    Chart.prototype.callbacks.push(function(chart) {
        var n,
        exportingOptions = chart.options.exporting,
        buttons = exportingOptions.buttons;

        if (exportingOptions.enabled !== false) {

            for (n in buttons) {
                chart.addButton(buttons[n]);
            }
        }
    });


})();




(function () {
    // Register the module with FusionCharts and als oget access to a global
    // variable within the core's scope.
    var global = FusionCharts(['private', 'modules.renderer.highcharts-base']);
    // Check whether the module has been already registered. If true, then
    // do not bother to re-register.
    if (global === undefined) {
        return;
    }

    var lib = global.hcLib,

    creditLabel = true,



    //strings
    BLANKSTRINGPLACEHOLDER = lib.BLANKSTRINGPLACEHOLDER,
    BLANKSTRING = lib.BLANKSTRING,

    createTrendLine = lib.createTrendLine,

    //add the tools thats are requared
    pluck = lib.pluck,
    getValidValue = lib.getValidValue,
    pluckNumber = lib.pluckNumber,
    defaultPaletteOptions = lib.defaultPaletteOptions,
    getFirstValue = lib.getFirstValue,
    getDefinedColor = lib.getDefinedColor,
    parsePointValue = lib.parsePointValue,
    parseUnsafeString = lib.parseUnsafeString,
    FC_CONFIG_STRING = lib.FC_CONFIG_STRING,
    extend2 = lib.extend2,//old: jarendererExtend / margecolone
    getDashStyle = lib.getDashStyle, // returns dashed style of a line series

    toPrecision = lib.toPrecision,

    stubFN = lib.stubFN,
    hasSVG = lib.hasSVG,

    getColumnColor = lib.graphics.getColumnColor,
    getFirstColor = lib.getFirstColor,
    setLineHeight = lib.setLineHeight,
    pluckFontSize = lib.pluckFontSize, // To get the valid font size (filters negative values)
    pluckColor = lib.pluckColor,
    getFirstAlpha = lib.getFirstAlpha,
    getDarkColor = lib.graphics.getDarkColor,
    getLightColor = lib.graphics.getLightColor,
    convertColor = lib.graphics.convertColor,
    COLOR_TRANSPARENT = lib.COLOR_TRANSPARENT,
    POSITION_CENTER = lib.POSITION_CENTER,
    POSITION_TOP = lib.POSITION_TOP,
    POSITION_BOTTOM = lib.POSITION_BOTTOM,
    POSITION_RIGHT = lib.POSITION_RIGHT,
    POSITION_LEFT = lib.POSITION_LEFT,
    INT_ZERO = 0,

    chartAPI = lib.chartAPI,

    mapSymbolName = lib.graphics.mapSymbolName,
    COMMASTRING = lib.COMMASTRING,
    ZEROSTRING = lib.ZEROSTRING,
    ONESTRING = lib.ONESTRING,
    HUNDREDSTRING = lib.HUNDREDSTRING,
    PXSTRING = lib.PXSTRING,
    BGRATIOSTRING = lib.BGRATIOSTRING,
    COMMASPACE = lib.COMMASPACE,



    //strings
    SAMPLESTRING = lib.SAMPLESTRING,
    TESTSTR = lib.TESTSTR,
    getAngle = lib.graphics.getAngle,
    POSITION_MIDDLE = lib.POSITION_MIDDLE,
    STRINGUNDEFINED = lib.STRINGUNDEFINED,
    axisLabelAdder = lib.axisLabelAdder,
    falseFN = lib.falseFN,


    //add the tools thats are requared
    SmartLabelManager = lib.SmartLabelManager,
    NumberFormatter = lib.NumberFormatter,
    getLinkAction = lib.getLinkAction,
    getAxisLimits = lib.getAxisLimits,
    HASHSTRING = lib.HASHSTRING,


    createDialog = lib.createDialog,


    dropHash = lib.regex.dropHash,

    mathMax = Math.max,
    mathMin = Math.min,

    Highcharts = lib.Highcharts,

    styleValueMap = {
        fontWeight : {
            '1' : 'bold',
            '0': 'normal'
        },
        fontStyle : {
            '1' : 'italic',
            '0': 'normal'
        },
        textDecoration : {
            '1' : 'underline',
            '0': 'none'
        }
    },

    fontStyleMap = {//create the map function for every fontstyle attribute
        font: function (value, obj) {
            obj.style.fontFamily = value;
        },
        size: function (value, obj) {
            if (value) {
                obj.style.fontSize = pluckFontSize(value) + PXSTRING;
            }

        },
        color: function (value, obj, isDataValuess) {
            obj.style.color = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
            if (isDataValuess) {
                obj.color = obj.style.color;
            }
        },
        /* align has been suppressed until better implementation.
        align: function (value, obj) {

             if (value.toLowerCase) {
                obj.align = value.toLowerCase();
            }
        },*/
        bgcolor: function (value, obj) {
            obj.style.backgroundColor = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
        },
        bordercolor: function (value, obj) {
            obj.style.border = '1px solid';
            obj.style.borderColor = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
        },
        ishtml: BLANKSTRING,
        leftmargin: function (value, obj) {
            obj.style.marginLeft =  pluckNumber(value, 0) + PXSTRING;
        },
        letterspacing: function (value, obj) {
            obj.style.letterSpacing = pluckNumber(value, 0) + PXSTRING;
        },
        bold: function (value, obj) {
            obj.style.fontWeight = styleValueMap.fontWeight[value] || '';
        //obj.style.fontWeight = value == '1' ? 'bold' : '';
        },
        italic: function (value, obj) {
            obj.style.fontStyle = styleValueMap.fontStyle[value] || '';
        },
        underline: function (value, obj) {
            obj.style.textDecoration = styleValueMap.textDecoration[value] || '';
        }
    },
    defaultFontStyleMap = {
        text: '',
        style : {}
    },
    supportedStyle = {//supported style type that are supported in js chart
        //font style mapping
        font: function (HC, toObj, style) {
            var styleobject, x, y, isDataValuess = false, i, len, styleobjectI;

            switch (toObj) {//fiend the toobject of HC depending upon toobject string of FC
                case 'caption':
                    styleobject = HC.title;
                    break;

                case 'datalabels':
                    styleobject = HC.xAxis.labels;
                    break;

                case 'datavalues':
                    styleobject = HC.plotOptions.series.dataLabels;
                    isDataValuess = true;
                    break;

                case 'subcaption':
                    styleobject = HC.subtitle;
                    break;

                case 'tooltip':
                    styleobject = HC.tooltip;
                    break;

                case 'trendvalues':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].trendStyle
                    };
                    break;

                case 'xaxisname':
                    styleobject = HC.xAxis.title;
                    break;

                case 'yaxisname':
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].title)
                    }
                    break;

                case 'yaxisvalues':
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].labels)
                    }
                    break;

                case 'vlinelabels':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].divlineStyle
                    };
                    break;

                default:
                    //to prevent error send a dummy styleObj
                    styleobject = defaultFontStyleMap;
                    break;
            }

            if (typeof styleobject === 'object') {
                if (styleobject instanceof Array) {
                    for (i = 0, len = styleobject.length; i < len; i += 1) {
                        styleobjectI = styleobject[i];
                        for (x in style) {//add all style attr into the hc object
                            y = x.toLowerCase();
                            if (typeof fontStyleMap[y] === 'function') {
                                fontStyleMap[y](style[x], styleobjectI, isDataValuess);
                            }
                        }
                        setLineHeight(styleobjectI.style);
                    }
                }
                else {
                    for (x in style) {//add all style attr into the hc object
                        y = x.toLowerCase();
                        if (typeof fontStyleMap[y] === 'function') {
                            fontStyleMap[y](style[x], styleobject, isDataValuess);
                        }
                    }
                    setLineHeight(styleobject.style);
                }
            }
        }
    },

    // Palette string and 3d chart palette string
    chartPaletteStr = {
        chart2D: {
            bgColor : 'bgColor',
            bgAlpha : 'bgAlpha',
            bgAngle : 'bgAngle',
            bgRatio : 'bgRatio',
            canvasBgColor : 'canvasBgColor',
            canvasBaseColor : 'canvasBaseColor',
            divLineColor : 'divLineColor',
            legendBgColor : 'legendBgColor',
            legendBorderColor : 'legendBorderColor',
            toolTipbgColor : 'toolTipbgColor',
            toolTipBorderColor : 'toolTipBorderColor',
            baseFontColor : 'baseFontColor',
            anchorBgColor : 'anchorBgColor'
        },
        chart3D : {
            bgColor : 'bgColor3D',
            bgAlpha : 'bgAlpha3D',
            bgAngle : 'bgAngle3D',
            bgRatio : 'bgRatio3D',
            canvasBgColor : 'canvasBgColor3D',
            canvasBaseColor : 'canvasBaseColor3D',
            divLineColor : 'divLineColor3D',
            divLineAlpha : 'divLineAlpha3D',
            legendBgColor : 'legendBgColor3D',
            legendBorderColor : 'legendBorderColor3D',
            toolTipbgColor : 'toolTipbgColor3D',
            toolTipBorderColor : 'toolTipBorderColor3D',
            baseFontColor : 'baseFontColor3D',
            anchorBgColor : 'anchorBgColor3D'
        }
    },

    handleContainerResize = (function () {
        var store = {},
        INTERVALMS = 300,
        intervalId,
        trackResize = function () {
            var item,
            itemObj,
            itemVar,
            parentEle,
            count = 0;

            for (item in store) {
                count += 1;
                itemObj = store[item];
                itemVar = itemObj.jsVars;

                if ((parentEle = itemObj.ref && itemObj.ref.parentNode)) {
                    if (!itemVar.resizeLocked &&
                        (itemVar._containerOffsetW !== parentEle.offsetWidth ||
                            itemVar._containerOffsetH !== parentEle.offsetHeight)) {
                        itemObj.ref.resize();
                        itemVar._containerOffsetW = parentEle.offsetWidth;
                        itemVar._containerOffsetH = parentEle.offsetHeight;
                    }
                }
                else {
                    delete store[item];
                    count -= 1;
                }
            }

            if (!count) {
                intervalId = clearInterval(intervalId);
            }
        };

        return function (sender) {
            var vars = sender.jsVars,
            element = sender.ref && sender.ref.parentNode || {};

            vars._containerOffsetW = element.offsetWidth;
            vars._containerOffsetH = element.offsetHeight;
            store[sender.id] = sender;

            if (!intervalId) {
                intervalId = setInterval(trackResize, INTERVALMS);
            }
        };
    })(),

    privateAPIMethods = {
        getExternalInterfaceMethods: function () {
            var vars = this.jsVars,
            api = chartAPI[vars.type],
            eiMethods = api && api.eiMethods,
            eiMethodString = 'saveAsImage,print,exportChart,getXML,hasRendered,signature,cancelExport,';

            if (typeof eiMethods === 'string') {
                eiMethodString += eiMethods + COMMASTRING;
            }
            else if (eiMethods !== undefined || eiMethods !== null) {
                for (var method in eiMethods) {
                    eiMethodString += method + COMMASTRING;
                }
            }

            return eiMethodString.substr(0, eiMethodString.length -1);
        },

        drawOverlayButton: function (args) {
            var vars = this.jsVars,
                $back = vars.$overlayButton;

            if (args && args.show) {
                if (!$back) {
                    $back = vars.$overlayButton = jQuery('<span>');
                    $back.click(function () {
                        global.raiseEvent('OverlayButtonClick', args, vars.fcObj);
                    });
                }

                $back.html(args.message ? args.message : "Back")

                // Create the visual layout of the element.
                $back.css({
                    border: '1px solid #' + (args.borderColor ? args.borderColor : "7f8975"),
                    backgroundColor: '#' + (args.bgColor ? args.bgColor : "edefec"),
                    fontFamily: args.font ? args.font : "Verdana",
                    color: '#' + args.fontColor ? args.fontColor: "49563a",
                    fontSize: (args.fontSize ? args.fontSize : '10') + PXSTRING,
                    padding: (args.padding ? args.padding : '3') + PXSTRING,
                    fontWeight: parseInt(args.bold, 10) === 0 ? 'normal' : 'bold',
                    position: 'absolute',
                    top: '0',
                    right: '1px',
                    '_cursor': 'hand',
                    cursor: 'pointer'

                });

                vars.hcObj.container.appendChild($back[0]);
            }
            else if ($back) {
                $back.detach();
            }
        },

        print: function () {
            return this.jsVars.hcObj && this.jsVars.hcObj.hasRendered &&
                this.jsVars.hcObj.print();
        },

        exportChart: function (setup) { //export the chart
            var vars = this.jsVars,
                hcObj = vars.hcObj,
                exportParams = {},
                config;

            // check whether exporting is enabled or not
            if (hcObj && hcObj.options && hcObj.options.exporting &&
                hcObj.options.exporting.enabled) {

                if (!(setup === undefined || setup === null)) {

                    for (config in setup) {
                        switch(config.toLowerCase()) {
                            case 'exportfilename':
                                exportParams.filename = setup[config];
                                break;
                            case 'exportformat':
                                exportParams.type = {
                                    png: 'image/png',
                                    jpg: 'image/jpeg',
                                    pdf: 'application/pdf',
                                    svg: 'image/svg+xml'
                                }[setup[config].toLowerCase()] || 'image/png';
                                break;
                        }
                    }
                }
                hcObj.exportChart(exportParams);
            }
        },

        getSVGString: function () {
            return this.jsVars && this.jsVars.hcObj &&
                this.jsVars.hcObj.getSVG && this.jsVars.hcObj.getSVG();
        },

        resize: function () {
            var vars = this.jsVars,
            container = vars.container,
            fcObj = vars.fcObj,
            hcObj = vars.hcObj;

            if (!hcObj) {
                return;
            }

            // destroy old chart
            if (hcObj && hcObj.destroy) {
                hcObj.destroy();
            }

            lib.createChart(vars.fcObj, container, vars.type, undefined,
                undefined, false);

            delete vars.isResizing;

            lib.raiseEvent('resized', {
                width: fcObj.width,
                height: fcObj.height,
                prevWidth: vars.width,
                prevHeight: vars.height
            }, fcObj, [fcObj.id]);
        },

        lockResize: function (state) {
            return this.jsVars.resizeLocked = state === undefined && true || state;
        },

        showChartMessage: function (text) {
            var vars = this.jsVars,
            hcObj = vars.hcObj;

            if (vars.msgStore[text]) {
                text = vars.msgStore[text];
            }

            // destroy old chart
            if (hcObj && hcObj.destroy) {
                hcObj.destroy();
            }

            // create new dialog json and render chart
            lib.createChart(vars.fcObj, vars.container, vars.type, undefined, text);
            return text;
        },

        signature: function () {
            return 'FusionCharts/3.2.2 (XT)';
        }
    };


    lib.createChart = function (chartObj, container, type, notify, hcJSON, animate) {

        var vars = chartObj.jsVars,
        msgStore = vars.msgStore,
        dataComp, dataObj,
        api = chartAPI[type],
        instanceAPI,
        callback = function (obj) {

            var eventArgs,
            fcObj = vars.fcObj,
            w = fcObj.width,
            h = fcObj.height,
            eiMethods = api && api.eiMethods,
            $back = vars.$overlayButton;

            container.jsVars = chartObj.jsVars;
            vars.container = container;
            vars.hcObj = obj;
            vars.type = type;
            vars.width = container.offsetWidth;
            vars.height = container.offsetHeight;
            vars.instanceAPI = instanceAPI;

            // Check / set bgColor
            container.style.backgroundColor = vars.transparent ?
                'transparent' : '#ffffff';

            if (obj.hasRendered) {
                // Add private ExternalInterface API
                global.extend(container, privateAPIMethods);

                // Add Public externalInteface API
                if (eiMethods && typeof eiMethods !== 'string') {
                    for (var method in eiMethods) {
                        container[method] = eiMethods[method]
                    }
                }

                eventArgs = {
                    width: vars.width,
                    height: vars.height,
                    drawCount: vars.drawCount
                };

                // if overlaybutton was there, make it persistent.
                if ($back) {
                    obj.container.appendChild($back[0]);
                }

                lib.raiseEvent('drawcomplete', eventArgs, fcObj, [fcObj.id]);
            }

            if (notify) {
                notify({
                    success: obj.hasRendered,
                    ref: container,
                    id: chartObj.id
                });

                if (obj.hasRendered) {
                    w = Number((w && w.match && w.match(/^\s*(\d*\.?\d*)\%\s*$/) || [])[1]);
                    h = Number((h && h.match && h.match(/^\s*(\d*\.?\d*)\%\s*$/) || [])[1]);

                    if ((w || h) && fcObj.ref && fcObj.ref.parentNode) {
                        handleContainerResize(fcObj);
                    }

                    lib.raiseEvent('loaded', {
                        type: type
                    }, fcObj, [fcObj.id]);
                }
            }
        };

        // dispose old instanceAPI
        if (vars.instanceAPI && vars.instanceAPI.dispose) {
            vars.instanceAPI.dispose();
        }
        instanceAPI = api ? new chartAPI(type) : new chartAPI('stub');
        instanceAPI.chartInstance = chartObj;

        // if a JSON is already provided
        if (hcJSON !== undefined) {
            if (typeof hcJSON === 'string') {
                hcJSON = new createDialog(container, hcJSON);
                vars.hasNativeMessage = true;
            }
        }
        //check verious condition where the chart shows an message
        //chart not supported
        else if (!(api && api.init)) {
            hcJSON = new createDialog(container, msgStore.ChartNotSupported);
            vars.hasNativeMessage = true;
        }
        ////if chart has any msg to show
        else if (vars.message) {
            hcJSON = new createDialog(container, vars.message);
            vars.hasNativeMessage = true;
        }
        ////if chart has data loading error
        else if (vars.loadError) {
            hcJSON = new createDialog(container, msgStore.LoadDataErrorText);
            vars.hasNativeMessage = true;
        }
        ////if chart is retriving data
        else if (vars.stallLoad) {
            hcJSON = new createDialog(container, msgStore.XMLLoadingText);
            vars.hasNativeMessage = true;
        }

        else {
            //get the chart JSON
            dataComp = chartObj.getChartData(FusionChartsDataFormats.JSON, true);
            dataObj = dataComp.data;
            ////if chart will show xml parse error
            if (dataComp.error instanceof Error) {
                hcJSON = new createDialog(container, msgStore.InvalidXMLText);
                vars.hasNativeMessage = true;
                lib.raiseEvent('dataxmlinvalid', {}, vars.fcObj, [vars.fcObj.id]);
            }
            //convert the chart's JSON into HC compatable data
            else {

                lib.raiseEvent('dataloaded', {}, vars.fcObj, [vars.fcObj.id]);

                // convert it into HC data
                hcJSON = instanceAPI.init(container, dataObj, chartObj, callback);
                vars.drawCount += 1;

                //if no data to display
                
                
                if (hcJSON.series.length === 0) {
                    hcJSON = new createDialog(container, msgStore.ChartNoDataText);
                    vars.hasNativeMessage = true;
                    lib.raiseEvent('nodatatodisplay', {}, vars.fcObj, [vars.fcObj.id]);
                }
                else {
                    vars.hasNativeMessage = false;
                    delete vars.message;
                }
            }
        }

        if (!hcJSON) {
            hcJSON = new createDialog(container, 'Error rendering chart {0x01}');
            vars.hasNativeMessage = true;
        }
        // configure container
        hcJSON.chart = hcJSON.chart || {};
        hcJSON.chart.renderTo = container;

        // store chart api
        hcJSON.instanceAPI = instanceAPI;

        // configure the credit label
        hcJSON.credits = hcJSON.credits || {};
        hcJSON.credits.enabled = api && api.creditLabel === true ? true : false;

        // predisable animation (when sent as create-chart param during resize)
        if (animate === false) {
            hcJSON.chart.animation = false;
            
            (hcJSON.plotOptions || !(hcJSON.plotOptions = {})) &&
            (hcJSON.plotOptions.series || !(hcJSON.plotOptions.series = {}))
            hcJSON.plotOptions.series.animation = false;
        }

        return instanceAPI.draw(hcJSON, callback);
    };


    /////////// few local functions and tools ///////////
    //***if requared then add them to the lib

    //this function will create a default FCC object
    
    function HCstub (cObj, width, height) {
        var fcChartJSON = cObj.chart,
        marginTop = pluckNumber(fcChartJSON.charttopmargin, 15),
        marginRight = pluckNumber(fcChartJSON.chartrightmargin, 15),
        marginBottom = pluckNumber(fcChartJSON.chartbottommargin, 15),
        marginLeft = pluckNumber(fcChartJSON.chartleftmargin, 15),
        verticalMargin = marginTop + marginBottom,
        horizontalMargin = marginLeft + marginRight,
        maxVMargin = (0.7 * height),
        maxHMargin = (0.7 * width);


        // failsafe in case some user gives an arbitrarily high value for chart margins
        if (verticalMargin > maxVMargin) {
            marginTop -= (((verticalMargin - maxVMargin) * marginTop) / verticalMargin);
            marginBottom -= (((verticalMargin - maxVMargin) * marginBottom) / verticalMargin);
        }

        if (horizontalMargin > maxHMargin) {
            marginLeft -= (((horizontalMargin - maxHMargin) * marginLeft) / horizontalMargin);
            marginRight -= (((horizontalMargin - maxHMargin) * marginRight) / horizontalMargin);
        }

        var stubHC = {
            '_FCconf': {
                0 : {
                    stack : {}
                },
                1 : {
                    stack : {}
                },
                x : {
                    stack : {}
                },
                oriCatTmp : [],
                noWrap : false,//wrap a text if there has no space in width
                marginLeftExtraSpace : 0,
                marginRightExtraSpace : 0,
                marginBottomExtraSpace : 0,
                marginTopExtraSpace : 0,
                marimekkoTotal : 0//total for marimekko charts
            },
            chart: {
                alignTicks: false,
                renderTo: BLANKSTRING,
                ignoreHiddenSeries: false,
                events: {
                },
                reflow: false,
                spacingTop: marginTop,
                spacingRight: marginRight,
                spacingBottom: marginBottom,
                spacingLeft: marginLeft,
                marginTop: marginTop,
                marginRight: marginRight,
                marginBottom: marginBottom,
                marginLeft: marginLeft,
                borderRadius: 0,
                plotBackgroundColor : '#FFFFFF',
                style : {}
            },
            
            colors: ["AFD8F8", "F6BD0F", "8BBA00", "FF8E46", "008E8E",
            "D64646", "8E468E", "588526", "B3AA00", "008ED6",
            "9D080D", "A186BE", "CC6600", "FDC689", "ABA000",
            "F26D7D", "FFF200", "0054A6", "F7941C", "CC3300",
            "006600", "663300", "6DCFF6"],
            credits: {
                href: 'http://www.fusioncharts.com?BS=FCHSEvalMark',
                text: 'FusionCharts',
                enabled: true
            },
            global: {},
            labels: {
                items: []
            },
            lang: {},
            legend: {
                enabled : true,
                symbolWidth: 12,
                borderRadius: 1,
                backgroundColor: '#FFFFFF',
                initialItemX : 0,
                title : {
                    text : BLANKSTRING,
                    x : 0,
                    y : 0,
                    padding : 2
                },
                scroll : {},
                itemStyle: {}
            },
            loading: {},
            plotOptions: {
                series: {
                    pointPadding: 0,
                    borderColor : '#333333',
                    events: {},
                    animation: fcChartJSON.animation == ZEROSTRING ? false :{
                        duration: 1000
                    },
                    states: {
                        hover: {
                            enabled: false
                        },
                        select: {
                            enabled: false
                        }
                    },
                    dataLabels : {
                        enabled : true,
                        color: '#555555',
                        style: {},
                        formatter : function () {
                            if(this.point.showPercentValues) {
                                return (parseInt(this.percentage * 100, 10) / 100) + '%';
                            }
                            else {
                                return this.point.displayValue;
                            }
                        }
                    },
                    point: {
                        events: {}
                    }
                },
                area: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                radar: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                areaspline: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                line: {
                    shadow: true,

                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                scatter: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                bubble: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                spline: {
                    states: {
                        hover: {
                            enabled: false
                        }
                    },
                    marker: {
                        lineWidth: 1,
                        radius: 3,
                        states: {
                            hover: {
                                enabled: false
                            },
                            select: {
                                enabled: false
                            }
                        }
                    }
                },
                pie: {
                    size: '80%',
                    allowPointSelect: true,
                    cursor: 'pointer',
                    point: {
                        events: {
                            legendItemClick: fcChartJSON.interactivelegend ===
                            ZEROSTRING ? falseFN  : function () {
                                this.slice();
                                return false;
                            }
                        }
                    }
                },
                column: {},
                floatedcolumn : {},
                column3d: {},
                bar : {},
                bar3d : {}
            },
            point: {},
            series: [],
            subtitle: {
                text: BLANKSTRING,
                style : {}
            },
            symbols: [],
            title: {
                text : BLANKSTRING,
                style : {}
            },
            toolbar: {},
            tooltip: {
                borderRadius: 1,
                style: {},
                formatter : function () {
                    if(this.point.showPercentInToolTip) {
                        return this.point.toolText + (parseInt(this.percentage * 100, 10) / 100) + '%';
                    }
                    else {
                        return this.point.toolText;
                    }
                }
            },
            xAxis: {
                labels: {
                    x : 0,
                    style: {},
                    enabled : false
                },
                lineWidth: 0,
                plotLines: [],
                plotBands: [],
                title : {
                    style: {},
                    text: BLANKSTRING
                },
                tickWidth: 0,
                scroll : {
                    enabled : false
                }
            },
            yAxis: [{
                startOnTick: false,
                endOnTick : false,
                title : {
                    style: {},
                    text : BLANKSTRING
                },
                tickLength  : 0,
                labels: {
                    x : 0,
                    style: {}
                },
                plotBands: [],
                plotLines: []
            }, {
                tickLength  : 0,
                gridLineWidth: 0,
                startOnTick: false,
                endOnTick : false,
                title : {
                    style: {},
                    text : BLANKSTRING
                },
                labels: {
                    x: 0,
                    style: {},
                    enabled : false,
                    formatter : function () {
                        if (this.value !== BLANKSTRINGPLACEHOLDER){
                            return this.value;
                        }
                        else {
                            return BLANKSTRING;
                        }
                    }
                },
                opposite: true,
                plotBands: [],
                plotLines: []
            }],
            exporting: {
                buttons: {
                    exportButton: {},
                    printButton: {
                        enabled: false
                    }
                }
            }
        };
        if (fcChartJSON.palettecolors && typeof fcChartJSON.palettecolors === 'string') {
            stubHC.colors = fcChartJSON.palettecolors.split(COMMASTRING);
        }

        return stubHC;

    }



    ///////////// base modules registration ///////
    /**
     * Create a HighCharts compatible object depending upon FusonChrts JSON object
     *
     * @param id {string} The Id of the Div where the chart will render.
     * @param chartName {string} name of the chart e.g. Column3D, Pie2D etc.
     * @param obj {json} FusionChrarts JSON data.
     * @param id {string} The Id of the chart.
     * @param width {string} Chart's width
     * @param height {string} Chrart's hight
     *
     * @type json
     * @return json object compatable to HighChrats
     * updated
     */

    var defaultChartFN = function (container, chartName, obj, width, height, FCObj) {
        var hc, is3d, zeroPlaneColor, zeroPlaneAlpha, stack100percent, smartLabel,
        defaultSeries = this.defaultSeriesType, conf, isBar, plotOptions,
        FCChartObj = obj.chart, showBorder, showCanvasBorder, palleteString, isRoundEdges, xAxis, HCChartObj;

        //set the default tooltip charecter seperator if not defined
        // We don't need to set "tooltipsepchar" here
        //obj.chart.tooltipsepchar = pluck(FCChartObj.tooltipsepchar, COMMASTRING);


        //creade defaule stub
        hc = HCstub(obj, width, height);
        // HighChart Chart object
        HCChartObj = hc.chart;
        //HighChart xAxis
        xAxis = hc.xAxis;
        //HighChart conf obj
        conf = hc[FC_CONFIG_STRING];

        //create the smartLabel instance
        hc.labels.smartLabel = smartLabel = conf.smartLabel = this.smartLabel;
        //svae the width and height
        conf.width = width;
        conf.height = height;
        plotOptions = hc.plotOptions;


        conf.isDual = this.isDual;
        //create the numberformatter instance
        conf.numberFormatter = new NumberFormatter (FCChartObj, chartName);
        //create the numberformatter instance
        conf.axisGridManager = new axisLabelAdder (defaultSeries, FCChartObj);
        //save the FC chart type
        conf.FCchartName = chartName;
        //is the chart 3d
        HCChartObj.is3D = is3d = conf.is3d = /3d$/.test(defaultSeries);
        HCChartObj.isBar = isBar = conf.isBar = this.isBar;
        // If roundedges is enabled
        isRoundEdges = FCChartObj.useroundedges == 1,
        // Whether the cosmetics is to use 3D
        palleteString = is3d ? chartPaletteStr.chart3D : chartPaletteStr.chart2D;
        //save the FC Linkclick function
        HCChartObj.events.click = hc.plotOptions.series.point.events.click = conf.linkClickFN =
        getLinkAction(obj, FCObj);

        //fiend defaultseries type depemding upon chart's name
        HCChartObj.defaultSeriesType = defaultSeries;
        ////palette////
        var paletteIndex = FCChartObj.palette > 0 && FCChartObj.palette < 6 ?
        FCChartObj.palette : pluckNumber(this.paletteIndex, 1);
        ////reduce by 1 for array positining
        paletteIndex -= 1;
        //save the palette index for further reference
        HCChartObj.paletteIndex = paletteIndex;

        // If we're plotting round edges, we necessarily apply shadow
        // To give the contrasting effect.
        HCChartObj.useRoundEdges = (isRoundEdges && !is3d && !this.distributedColumns &&
            this.defaultSeriesType !== 'pie');

        // Full Chart as a hotspot
        if (pluck(FCChartObj.clickurl) !== undefined) {
            HCChartObj.link = FCChartObj.clickurl;
            HCChartObj.style.cursor = 'pointer';
            //change the point Click event ot make similar as FC
            hc.plotOptions.series.point.events.click = function () {
                HCChartObj.events.click.call({
                    link : FCChartObj.clickurl
                });
            };
        }

        //////////Chart font style////////////////////
        var inCanfontFamily = pluck(FCChartObj.basefont, 'Verdana'),
        inCanfontSize =  pluckFontSize(FCChartObj.basefontsize, 10),
        inCancolor = pluck(FCChartObj.basefontcolor, defaultPaletteOptions[palleteString.
            baseFontColor][paletteIndex]),
        outCanfontFamily = pluck(FCChartObj.outcnvbasefont, inCanfontFamily),
        fontSize = pluckFontSize(FCChartObj.outcnvbasefontsize, inCanfontSize),
        outCanfontSize = fontSize + PXSTRING,
        outCancolor = pluck(FCChartObj.outcnvbasefontcolor, inCancolor).
        replace(/^#?([a-f0-9]+)/ig, '#$1'),
        outCanLineHeight, inCanLineHeight, axisTitleLineHeight;


        inCanfontSize =  inCanfontSize + PXSTRING;
        inCancolor = inCancolor.replace(/^#?([a-f0-9]+)/ig, '#$1');

        //create style for tredn tendtext
        //save it in the hc JSON for ferther refrence
        
        conf.trendStyle = conf.outCanvasStyle = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  outCanfontSize
        };
        outCanLineHeight = setLineHeight(conf.trendStyle);

        conf.inCanvasStyle = {
            fontFamily: inCanfontFamily,
            fontSize:  inCanfontSize,
            color: inCancolor
        };

        inCanLineHeight = setLineHeight(conf.inCanvasStyle);
        conf.divlineStyle = {
            fontFamily: inCanfontFamily,
            fontSize:  inCanfontSize,
            color: inCancolor,
            lineHeight : inCanLineHeight
        };

        xAxis.labels.style = {//style for x axis
            fontFamily: outCanfontFamily,
            fontSize:  outCanfontSize,
            lineHeight : outCanLineHeight,
            color: outCancolor
        };
        //style for pyasis
        hc.yAxis[0].labels.style = {
            fontFamily: outCanfontFamily,
            fontSize:  outCanfontSize,
            lineHeight : outCanLineHeight,
            color: outCancolor
        };
        //style for syaxis
        hc.yAxis[1].labels.style = {
            fontFamily: outCanfontFamily,
            fontSize:  outCanfontSize,
            lineHeight : outCanLineHeight,
            color: outCancolor
        };
        //legend
        hc.legend.itemStyle = {
            fontFamily: outCanfontFamily,
            fontSize:  outCanfontSize,
            lineHeight : outCanLineHeight,
            color: outCancolor
        };
        ///datalabels
        hc.plotOptions.series.dataLabels.style = {
            fontFamily: inCanfontFamily,
            fontSize:  inCanfontSize,
            lineHeight : inCanLineHeight,
            color: inCancolor
        };
        //special attr for datalabels color
        
        hc.plotOptions.series.dataLabels.color = hc.plotOptions.series.dataLabels.style.color;
        ///tooltip
        hc.tooltip.style = {
            fontFamily: inCanfontFamily,
            fontSize:  inCanfontSize,
            lineHeight : inCanLineHeight,
            color: inCancolor
        };
        ///set the caption font style
        hc.title.style = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  (fontSize + 3) + PXSTRING,
            fontWeight: 'bold'
        };
        setLineHeight(hc.title.style);
        hc.subtitle.style = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  (fontSize + 1) + PXSTRING,
            fontWeight: 'bold'
        };
        setLineHeight(hc.subtitle.style);
        //set the style for the xAxis name
        xAxis.title.style = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  outCanfontSize,
            fontWeight: 'bold'
        };
        axisTitleLineHeight = setLineHeight(xAxis.title.style);
        //set the style for the primary yAxis name
        hc.yAxis[0].title.style = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  outCanfontSize,
            lineHeight : axisTitleLineHeight,
            fontWeight: 'bold'
        };
        //set the style for the secinadry yAxis name
        hc.yAxis[1].title.style = {
            fontFamily: outCanfontFamily,
            color: outCancolor,
            fontSize:  outCanfontSize,
            lineHeight : axisTitleLineHeight,
            fontWeight: 'bold'
        };


        //////set styles//////////
        var j, styleArr, styleName, tempstyle = {}, l, definitionObj;
        if (obj.styles && obj.styles.definition instanceof Array && obj.styles.application instanceof Array) {
            // retrieving all style definition and storing them in a temporary store
            for (j = 0; j < obj.styles.definition.length; j += 1) {
                definitionObj = obj.styles.definition[j];
                if (typeof supportedStyle[definitionObj.type.toLowerCase()] === 'function') {
                    tempstyle[definitionObj.name.toLowerCase()] = definitionObj;
                }
            }
            ///find all apply object
            for (j = 0; j < obj.styles.application.length; j += 1) {
                styleArr = obj.styles.application[j].styles.split(COMMASTRING);
                for (l = 0; l < styleArr.length; l += 1) {
                    styleName = styleArr[l].toLowerCase();
                    if (tempstyle[styleName]) {
                        supportedStyle[tempstyle[styleName].type.toLowerCase()]
                        (hc, obj.styles.application[j].toobject.toLowerCase(), tempstyle[styleName]);
                    }
                }
            }
        }

        //after applying the style do the


        // Deleting background style for not to effect the background cosmetics
        // for 3.2.2 relelease.
        delete hc.xAxis.labels.style.backgroundColor;
        delete hc.xAxis.labels.style.borderColor;

        delete hc.yAxis[0].labels.style.backgroundColor;
        delete hc.yAxis[0].labels.style.borderColor;

        delete hc.yAxis[1].labels.style.backgroundColor;
        delete hc.yAxis[1].labels.style.borderColor;


        // Point configuration to show label tooltext and data values
        conf.showTooltip = pluckNumber(FCChartObj.showtooltip, 1);
        conf.tooltipSepChar = pluck(FCChartObj.tooltipsepchar, COMMASPACE);
        conf.showValues = pluckNumber(FCChartObj.showvalues, this.showValues, 1);
        conf.seriesNameInToolTip = pluckNumber(FCChartObj.seriesnameintooltip, 1);

        conf.showVLineLabelBorder = pluckNumber(FCChartObj.showvlinelabelborder, 1);
        conf.rotateVLineLabels = pluckNumber(FCChartObj.rotatevlinelabels, 0);
        conf.vLineColor = pluck(FCChartObj.vlinecolor, "333333");
        conf.vLineThickness = pluck(FCChartObj.vlinethickness, 1);
        conf.vLineAlpha = pluckNumber(FCChartObj.vlinealpha, 80);
        conf.vLineLabelBgColor = pluck(FCChartObj.vlinelabelbgcolor, "ffffff");
        conf.vLineLabelBgAlpha = pluckNumber(FCChartObj.vlinelabelbgalpha, is3d ? 50 : 100);


        

        hc.plotOptions.series.connectNullData = pluckNumber(FCChartObj.connectnulldata, 0);
        // create the back-ground color
        ////Finaly Set the Plot and Background color[must be modifyed al last as margins may be changed any where]
        HCChartObj.backgroundColor = {
            FCcolor : {
                color : pluck(FCChartObj.bgcolor, defaultPaletteOptions[palleteString.bgColor][paletteIndex]),
                alpha : pluck(FCChartObj.bgalpha, defaultPaletteOptions[palleteString.bgAlpha][paletteIndex]),
                angle : pluck(FCChartObj.bgangle, defaultPaletteOptions[palleteString.bgAngle][paletteIndex]),
                ratio : pluck(FCChartObj.bgratio, defaultPaletteOptions[palleteString.bgRatio][paletteIndex])
            }
        };

        // Whether to rotate the values
        HCChartObj.rotateValues = pluckNumber(FCChartObj.rotatevalues, 0);

        // placevaluesinside
        HCChartObj.placeValuesInside = pluckNumber(FCChartObj.placevaluesinside, 0);

        // valuePosition for line and area
        HCChartObj.valuePosition = FCChartObj.valueposition;

        // valuePosition for line and area
        HCChartObj.valuePadding = pluckNumber(FCChartObj.valuepadding, 2);

        HCChartObj.borderColor = convertColor(pluck(FCChartObj.bordercolor, is3d ? '#666666' :
            defaultPaletteOptions.borderColor[paletteIndex]),
        pluck(FCChartObj.borderalpha, is3d ? '100' : defaultPaletteOptions.borderAlpha[paletteIndex]));

        showBorder = pluckNumber(FCChartObj.showborder, is3d ? 0 : 1);

        HCChartObj.borderWidth = showBorder ? pluckNumber(FCChartObj.borderthickness, 1) : 0;

        HCChartObj.plotBorderColor = convertColor(pluck(FCChartObj.canvasbordercolor,
            defaultPaletteOptions.canvasBorderColor[paletteIndex]),
        pluck(FCChartObj.canvasborderalpha, defaultPaletteOptions.canvasBorderAlpha[paletteIndex]));

        showCanvasBorder = Boolean(pluck(FCChartObj.canvasborderthickness, isRoundEdges ? 0 : 1));

        HCChartObj.plotBorderWidth = is3d || !showCanvasBorder ? 0 : pluckNumber(FCChartObj.canvasborderthickness, HCChartObj.useRoundEdges ? 1 : 2);

        // Chart background image
        /* Attributes for customize bg image
            bgImage (String)
            bgImageAlpha	(0-100)
            bgImageDisplayMode	(none, stretch, center, fill, fit, tile )
            bgImageVAlign	(top, middle, bottom)
            bgImageHAlign	(left, middle, right)
            bgImageScale	(0-300)
         */
        var bgImageDisplayMode, bgImageVAlign, bgImageHAlign,
        TILE = 'tile',
        FILL = 'fill',
        FIT = 'fit';
        HCChartObj.bgSWF = pluck(FCChartObj.bgimage, FCChartObj.bgswf);
        HCChartObj.bgSWFAlpha = pluckNumber(FCChartObj.bgimagealpha, FCChartObj.bgswfalpha, 100);
        // Set background swf param
        bgImageDisplayMode = pluck(FCChartObj.bgimagedisplaymode, "none").toLowerCase();
        bgImageVAlign = getValidValue(FCChartObj.bgimagevalign, BLANKSTRING).toLowerCase();
        bgImageHAlign = getValidValue(FCChartObj.bgimagehalign, BLANKSTRING).toLowerCase();
        //when background mode is tile, fill and fit then default value of vertical alignment and horizontal alignment will be middle and middle
        if (bgImageDisplayMode == TILE || bgImageDisplayMode == FILL || bgImageDisplayMode == FIT) {
            if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE && bgImageVAlign != POSITION_BOTTOM) {
                bgImageVAlign = POSITION_MIDDLE;
            }
            if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE && bgImageHAlign != POSITION_RIGHT) {
                bgImageHAlign = POSITION_MIDDLE;
            }
        }
        else {
            if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE && bgImageVAlign != POSITION_BOTTOM) {
                bgImageVAlign = POSITION_TOP;
            }
            if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE && bgImageHAlign != POSITION_RIGHT) {
                bgImageHAlign = POSITION_LEFT;
            }
        }
        HCChartObj.bgImageDisplayMode = bgImageDisplayMode;
        HCChartObj.bgImageVAlign = bgImageVAlign;
        HCChartObj.bgImageHAlign = bgImageHAlign;
        HCChartObj.bgImageScale = pluckNumber(FCChartObj.bgimagescale, 100);


        // LOGO URL (foreground) logo parameters
        HCChartObj.logoURL = getValidValue(FCChartObj.logourl);
        HCChartObj.logoPosition = pluck(FCChartObj.logoposition, 'tl').toLowerCase();
        HCChartObj.logoAlpha = pluckNumber(FCChartObj.logoalpha, 100);
        HCChartObj.logoLink = getValidValue(FCChartObj.logolink);
        HCChartObj.logoScale = pluckNumber(FCChartObj.logoscale, 100);
        HCChartObj.logoLeftMargin = pluckNumber(FCChartObj.logoleftmargin, 0);
        HCChartObj.logoTopMargin = pluckNumber(FCChartObj.logotopmargin, 0);

        // Div lines and grid
        var
        divLineColor = pluck(FCChartObj.divlinecolor, defaultPaletteOptions[palleteString.divLineColor][paletteIndex]),
        divLineAlpha = pluck(FCChartObj.divlinealpha, is3d ?
            defaultPaletteOptions.divLineAlpha3D[paletteIndex] :
            defaultPaletteOptions.divLineAlpha[paletteIndex]),
        divLineThickness = pluckNumber(FCChartObj.divlinethickness, 1),
        divLineIsDashed = Boolean(pluckNumber(FCChartObj.divlineisdashed, this.divLineIsDashed, 0)),
        divLineDashLen = pluckNumber(FCChartObj.divlinedashlen, 4),
        divLineDashGap = pluckNumber(FCChartObj.divlinedashgap, 2);

        hc.yAxis[0].gridLineColor = convertColor(divLineColor, divLineAlpha);
        hc.yAxis[0].gridLineWidth = divLineThickness;
        hc.yAxis[0].gridLineDashStyle = divLineIsDashed ? getDashStyle(divLineDashLen,
            divLineDashGap, divLineThickness) : undefined;
        if (isBar) {
            hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                defaultPaletteOptions.altVGridColor[paletteIndex]),
            pluckNumber(FCChartObj.showalternatevgridcolor, 1) === 1 ?
                pluck(FCChartObj.alternatevgridalpha, defaultPaletteOptions.altVGridAlpha[paletteIndex]) : ZEROSTRING);
        } else {
            hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatehgridcolor,
                defaultPaletteOptions.altHGridColor[paletteIndex]),
            (FCChartObj.showalternatehgridcolor == 0) ? 0 : (pluck(FCChartObj.alternatehgridalpha,
                defaultPaletteOptions.altHGridAlpha[paletteIndex])));
        }

        //create the x axis options scatter
        var vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, 1),
        vDivLineIsDashed = Boolean(pluckNumber(FCChartObj.vdivlineisdashed, 0)),
        vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, 4),
        vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, 2);
        xAxis.gridLineColor = convertColor(pluck(FCChartObj.vdivlinecolor,
            defaultPaletteOptions[palleteString.divLineColor][paletteIndex]),
        pluck(FCChartObj.vdivlinealpha, defaultPaletteOptions.divLineAlpha[paletteIndex]));
        xAxis.gridLineWidth = vDivLineThickness;
        xAxis.gridLineDashStyle = vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
            vDivLineDashGap, vDivLineThickness) : undefined;
        xAxis.alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
            defaultPaletteOptions.altVGridColor[paletteIndex]),
        (FCChartObj.showalternatehgridcolor === '1') ? (pluck(FCChartObj.alternatevgridalpha,
            defaultPaletteOptions.altVGridAlpha[paletteIndex])) : 0);

        var showPercentValues, canBGColor = pluck(FCChartObj.canvasbgcolor, defaultPaletteOptions[
            palleteString.canvasBgColor][paletteIndex]), showPercentInToolTip,
        canBGAlpha = pluck(FCChartObj.canvasbgalpha, defaultPaletteOptions.
            canvasBgAlpha[paletteIndex]),
        showCanvasBG = pluck(FCChartObj.showcanvasbg, ONESTRING);

        if (showCanvasBG == ZEROSTRING) {
            canBGAlpha = '0';
        }

        // Plot shadow effect. Note that this is overridden in the if-block
        // below.
        hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
            FCChartObj.showcolumnshadow,
            this.defaultPlotShadow,
            defaultPaletteOptions.showShadow[paletteIndex]);

        //if inversed chart then set the reverse attr for axis
        if (this.inversed) {
            hc.yAxis[0].reversed = true;
            hc.yAxis[1].reversed = true;
        }

        //if stacked chart
        if (this.isStacked) {
            if (this.distributedColumns) {
                conf.showStackTotal = Boolean(pluckNumber(FCChartObj.showsum,  1));
                stack100percent = pluckNumber(FCChartObj.usepercentdistribution, 1);
                
                showPercentValues = pluckNumber(FCChartObj.showpercentvalues, 0);
                showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, 1);
                conf.showXAxisPercentValues = pluckNumber(FCChartObj.showxaxispercentvalues, 1);
            }
            else {
                conf.showStackTotal = Boolean(pluckNumber(this.showSum, FCChartObj.showsum,  0));
                //combicharts dose not support stack100percent
                stack100percent = pluckNumber(this.stack100percent, FCChartObj.stack100percent, 0);
                showPercentValues = pluckNumber(FCChartObj.showpercentvalues, stack100percent);
                showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, showPercentValues);
            }
            //add the showPercentValues in conf
            conf.showPercentValues = showPercentValues;
            conf.showPercentInToolTip = showPercentInToolTip;

            //only default series get the stack property
            if (stack100percent) {
                conf.isValueAbs = true;
                plotOptions[defaultSeries].stacking = 'percent';
                //first axis will be percent stacking
                conf[0].stacking100Percent = true;
            }
            else {
                plotOptions[defaultSeries].stacking = 'normal';
            }
        }

        //Issue #680 solved
        if(this.isDual) {
            if (FCChartObj.primaryaxisonleft === '0') {
                hc.yAxis[0].opposite = true;
                hc.yAxis[1].opposite = false;
            }
            hc.yAxis[0].showAlways = true;
            hc.yAxis[1].showAlways = true;
        }



        if (HCChartObj.useRoundEdges) {
            hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
                FCChartObj.showcolumnshadow, 1);
            hc.plotOptions.series.borderRadius = 1;
            hc.tooltip.borderRadius = 2;
            // Manage canvas cosmetics
            HCChartObj.plotBorderRadius = 3;
            if (!showCanvasBorder) {
                HCChartObj.plotBorderWidth = 0;
            }
            HCChartObj.plotShadow = hc.plotOptions.series.shadow ? {
                enabled: true,
                opacity: canBGAlpha / 100
            } : 0;

        }

        ///add the support for maxColWidth/maxBarHeight
        hc.plotOptions.series.maxColWidth = Math.abs(pluckNumber(isBar ?
            FCChartObj.maxbarheight : FCChartObj.maxcolwidth, 50)) || 1;


        //Title
        hc.title.text = parseUnsafeString(FCChartObj.caption);

        //SubTitle
        hc.subtitle.text = parseUnsafeString(FCChartObj.subcaption);


        ///////// tooltip Options//////////////
        if (FCChartObj.showtooltip == ZEROSTRING) { //area/line ancor conflict
            hc.tooltip.enabled =  false;
        }

        var tooltipStyle = hc.tooltip.style;
        hc.tooltip.backgroundColor = convertColor(pluck(tooltipStyle.backgroundColor, FCChartObj.tooltipbgcolor,
            defaultPaletteOptions.toolTipBgColor[paletteIndex]), pluck(FCChartObj.tooltipbgalpha, 100));
        hc.tooltip.borderColor = convertColor(pluck(tooltipStyle.borderColor, FCChartObj.tooltipbordercolor,
            defaultPaletteOptions.toolTipBorderColor[paletteIndex]), pluck(FCChartObj.tooltipborderalpha, 100));

        // delete following styles to prevent IE to draw double border of the tooltext.
        tooltipStyle.backgroundColor = undefined;
        tooltipStyle.borderColor = undefined;
        tooltipStyle.border = undefined;

        hc.tooltip.shadow = FCChartObj.showtooltipshadow == ONESTRING ? {
            enabled: true,
            opacity: pluckNumber(mathMax(FCChartObj.tooltipbgalpha,FCChartObj.tooltipborderalpha), 100) / 100
        } : false;
        hc.tooltip.borderWidth = pluckNumber(FCChartObj.tooltipborderthickness, 1);
        if (FCChartObj.tooltipborderradius) {
            hc.tooltip.borderRadius = pluckNumber(FCChartObj.tooltipborderradius, 1);
        }
        hc.tooltip.padding = pluckNumber(FCChartObj.tooltippadding, 2);
        if (FCChartObj.tooltipcolor) {
            tooltipStyle.color = getFirstColor(FCChartObj.tooltipcolor);
        }


        //set the plotspace ppercent has effecton column only
        var plotSpacePercent = pluckNumber(FCChartObj.plotspacepercent, 20);
        if (plotSpacePercent > 80 || plotSpacePercent < 0) {
            plotSpacePercent = 20;
        }
        //set the plot space percent
        conf.plotSpacePercent = hc.plotOptions.series.groupPadding = plotSpacePercent / 200;

        //if 3d chart then add 15 * 15 pixel space
        
        if (is3d) {
            //combi chart add shift for 2d series
            //**set the speciffic 3dShift conf in chartApi(2d area in 3d chart issue)
            HCChartObj.series2D3Dshift = chartName === 'mscombi3d' ? true : Boolean(pluckNumber(
                FCChartObj.use3dlineshift, 0));
            HCChartObj.canvasBaseColor3D = pluck(FCChartObj.canvasbasecolor, defaultPaletteOptions.
                canvasBaseColor3D[paletteIndex]);
            HCChartObj.canvasBaseDepth = pluckNumber(FCChartObj.canvasbasedepth, 10);
            HCChartObj.canvasBgDepth = pluckNumber(FCChartObj.canvasbgdepth, 3);
            HCChartObj.showCanvasBg = Boolean(pluckNumber(FCChartObj.showcanvasbg, 1));
            HCChartObj.showCanvasBase = Boolean(pluckNumber(FCChartObj.showcanvasbase, 1));
            if (isBar) {
                HCChartObj.xDepth = 5;
                HCChartObj.yDepth = 5;

                // adjust the space for canvasBgDepth
                //Store it as marginRightExtraSpace
                if (HCChartObj.showCanvasBg) {
                    conf.marginTopExtraSpace +=  HCChartObj.canvasBgDepth;
                }
                //adjust the space for canvasBaseDepth and yDepth
                conf.marginLeftExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                    HCChartObj.canvasBaseDepth : 0);
                conf.marginBottomExtraSpace += 5;
            }
            else {
                HCChartObj.xDepth = 10;
                HCChartObj.yDepth = 10;

                // adjust the space for canvasBgDepth
                //Store it as marginRightExtraSpace
                if (HCChartObj.showCanvasBg) {
                    conf.marginRightExtraSpace +=  HCChartObj.canvasBgDepth;
                }
                //adjust the space for canvasBaseDepth and yDepth
                conf.marginBottomExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                    HCChartObj.canvasBaseDepth : 0);
            }
            //build the 3d effect of the plotBackgroundColor
            canBGColor = canBGColor.split(COMMASTRING)[0];
            canBGAlpha = canBGAlpha.split(COMMASTRING)[0];
            HCChartObj.use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting, 1));
            if (HCChartObj.use3DLighting) {
                HCChartObj.plotBackgroundColor = {
                    FCcolor : {
                        color : getDarkColor (canBGColor, 85) + COMMASTRING + getLightColor (canBGColor, 55),
                        alpha : canBGAlpha + COMMASTRING + canBGAlpha,
                        ratio : BGRATIOSTRING,
                        angle : getAngle (width - (HCChartObj.marginLeft + HCChartObj.marginRight),
                            height - (HCChartObj.marginTop + HCChartObj.marginBottom), 1)
                    }
                };
            }
            else {
                HCChartObj.plotBackgroundColor =  convertColor(canBGColor, canBGAlpha);
            }


            //for bg depth
            HCChartObj.canvasBgColor = convertColor(getDarkColor(canBGColor, 80), canBGAlpha);
            zeroPlaneColor = pluck(FCChartObj.zeroplanecolor, FCChartObj.divlinecolor,
                defaultPaletteOptions[palleteString.divLineColor][paletteIndex]);
            zeroPlaneAlpha = pluck(FCChartObj.zeroplanealpha, FCChartObj.divlinealpha,
                defaultPaletteOptions.divLineAlpha[paletteIndex]);
            HCChartObj.zeroPlaneColor = convertColor(zeroPlaneColor, zeroPlaneAlpha);
            HCChartObj.zeroPlaneBorderColor = convertColor(pluck(FCChartObj.zeroplanebordercolor,
                zeroPlaneColor), pluckNumber(FCChartObj.zeroplaneshowborder, 1) ? zeroPlaneAlpha : 0);
        }
        else {
            // Manage canvas cosmetics
            HCChartObj.plotBackgroundColor = {
                FCcolor : {
                    color : canBGColor,
                    alpha : canBGAlpha,
                    angle : pluck(FCChartObj.canvasbgangle, defaultPaletteOptions.canvasBgAngle[paletteIndex]),
                    ratio : pluck(FCChartObj.canvasbgratio, defaultPaletteOptions.canvasBgRatio[paletteIndex])
                }
            };
        }


        //
        //////Expprt Module/////
        hc.exporting.enabled = FCChartObj.exportenabled == '1' ? true: false;
        //hc.exporting.exportAtClient = FCChartObj.exportatclient == '1' ? true: false;
        hc.exporting.url = Boolean(pluckNumber(FCChartObj.exportatclient)) ?
        getValidValue(FCChartObj.exporturl) : hc.exporting.url;
        hc.exporting.buttons.exportButton.enabled = FCChartObj.exportshowmenuitem == '0' ? false : true;
        hc.exporting.filename = FCChartObj.exportfilename ? FCChartObj.exportfilename : 'FusionCharts';
        hc.exporting.width = width;

        //create the Data serias first
        this.series(obj, hc, chartName, width, height);



        //this function do the after series addition works like:
        // showsum for stacking
        //marimekko conf
        this.postSeriesAddition(hc, obj, width, height);


        /*
         *Manage the space
         */
        this.spaceManager(hc, obj, width, height);


        // Drawing Quadrant for XY plot Charts
        var drawQuadrant = pluckNumber(FCChartObj.drawquadrant, 0);
        if (conf.isXYPlot && drawQuadrant) {

            //Quadrant related properties
            var HCChartObj = HCChartObj,
            xMin = xAxis.min, xMax = xAxis.max,
            yMin = hc.yAxis[0].min, yMax = hc.yAxis[0].max,
            quadrantXVal = pluckNumber(FCChartObj.quadrantxval, (xMin + xMax)/2),
            quadrantYVal = pluckNumber(FCChartObj.quadrantyval, (yMin + yMax)/2);
            if (quadrantYVal >= yMin && quadrantYVal <= yMax && quadrantXVal >= xMin && quadrantXVal <= xMax) {
                var quadrantLineColor = convertColor(pluck(FCChartObj.quadrantlinecolor, HCChartObj.plotBorderColor),
                    pluck(FCChartObj.quadrantlinealpha, HUNDREDSTRING)),
                quadrantLineThickness = pluckNumber(FCChartObj.quadrantlinethickness, HCChartObj.plotBorderWidth),
                quadrantLineIsDashed = pluckNumber(FCChartObj.quadrantlineisdashed, 0),
                quadrantLineDashLen = pluckNumber(FCChartObj.quadrantlinedashLen, 4),
                quadrantLineDashGap = pluckNumber(FCChartObj.quadrantlinedashgap, 2),
                quadrantLabelTL = getValidValue(FCChartObj.quadrantlabeltl, BLANKSTRING),
                quadrantLabelTR = getValidValue(FCChartObj.quadrantlabeltr, BLANKSTRING),
                quadrantLabelBL = getValidValue(FCChartObj.quadrantlabelbl, BLANKSTRING),
                quadrantLabelBR  = getValidValue(FCChartObj.quadrantlabelbr, BLANKSTRING),
                //Padding of label from any side of canvase
                quadrantLabelPadding = pluckNumber(FCChartObj.quadrantlabelpadding, 3),
                dashStyle = quadrantLineIsDashed ? getDashStyle(quadrantLineDashLen,
                    quadrantLineDashGap, quadrantLineThickness) : undefined;


                //Now check whether they're in range.
                xAxis.plotLines.push({
                    color: quadrantLineColor,
                    value: quadrantXVal,
                    width: quadrantLineThickness,
                    dashStyle: dashStyle,
                    zIndex: 3
                });

                hc.yAxis[0].plotLines.push({
                    color: quadrantLineColor,
                    value: quadrantYVal,
                    width: quadrantLineThickness,
                    dashStyle: dashStyle,
                    zIndex: 3
                });

                var canvasWidth = width - HCChartObj.marginRight - HCChartObj.marginLeft,
                canvasHeight = height - HCChartObj.marginTop - HCChartObj.marginBottom,
                labelWidthPart1, labelWidthPart2, labelHeightPart1, labelHeightPart2, smartText,
                inCanvasStyle = conf.inCanvasStyle, inCanvasFontSize =
                parseInt(inCanvasStyle.fontSize, 10);

                labelWidthPart1 = (canvasWidth / (xMax - xMin)) * (quadrantXVal - xMin);
                labelWidthPart2 = canvasWidth - labelWidthPart1;

                labelHeightPart2 = (canvasHeight / (yMax - yMin)) * (quadrantYVal - yMin);
                labelHeightPart1 = canvasHeight - labelHeightPart2;

                //remove the padding amount
                labelWidthPart1 -= quadrantLabelPadding;
                labelWidthPart2 -= quadrantLabelPadding;
                labelHeightPart1 -= quadrantLabelPadding;
                labelHeightPart2 -= quadrantLabelPadding;
                var top1 = quadrantLabelPadding + inCanvasFontSize + PXSTRING,
                top2 = (canvasHeight - quadrantLabelPadding + inCanvasFontSize) + PXSTRING,
                left1 = quadrantLabelPadding + PXSTRING,
                left2 = (canvasWidth - quadrantLabelPadding) + PXSTRING;

                // Draw the quadrant labels.
                smartLabel.setStyle(inCanvasStyle);

                if (labelHeightPart1 > 0) {
                    if (quadrantLabelTL !== BLANKSTRING && labelWidthPart1 > 0) {
                        smartText = smartLabel.getSmartText(quadrantLabelTL, labelWidthPart1, labelHeightPart1)
                        hc.labels.items.push({
                            html: smartText.text,
                            zIndex : 3,
                            style: {
                                left: left1,
                                top: top1,
                                fontSize: inCanvasStyle.fontSize,
                                lineHeight: inCanvasStyle.lineHeight,
                                fontFamily: inCanvasStyle.fontFamily,
                                color: inCanvasStyle.color
                            }
                        });
                    }

                    if (quadrantLabelTR !== BLANKSTRING && labelWidthPart2 > 0) {
                        smartText = smartLabel.getSmartText(quadrantLabelTR, labelWidthPart2, labelHeightPart1);
                        hc.labels.items.push({
                            html: smartText.text,
                            textAlign: POSITION_RIGHT,
                            zIndex : 3,
                            style: {
                                left: left2,
                                top: top1,
                                fontSize: inCanvasStyle.fontSize,
                                lineHeight: inCanvasStyle.lineHeight,
                                fontFamily: inCanvasStyle.fontFamily,
                                color: inCanvasStyle.color
                            }
                        });
                    }
                }
                if (labelHeightPart2 > 0) {
                    if (quadrantLabelBL !== BLANKSTRING && labelWidthPart1 > 0) {
                        smartText = smartLabel.getSmartText(quadrantLabelBL, labelWidthPart1, labelHeightPart2)
                        hc.labels.items.push({
                            html: smartText.text,
                            vAlign : POSITION_BOTTOM,
                            zIndex : 3,
                            style: {
                                left: left1,
                                top: top2,
                                fontSize: inCanvasStyle.fontSize,
                                lineHeight: inCanvasStyle.lineHeight,
                                fontFamily: inCanvasStyle.fontFamily,
                                color: inCanvasStyle.color
                            }
                        });
                    }

                    if (quadrantLabelBR !== BLANKSTRING && labelWidthPart2 > 0) {
                        smartText = smartLabel.getSmartText(quadrantLabelBR, labelWidthPart2, labelHeightPart2)
                        hc.labels.items.push({
                            html: smartText.text,
                            textAlign: POSITION_RIGHT,
                            vAlign : POSITION_BOTTOM,
                            zIndex : 3,
                            style: {
                                left: left2,
                                top: top2,
                                fontSize: inCanvasStyle.fontSize,
                                lineHeight: inCanvasStyle.lineHeight,
                                fontFamily: inCanvasStyle.fontFamily,
                                color: inCanvasStyle.color
                            }
                        });
                    }
                }
            }
        }


        //add the code for x axis num v div line for line area
        if (this.hasVDivLine) {
            var numVDivLines, vDivLineColor, vDivLineAlpha;

            numVDivLines = pluckNumber(FCChartObj.numvdivlines, 0) + 1;
            if (numVDivLines > 1) {

                var min = xAxis.min, catLength = conf.x.catCount - 1, max = xAxis.max, value,
                gridInterval = catLength / numVDivLines, drawAltGrid = true,
                lastValue = min, alternateVGridColor, showAlternateVGridColor;

                vDivLineColor = pluck(FCChartObj.vdivlinecolor, divLineColor);
                vDivLineAlpha = pluckNumber(FCChartObj.vdivlinealpha, divLineAlpha);
                vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, divLineThickness);
                vDivLineIsDashed = pluckNumber(FCChartObj.vdivlineisdashed, divLineIsDashed);
                vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, divLineDashLen);
                vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, divLineDashGap);
                showAlternateVGridColor = pluckNumber(FCChartObj.showalternatevgridcolor, 0);
                if (showAlternateVGridColor) {
                    alternateVGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                        defaultPaletteOptions.altVGridColor[paletteIndex]),
                    pluck(FCChartObj.alternateVGridAlpha,
                        defaultPaletteOptions.altVGridAlpha[paletteIndex]
                        ))
                }

                for (value = gridInterval; value < catLength; value += gridInterval,
                    drawAltGrid = !drawAltGrid) {
                    // Draw the alternate grid
                    if (drawAltGrid && showAlternateVGridColor) {
                        xAxis.plotBands.push({
                            color: alternateVGridColor,
                            from: lastValue,
                            to: value,
                            zIndex: 1
                        });
                    }
                    // Draw the Grid lines
                    xAxis.plotLines.push({
                        width: vDivLineThickness,
                        color: convertColor(vDivLineColor, vDivLineAlpha),
                        dashStyle : vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
                            vDivLineDashGap, vDivLineThickness) : undefined,
                        value: value,
                        zIndex: 1
                    });
                    lastValue = value;
                }
                // Draw the alternate grid for last one
                if (drawAltGrid && showAlternateVGridColor) {
                    xAxis.plotBands.push({
                        color: alternateVGridColor,
                        from: lastValue,
                        to: max,
                        zIndex: 1
                    });
                }

            }
        }



        
        // manageSpace (hc, obj, StoreChartObj.axisType, width, height);
        //place elements as per space calculated
        //placeElements (hc, StoreChartObj.axisType);

        //special checking for axis Depth. if there dont have sufficiant space for x depth
        //then add it
        if (is3d && HCChartObj.xDepth > HCChartObj.marginLeft) {
            HCChartObj.marginLeft = HCChartObj.xDepth;
        }

        //if the axis has no negative value then set the thresold as max
        
        /*if (StoreChartObj.seriesType === INVERSESERIES && hc.yAxis[0].min >= 0) {
            hc.plotOptions.series.threshold = hc.yAxis[0].max;
        }*/

        //delete configuration
        delete hc['_FCconf'];
        if (window.console && window.console.log && window.FC_DEV_ENVIRONMENT) {
            console.log(hc);
        //hc.title.style.border = '1px solid #ff0000'
        }
        //return the converted object
        return hc;
    },







    ////////////////// block that will configure a y axis (i.e. add min max and create cat//////


    /*
     * this function will set the min max and the tickinterval for a y axis
     */

    axisMinMaxSetter = lib.axisMinMaxSetter = function (aXisObj, axisConf, yAxisMaxValue, yAxisMinValue,
        stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv) {
        var axisLimits;
        if (axisConf.stacking100Percent) {
            axisLimits = getAxisLimits (99, 1, 100, 0, stopMaxAtZero, setMinAsZero,
                numDivLines, adjustDiv);
        }
        else {
            axisLimits = getAxisLimits (pluckNumber(axisConf.max, yAxisMaxValue),
                pluckNumber(axisConf.min, yAxisMinValue), yAxisMaxValue, yAxisMinValue,
                stopMaxAtZero, setMinAsZero, numDivLines, adjustDiv);
        }
        aXisObj.min = Number(toPrecision(axisLimits.Min,10));
        aXisObj.max = Number(toPrecision(axisLimits.Max, 10));
        aXisObj.tickInterval = Number(toPrecision(axisLimits.divGap, 10));

        //fix issue #698
        if (axisLimits.Range / axisLimits.divGap <= 2) {
            aXisObj.alternateGridColor = COLOR_TRANSPARENT;
        }

        //delete the min max
        delete axisConf.max;
        delete axisConf.min;
    },

    /**
     *This function will add plotLines and plotBands For gridLine and alrentenGrid Color
     * Added configuartion for not adding auto calculated X axis labels when there
     *   has category at the same position
     */
    configureAxis = lib.configureAxis = function (FCChartObj, hcJSON, axisObj,
        axisConf, showLimits, showDivLineValues, labelsStep, numberFormatter,
        isSeconderyAxis, isXaxis) {

        var value, min = axisObj.min, max = axisObj.max, interval = axisObj.tickInterval,
        numFormatterStr = isXaxis ? 'xAxis' : (axisConf.stacking100Percent ? 'percentValue' : (isSeconderyAxis ? 'sYAxis' : 'yAxis')),
        lastValue = min, labelIndex = 1, zeroPlaneWidth, zeroPlaneColor,
        gridLineColor = axisObj.gridLineColor, gridLineWidth = axisObj.gridLineWidth,
        gridLineDashStyle = axisObj.gridLineDashStyle, hasZeroPlane = min < INT_ZERO &&
        max > INT_ZERO ? true : false, showZeroPlane = true, zeroPlaneDefaultWidth, text,
        zeroPlaneDefaultAlpha, defaultZIndex = 1, axisGridManager = hcJSON[FC_CONFIG_STRING].axisGridManager;

        //for x axis make sure there has catOccupied obj
        if (isXaxis && !axisConf.catOccupied) {
            axisConf.catOccupied = {};
        }

        /*
         * createt the Zero plane
         */
        if (hasZeroPlane && (!isXaxis || !axisConf.catOccupied[0])) {
            if (isXaxis) {
                showZeroPlane = Boolean(pluckNumber(FCChartObj.showvzeroplane, 1));
                zeroPlaneWidth = pluckNumber(FCChartObj.vzeroplanethickness, 1);
                zeroPlaneColor = zeroPlaneWidth > 0 ? convertColor( pluck(FCChartObj.vzeroplanecolor,
                    gridLineColor), pluck(FCChartObj.vzeroplanealpha, FCChartObj.vdivlinealpha,
                    defaultPaletteOptions.divLineAlpha[hcJSON.chart.paletteIndex ])) : COLOR_TRANSPARENT;
            }
            else {
                zeroPlaneDefaultAlpha = pluckNumber(FCChartObj.divlinealpha,
                    defaultPaletteOptions.divLineAlpha[hcJSON.chart.paletteIndex ])
                //only for spline or line there has a showzeroplane
                if (hcJSON.chart.defaultSeriesType === 'line' || hcJSON.chart.defaultSeriesType ===
                    'spline' || hcJSON[FC_CONFIG_STRING].is3d) {
                    showZeroPlane = Boolean(pluckNumber(FCChartObj.showzeroplane, 1));
                    zeroPlaneDefaultWidth = 1;
                }
                else {
                    zeroPlaneDefaultWidth = gridLineWidth === 1 ? 2 : gridLineWidth;
                    defaultZIndex = 5;
                    zeroPlaneDefaultAlpha *= 2;
                }
                zeroPlaneWidth = pluckNumber(FCChartObj.zeroplanethickness, zeroPlaneDefaultWidth);
                zeroPlaneColor = zeroPlaneWidth > 0 ? convertColor( pluck(FCChartObj.zeroplanecolor,
                    gridLineColor), pluck(FCChartObj.zeroplanealpha, zeroPlaneDefaultAlpha)) :
                COLOR_TRANSPARENT;
            }
            if (showZeroPlane) {
                text = showDivLineValues === 1 ? numberFormatter[numFormatterStr](0) : BLANKSTRING;
                axisGridManager.addAxisGridLine(axisObj, 0, text, zeroPlaneWidth,
                    gridLineDashStyle, zeroPlaneColor, defaultZIndex, isXaxis);
            }
        }
        //min label
        if (showLimits === 1 && (!isXaxis || !axisConf.catOccupied[min])) {
            text = numberFormatter[numFormatterStr](min);
            axisGridManager.addAxisGridLine(axisObj, min, text, 0.1, undefined, COLOR_TRANSPARENT, 1, isXaxis)
        }
        //for zero plane  of width 0 make color TRANSPARENT
        if (gridLineWidth <= 0) {
            gridLineWidth = 0.1;
            gridLineColor = COLOR_TRANSPARENT;
        }


        //calculate divLines
        //Issue #1680 fixed using toPrecision
        value = Number(toPrecision(lastValue + interval, 10));
        for (; value < max; value = Number(toPrecision(value + interval, 10)), labelIndex += 1) {
            //if the zero plane layes between lastValue and value
            if (hasZeroPlane && lastValue < INT_ZERO && value > INT_ZERO && !isSeconderyAxis) {
                //add altGrid
                axisGridManager.addAxisAltGrid(axisObj, 0);
                labelIndex += 1;
            }
            //if it is not zero plane
            if (value !== INT_ZERO && (!isXaxis || !axisConf.catOccupied[value])) {
                text = showDivLineValues === 1 && labelIndex % labelsStep === INT_ZERO ?
                numberFormatter[numFormatterStr](value) : BLANKSTRING;
                axisGridManager.addAxisGridLine(axisObj, value, text, gridLineWidth,
                    gridLineDashStyle, gridLineColor, 2, isXaxis);
            }
            lastValue = value;
            //add altGrid
            if (!isSeconderyAxis) {
                axisGridManager.addAxisAltGrid(axisObj, value);
            }
        }
        //add altGrid
        if (!isSeconderyAxis) {
            axisGridManager.addAxisAltGrid(axisObj, max);
        }

        //max label
        if (showLimits === 1 && labelIndex % labelsStep === INT_ZERO && (!isXaxis || !axisConf.catOccupied[max])) {
            text = numberFormatter[numFormatterStr](max);
            axisGridManager.addAxisGridLine(axisObj, max, text, 0.1, gridLineDashStyle, COLOR_TRANSPARENT, 2, isXaxis)
        }
        //disable default labels and grid
        axisObj.labels.enabled = false;
        axisObj.gridLineWidth = INT_ZERO;
        axisObj.alternateGridColor = COLOR_TRANSPARENT;

        // sorting yAxis to fix negative values in bar chart
        axisObj.plotLines.sort(plotLineSortFN);
    },

    //this function will configure the axis and calculate the originaly space requared for the axis eliments
    
    
    
    yxAxisConfigurer = function (HCObj, FCObj) {
        var conf = HCObj[FC_CONFIG_STRING], xAxisObj = HCObj.xAxis, xConf = conf.x,
        FCchartObj = FCObj.chart,
        yAxisObj, i, len, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
        setMinAsZero, setadaptiveymin,
        numDivLines, adjustDiv, showYAxisValues, showLimits, showDivLineValues,
        yaxisvaluesstep;

        /**
         * configure x axis
         */

        //add xaxisTitle
        xAxisObj.title.text = parseUnsafeString(FCchartObj.xaxisname);

        /**
         * configure y axis
         */

        yaxisvaluesstep = pluckNumber(parseInt(FCchartObj.yaxisvaluesstep, 10), parseInt(FCchartObj.yaxisvaluestep, 10), 1);
        yaxisvaluesstep = yaxisvaluesstep < 1 ? 1 : yaxisvaluesstep;


        yAxisObj = HCObj.yAxis[0], yAxisConf = conf[0];
        if (conf.isDual) {//Dual

            yAxisMaxValue = FCchartObj.pyaxismaxvalue;
            yAxisMinValue = FCchartObj.pyaxisminvalue;

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.pyaxisname);
        }
        else {//single
            yAxisMaxValue = FCchartObj.yaxismaxvalue;
            yAxisMinValue = FCchartObj.yaxisminvalue;

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.yaxisname);
        }

        // adaptiveymin is available for non-stack charts
        setadaptiveymin = pluckNumber(this.isStacked ? 0 : this.setAdaptiveYMin, FCchartObj.setadaptiveymin, 0);

        setMinAsZero = stopMaxAtZero = !setadaptiveymin;
        numDivLines = pluckNumber(conf.numdivlines, FCchartObj.numdivlines, 4);
        adjustDiv = FCchartObj.adjustdiv !== ZEROSTRING;
        showYAxisValues = pluckNumber(this.showYAxisValues, FCchartObj.showyaxisvalues,
            FCchartObj.showyaxisvalue, 1);
        showLimits = pluckNumber(FCchartObj.showlimits, showYAxisValues);
        showDivLineValues = pluckNumber(FCchartObj.showdivlinevalue, FCchartObj.showdivlinevalues,
            showYAxisValues);





        //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
        axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
            setMinAsZero, numDivLines, adjustDiv);

        // create label category and remove trend obj if out side limit
        configureAxis(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
            yaxisvaluesstep, conf.numberFormatter, false);

        if (yAxisObj.reversed && yAxisObj.min >= 0) {
            HCObj.plotOptions.series.threshold = yAxisObj.max;
        }


        //manage secondary axis ////////
        if (conf.isDual) {
            yAxisMaxValue = FCchartObj.syaxismaxvalue;
            yAxisMinValue = FCchartObj.syaxisminvalue;
            setadaptiveymin = pluckNumber(FCchartObj.setadaptivesymin, setadaptiveymin);
            setMinAsZero = stopMaxAtZero = !setadaptiveymin;
            showLimits = pluckNumber(FCchartObj.showsecondarylimits, showLimits);
            showDivLineValues = pluckNumber(FCchartObj.showdivlinesecondaryvalue, showYAxisValues);

            yAxisObj = HCObj.yAxis[1], yAxisConf = conf[1];

            //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
            axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
                setMinAsZero, numDivLines, adjustDiv);

            // create label category and remove trend obj if out side limit
            configureAxis(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
                yaxisvaluesstep, conf.numberFormatter, true);

            // add axis Names
            yAxisObj.title.text = parseUnsafeString(FCchartObj.syaxisname);
        }

    },

    pointValueWatcher = function (HCObj, value, yAxisIndex, isStacked, index,
        stackIndex, seriesName) {
        if ( value !== null) {
            var obj, stackObj, FCconf = HCObj[FC_CONFIG_STRING];
            yAxisIndex = pluckNumber(yAxisIndex, 0);

            if (!FCconf[yAxisIndex]) {
                FCconf[yAxisIndex] = {};
            }
            obj = FCconf[yAxisIndex];
            if (isStacked) {
                if (this.distributedColumns) {
                    FCconf.marimekkoTotal += value;
                }

                stackObj = obj.stack;
                var seriesArr, seriesStackArr, pointIndexObj;
                index = pluckNumber(index, 0);
                stackIndex = pluckNumber(stackIndex, 0);
                seriesName = pluck(seriesName, STRINGUNDEFINED);
                if (!stackObj[seriesName]) {
                    stackObj[seriesName] = [];
                }
                seriesArr = stackObj[seriesName];

                if (!seriesArr[stackIndex]) {
                    seriesArr[stackIndex] = [];
                }
                seriesStackArr = seriesArr[stackIndex];
                if (!seriesStackArr[index]) {
                    seriesStackArr[index] = {};
                }
                pointIndexObj = seriesStackArr[index];

                if (value >= 0) {
                    if (pointIndexObj.p) {
                        value =  pointIndexObj.p += value;
                    }
                    else {
                        pointIndexObj.p = value;
                    }
                }
                else {
                    if (pointIndexObj.n) {
                        value =  pointIndexObj.n += value;
                    }
                    else {
                        pointIndexObj.n = value;
                    }
                }


            }
            obj.max = obj.max > value ? obj.max : value;
            obj.min = obj.min < value ? obj.min : value;
        }
    },

    /*
     *this function will place a vertical axis
     *this function will return the used width
     */
    placeVerticalAxis = lib.placeVerticalAxis = function (axisObj, axisConf,
        hcJSON, fcJSON, axisHeight, maxWidthCanUse, isOnRight, isDual, chartWidth, marginUsed) {
        var conf = hcJSON[FC_CONFIG_STRING],

        SmartLabel = conf.smartLabel, smartifiedTextObj,

        titleWidth, titleHeight, titleText, titleLineHeight, titleMinWidth,
        titleWidthUsed = 0, minTextWidth = 20,

        marginRightExtraSpace = conf.marginRightExtraSpace,
        marginLeftExtraSpace = conf.marginLeftExtraSpace,

        pSameSideGridText = {}, pSameSideNonGridText = {}, pOppSideText = {},
        plotLines = axisObj.plotLines,
        plotBands = axisObj.plotBands,

        verticalAxisValuesPadding = axisConf.verticalAxisValuesPadding,
        verticalAxisOppValuesPadding = axisConf.verticalAxisValuesPadding,
        verticalAxisNamePadding = axisConf.verticalAxisNamePadding,
        verticalAxisNameWidth = axisConf.verticalAxisNameWidth,

        isTitleRotate = axisConf.rotateVerticalAxisName,

        axisSameSideWidth = 0, axisOppSideWidth = 0, totalTBoxSpace = 0,
        labelTotal = 0, samesideText = 0, oppText = 0, samesideLabelWidth = 0,

        index, length, lastUsedStyle, plotObj, labelObj, tempRight,
        tempLeft, difference, temp, lessPadding, heightCorrection = 2,

        analyseAxisElements = function (plotObj, index) {
            var textActualWidth, textWidthWithPadding;
            if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {
                labelObj = plotObj.label;
                //if the style not implemented then implement it
                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                    lastUsedStyle = labelObj.style;
                    SmartLabel.setStyle(lastUsedStyle);
                }
                //get the text Size
                smartifiedTextObj = SmartLabel.getOriSize(plotObj.label.text);
                textActualWidth = smartifiedTextObj.width;
                textWidthWithPadding = textActualWidth ? (textActualWidth + 2) : 0;
                if (plotObj.isGrid) {
                    pSameSideGridText[index] = {
                        width : textActualWidth,
                        height: smartifiedTextObj.height,
                        label : labelObj
                    };
                    if (labelTotal <= textWidthWithPadding) {
                        labelTotal = textWidthWithPadding;
                        axisConf.lYLblIdx = index;
                    }

                } else if (plotObj.isTrend) {
                    if ((isOnRight && labelObj.textAlign === POSITION_LEFT) ||
                        (labelObj.textAlign === POSITION_RIGHT)) {
                        pSameSideNonGridText[index] = {
                            width : textActualWidth,
                            height: smartifiedTextObj.height,
                            label : labelObj
                        };
                        samesideText = mathMax(samesideText, textWidthWithPadding);
                    } else {
                        pOppSideText[index] = {
                            width : textActualWidth,
                            height: smartifiedTextObj.height,
                            label : labelObj
                        };
                        oppText = mathMax(oppText, textWidthWithPadding);
                    }
                }
            }
        },

        checkAndReallocateSpace = function () {
            // There has not sufficient space
            if (axisOppSideWidth + axisSameSideWidth > maxWidthCanUse) {
                difference = axisOppSideWidth + axisSameSideWidth - maxWidthCanUse;

                if (axisOppSideWidth) {
                    if (verticalAxisOppValuesPadding >= difference) {
                        verticalAxisOppValuesPadding -= difference
                        return;
                    } else {
                        difference -= verticalAxisOppValuesPadding;
                        verticalAxisOppValuesPadding = 0;
                    }
                }

                if ((verticalAxisValuesPadding + verticalAxisNamePadding) >= difference) {
                    if (verticalAxisNamePadding >= difference) {
                        verticalAxisNamePadding -= difference;
                        return;
                    } else {
                        verticalAxisValuesPadding -= (difference - verticalAxisNamePadding);
                        verticalAxisNamePadding = 0;
                        return
                    }
                } else {
                    difference -= (verticalAxisValuesPadding + verticalAxisNamePadding);
                    verticalAxisValuesPadding = 0;
                    verticalAxisNamePadding = 0;

                    if (oppText > minTextWidth) {
                        if (samesideText > labelTotal) {
                            if ((oppText - samesideText) >= difference) {
                                oppText -= difference;
                                return;
                            } else if ((samesideText - oppText) >= difference) {
                                samesideText -= difference;
                                return;
                            } else {
                                if (samesideText > oppText) {
                                    difference -= (samesideText - oppText);
                                    samesideText = oppText;
                                } else {
                                    difference -= (oppText - samesideText);
                                    oppText = samesideText;
                                }

                                if (2 * (samesideText - labelTotal) >= difference) {
                                    oppText -= (difference / 2);
                                    samesideText -= (difference / 2);
                                    return;
                                } else {
                                    difference -= 2 * (samesideText - labelTotal);
                                    samesideText = labelTotal;
                                    oppText = labelTotal;
                                }
                            }
                        } else if ((oppText - minTextWidth) >= difference) {
                            oppText -= difference;
                            return;
                        } else {
                            difference -= (oppText - minTextWidth);
                            oppText = minTextWidth;
                        }
                    }

                    if (samesideText > labelTotal) {
                        if ((samesideText - labelTotal) >= difference) {
                            samesideText -= difference;
                            return;
                        } else {
                            difference -= (samesideText - labelTotal);
                            samesideText = labelTotal;
                        }
                    }

                    if (titleWidthUsed - titleMinWidth >= difference) {
                        titleWidthUsed -= difference;
                        return;
                    } else {
                        difference -= (titleWidthUsed - titleMinWidth);
                        titleWidthUsed = titleMinWidth;

                        if (oppText >= difference) {
                            oppText = 0;
                            return;
                        } else {
                            difference -= oppText;
                            oppText = 0;
                        }

                        if (titleWidthUsed >= difference) {
                            titleWidthUsed = 0;
                            return;
                        } else {
                            difference -= titleWidthUsed;
                            titleWidthUsed = 0;
                        }

                        if (labelTotal >= difference) {
                            labelTotal -= difference;
                            samesideText = labelTotal;
                            return;
                        }
                    }
                }
            }
            return;
        },

        renderOppSideText = function (surplusWidth, isBubble) {
            //place the axis labels
            var tempSmartLabel, maxActualWidth = 0,
            workingWidth = isBubble ? (oppText - 2) : (oppText + surplusWidth - 2);

            if (oppText > 0) {
                for (index in pOppSideText) {
                    labelObj = pOppSideText[index].label;
                    if (pOppSideText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text,
                            workingWidth, axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        pOppSideText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pOppSideText[index].width);
                    }
                }
                return (isBubble ? (workingWidth - maxActualWidth) + surplusWidth
                    : (workingWidth - maxActualWidth));

            } else {
                for (index in pOppSideText) {
                    pOppSideText[index].label.text = BLANKSTRING;
                }
                return 0;
            }
        },

        renderTitle = function (surplusWidth, isBubble) {

            var actualWidth, workingWidth = isBubble ? titleWidthUsed
            : (titleWidthUsed + surplusWidth);

            if (workingWidth > 0) {
                if (isTitleRotate){
                    if (workingWidth < titleText.height) {
                        //now get the title space
                        titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, workingWidth);
                    }
                    actualWidth = titleText.height;
                }
                else {
                    if (workingWidth < titleText.width) {
                        titleText = SmartLabel.getSmartText(axisObj.title.text, workingWidth, axisHeight);
                    }
                    actualWidth = titleText.width;
                }
                axisObj.title.text = titleText.text;
                return (isBubble ? (workingWidth - actualWidth) + surplusWidth
                    : (workingWidth - actualWidth));
            } else {
                //remove the text
                axisObj.title.text = BLANKSTRING;
                return 0;
            }
        },

        renderSameSideText = function (surplusWidth) {
            //place the axis labels
            var tempSmartLabel, maxActualWidth = 0,
            workingWidth = (Math.max(labelTotal, samesideText) + surplusWidth - 2);

            if (workingWidth > 0) {
                for (index in pSameSideGridText) {
                    labelObj =  pSameSideGridText[index].label;
                    if (pSameSideGridText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                            axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        pSameSideGridText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pSameSideGridText[index].width);
                    }
                }

                for (index in pSameSideNonGridText) {
                    labelObj =  pSameSideNonGridText[index].label;
                    if (pSameSideNonGridText[index].width > workingWidth) {
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }
                        tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                            axisHeight, true);
                        labelObj.text = tempSmartLabel.text;
                        pSameSideNonGridText[index].height = tempSmartLabel.height;
                        maxActualWidth = Math.max(maxActualWidth, tempSmartLabel.width);
                    } else {
                        maxActualWidth = Math.max(maxActualWidth, pSameSideNonGridText[index].width);
                    }
                }

                return (workingWidth - maxActualWidth);
            } else {
                for (index in pSameSideGridText) {
                    pSameSideGridText[index].label.text = BLANKSTRING;
                }

                for (index in pSameSideNonGridText) {
                    pSameSideNonGridText[index].label.text = BLANKSTRING;
                }

                return 0;
            }
        },

        setLabelsXY = function (labelContainerObj, x, y) {
            var index;
            for (index in labelContainerObj) {
                labelContainerObj[index].label.x = x;
                labelContainerObj[index].label.y = y;
            }
        };

        //iterate through plotLines and find the divlines
        for (index = 0, length = plotBands.length; index < length; index += 1) {
            analyseAxisElements(plotBands[index], index);
        }

        //iterate through plotLines and find the divlines
        for (index = 0, length = plotLines.length; index < length; index += 1) {
            analyseAxisElements(plotLines[index], index);
        }

        if (axisObj.title && axisObj.title.text != BLANKSTRING) {
            lastUsedStyle = axisObj.title.style;
            SmartLabel.setStyle(lastUsedStyle);
            //now get the title space
            titleLineHeight = SmartLabel.getOriSize(TESTSTR).height;
            if (isTitleRotate) {
                titleWidth = axisHeight;
                titleHeight = maxWidthCanUse;
                titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                titleWidthUsed = titleText.height;
                titleMinWidth = titleLineHeight;
            } else {
                axisObj.title.rotation = 0;
                titleWidth = verticalAxisNameWidth !== undefined ?
                verticalAxisNameWidth : maxWidthCanUse;
                titleHeight = axisHeight;
                titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                titleWidthUsed = titleText.width;
                titleMinWidth = minTextWidth;
            }
        }

        if (oppText > 0) {
            axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
        }

        if (chartWidth) { // is a bar chart
            var maxLabelWidth, mlwp = pluckNumber(fcJSON.chart.maxlabelwidthpercent, 0);
            if (mlwp >= 1 && mlwp <= 100) {
                maxLabelWidth = (mlwp * chartWidth / 100);
                if (labelTotal > maxLabelWidth) {
                    labelTotal = maxLabelWidth;
                }
            }
        }

        axisSameSideWidth = mathMax(samesideText, labelTotal);

        if (titleWidthUsed > 0) {
            axisSameSideWidth += totalTBoxSpace = titleWidthUsed + 2 + verticalAxisNamePadding;
        }

        checkAndReallocateSpace();

        surplusWidth = renderOppSideText(0, true);
        surplusWidth = renderTitle(surplusWidth, true);
        surplusWidth = renderSameSideText(surplusWidth);
        surplusWidth = renderTitle(surplusWidth);

        lessPadding = axisConf.verticalAxisNamePadding - verticalAxisNamePadding;
        if (surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                verticalAxisNamePadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                verticalAxisNamePadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        lessPadding = axisConf.verticalAxisValuesPadding - verticalAxisValuesPadding;
        if ( surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                verticalAxisValuesPadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                verticalAxisValuesPadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        lessPadding = axisConf.verticalAxisOppValuesPadding - verticalAxisOppValuesPadding;
        if ( surplusWidth && lessPadding) {
            if (surplusWidth > lessPadding) {
                verticalAxisOppValuesPadding += lessPadding;
                surplusWidth -= lessPadding;
            } else {
                verticalAxisOppValuesPadding += surplusWidth;
                surplusWidth = 0;
            }
        }

        if (oppText > 0) {
            axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
        }

        axisSameSideWidth = mathMax(samesideText, labelTotal) + verticalAxisValuesPadding;
        if (titleWidthUsed > 0) {
            axisSameSideWidth += totalTBoxSpace = titleWidthUsed + verticalAxisNamePadding;
        }

        //all element's space is calculated now place them
        temp = mathMax(samesideText, labelTotal);
        temp += temp > 0 ? verticalAxisNamePadding : 0;

        //place title
        //**don't update the style as it is the last used style
        if (titleWidthUsed > 0) {

            temp += verticalAxisNamePadding + (temp > 0 ? 2 : 0);
            if (isTitleRotate){
                if (titleWidthUsed < titleText.height) {
                    //now get the title space
                    titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, titleWidthUsed);
                }

            }
            else {
                if (titleWidthUsed < titleText.width) {
                    titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidthUsed, axisHeight);
                }
                axisObj.title.y = - ((titleText.height - titleLineHeight) / 2); // 4 is for <br/> correction
            }
            axisObj.title.text = titleText.text;
            axisObj.title.margin = temp + marginLeftExtraSpace + (isTitleRotate ? titleText.height -
                titleLineHeight : titleText.width / 2);
        }
        else {
            //remove the text
            axisObj.title.text = BLANKSTRING;
        }

        /*
         *new logic: store only the text width of plotlines and the plot bands
         *during final sizing zust loop through the plotLined and the plot
         *Band then decide it is label/same text/ opp text
         *then configure it
         */
        tempLeft = -(verticalAxisValuesPadding + marginLeftExtraSpace + 2);//text padding 2px
        tempRight = marginRightExtraSpace + verticalAxisValuesPadding + 2;//text padding 2px
        samesideLabelWidth = mathMax(samesideText, labelTotal);
        if (axisObj.labels.style) {
            heightCorrection = parseInt(axisObj.labels.style.fontSize, 10) * 0.35;
        }

        //place the axis labels
        if (isOnRight) {
            if (oppText > 0) {
                setLabelsXY(pOppSideText, tempLeft, heightCorrection);
            }

            if (samesideLabelWidth > 0) {
                setLabelsXY(pSameSideGridText, tempRight, heightCorrection);
                setLabelsXY(pSameSideNonGridText, tempRight, heightCorrection);
            }
        } else {
            if (oppText > 0) {
                setLabelsXY(pOppSideText, tempRight, heightCorrection);
            }

            if (samesideLabelWidth > 0) {
                setLabelsXY(pSameSideGridText, tempLeft, heightCorrection);
                setLabelsXY(pSameSideNonGridText, tempLeft, heightCorrection);
            }
        }

        if (marginUsed) {
            hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : (axisSameSideWidth - marginUsed);
            hcJSON.chart.marginRight += isOnRight ? (axisSameSideWidth - marginUsed) : axisOppSideWidth;
        } else {
            hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : axisSameSideWidth;
            hcJSON.chart.marginRight += isOnRight ? axisSameSideWidth : axisOppSideWidth;
        }
        return axisOppSideWidth + axisSameSideWidth;

    },

    /*
     *This function willplace the title to a speciffied width & height
     */
    titleSpaceManager = lib.titleSpaceManager =  function (hcJSON, fcJSON, canvasWidth,
        allowedHeight) {
        var fcChartObj = fcJSON.chart, titleText = parseUnsafeString(fcChartObj.caption),
        subTitleText = parseUnsafeString(fcChartObj.subcaption), captionPadding, oriCapPadding =
        captionPadding = pluckNumber(fcChartObj.captionpadding, 10), conf = hcJSON[FC_CONFIG_STRING],
        SmartLabel = conf.smartLabel, isPaddingReduced = false, captionObj,
        subcaptionObj, totalHeight = 0, capStyle, subCapStyle, difference = 0,
        extraSpace = 0, captionLineHeight = 0, subCaptionLineHeight = 0,
        subCaptionFontSize = 0, captionFontSize = 0,
        titleObj = hcJSON.title, subTitleObj = hcJSON.subtitle;

        if (titleText !== BLANKSTRING) {//calculatethe single line's height
            capStyle = titleObj.style;
            captionLineHeight = pluckNumber(parseInt(capStyle.fontHeight, 10), parseInt(capStyle.lineHeight, 10), 12);
            captionFontSize = pluckNumber(parseInt(capStyle.fontSize, 10), 10);
        }
        if (subTitleText !== BLANKSTRING) {
            subCapStyle = subTitleObj.style;
            subCaptionLineHeight = pluckNumber(parseInt(subCapStyle.fontHeight, 10), parseInt(subCapStyle.lineHeight, 10), 12);
            subCaptionFontSize = pluckNumber(parseInt(subCapStyle.fontSize, 10), 10);
        }

        if (captionLineHeight > 0 || subCaptionLineHeight > 0) {
            //calculate the min height requared

            totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
            //now decide whether it has space shgaortfall or excess
            if (totalHeight > allowedHeight) {
                difference = totalHeight - allowedHeight;
                isPaddingReduced = true;
                //first reduce the padding
                if (difference < captionPadding) {
                    captionPadding -= difference;
                }
                else {//if the difference is more then padding then remove the subcap also
                    difference -= captionPadding;
                    captionPadding = 0;
                    //if the subcap is gretter then diff add the remaning space to the extraSpace
                    if (subCaptionLineHeight > difference) {
                        extraSpace = (subCaptionLineHeight - difference) + 10;
                        subCaptionLineHeight = 0;
                    }
                    else {
                        difference -= subCaptionLineHeight;
                        subCaptionLineHeight = 0;
                        //now remove the caption also
                        if (captionLineHeight > difference) {
                            extraSpace = captionLineHeight - difference;
                        }
                        captionLineHeight = 0;
                        difference = 0;
                    }

                }
            }
            else {
                extraSpace = allowedHeight - totalHeight;
            }

            ////// now place the elements

            if (captionLineHeight > 0) {
                //set the caption style and get the caption's requared space
                SmartLabel.setStyle(capStyle);
                captionLineHeight += extraSpace;
                captionObj = SmartLabel.getSmartText(titleText, canvasWidth, captionLineHeight);
                extraSpace = captionLineHeight - captionObj.height;
                captionLineHeight = captionObj.height;
                titleObj.text = captionObj.text;
                titleObj.y = captionFontSize;
            }
            if (subCaptionLineHeight > 0) {
                //set the caption style and get the caption's requared space
                SmartLabel.setStyle(subCapStyle);
                subCaptionLineHeight += extraSpace;
                subcaptionObj = SmartLabel.getSmartText(subTitleText, canvasWidth, subCaptionLineHeight);
                extraSpace = subCaptionLineHeight - subcaptionObj.height;
                subCaptionLineHeight = subcaptionObj.height;
                subTitleObj.text = subcaptionObj.text;
                subTitleObj.y = subCaptionFontSize + captionLineHeight;
            }
            if (isPaddingReduced && extraSpace > 0) {
                captionPadding += mathMin(oriCapPadding - captionPadding, extraSpace);
            }
            ////now add the top margin
            totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
            hcJSON.chart.marginTop += totalHeight;
        }
        return totalHeight;
    },



    
    

    stepYAxisNames = lib.stepYAxisNames = function (canvasHeight, hcJSON, fcJSONChart, axisObj, labelIdx, isBar) {
        var i = 0, plotLines = axisObj.plotLines, gridLines = [], startIdx, marker,
        length = axisObj.plotLines.length, plotObj, stepValue, perLabelHeight,
        testStr = 'W', SmartLabel = hcJSON[FC_CONFIG_STRING].smartLabel, lineHeight,
        fontSize = parseFloat(pluckFontSize(fcJSONChart.basefontsize, 10)), prevPlot;

        for (; i < length; i += 1) {
            plotObj = plotLines[i];
            if (plotObj.isGrid && plotObj.label && plotObj.label.text) {
                gridLines.push(plotObj);
                if (plotObj.value === 0) {
                    startIdx = gridLines.length - 1;
                }
            }
        }

        length = gridLines.length;

        if (length) {
            if (axisObj.labels.style) {
                SmartLabel.setStyle(axisObj.labels.style);
            } else if (gridLines[0].label && gridLines[0].label.style) {
                SmartLabel.setStyle(axisObj.labels.style);
            }


            lineHeight = SmartLabel.getOriSize(testStr).height;

            if (!isBar) {
                lineHeight += (fontSize * 0.4); // padding in case of non bar charts to make the labels look visiually aesthetic
            }

            perLabelHeight = canvasHeight / (length - 1);

            if (perLabelHeight < lineHeight) {
                stepValue = Math.ceil(lineHeight / perLabelHeight);

                marker = startIdx;
                for (i = startIdx; i < length; i += 1) {
                    plotObj = gridLines[i];
                    if (i === labelIdx) {
                        if (((i - marker) % stepValue) && prevPlot) {
                            prevPlot.label.text = "";
                        }
                        marker = labelIdx;
                    }
                    if (plotObj && plotObj.label) {
                        if ((i - marker) % stepValue) {
                            plotObj.label.text = BLANKSTRING;
                        } else {
                            prevPlot = plotObj;
                        }
                    }
                }

                marker = startIdx;
                for (i = startIdx; i >= 0; i -= 1) {
                    plotObj = gridLines[i];
                    if (i === labelIdx) {
                        if (((marker - i) % stepValue) && prevPlot) {
                            prevPlot.label.text = "";
                        }
                        marker = labelIdx;
                    }
                    if (plotObj && plotObj.label) {
                        if ((marker - i) % stepValue) {
                            plotObj.label.text = BLANKSTRING;
                        } else {
                            prevPlot = plotObj;
                        }
                    }
                }
            }
        }
    },

    placeHorizontalAxis = lib.placeHorizontalAxis =  function (axisObj, axisConf, hcJSON,
        fcJSON, width, maxHeight, minCanWidth) {

        var conf = hcJSON[FC_CONFIG_STRING],

        textObj, plotObj, index, titleText, labelObj,
        lastUsedStyle, minWidth, temp, maxStaggerLines, tempLabelWidth,
        labelTextWidth, labelTextPadding = 4, autoWrapLimit,

        rotation = 0, titleHeightUsed = 0, labelHeight = 10, stepValue = 1,
        labelY = 0, nameLineHeight = 0, catCount = 0, testStr = 'W',

        noWrap = false, isStagger = false, isNone = false,

        isStepped = pluckNumber(fcJSON.chart.labelstep, 0),
        labelDisplay = axisConf.labelDisplay,
        labelPadding = axisConf.horizontalLabelPadding,

        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        availableSpaceLeft = hcJSON.chart.marginLeft,
        availableSpaceRight = hcJSON.chart.marginRight,

        SmartLabel = conf.smartLabel,

        catLen = axisConf.catCount,
        slantLabels = axisConf.slantLabels,
        unitWidth = width / (axisObj.max - axisObj.min),

        
        tedendHeight = 0, oppTrendHeight = 0, labelSize = {
            w: 0,
            h: 0
        };

        if (axisObj.labels.style) {
            lastUsedStyle = axisObj.labels.style;
            SmartLabel.setStyle(lastUsedStyle);
            temp = SmartLabel.getOriSize(testStr);
            labelHeight = temp.height;
            minWidth = temp.width + labelTextPadding;
            autoWrapLimit = SmartLabel.getOriSize("WWW").width + labelTextPadding;
        }

        var axisMin, axisMax, labelEdge, leftModify, rightModify, excessWidth, i,
        plotLinesArr, plotBandsArr, gridLinesArr = [], nonGridLinesArr = [],
        chartPlotWidth, firstDifference = 0, lastDifference = 0, lastGridIndex,
        gridLinesLen, perCatWidth, canvasLeftSpace, canvasRightSpace,
        totalDifference, length, xAxisNamePadding = axisConf.horizontalAxisNamePadding, labelSpace = 0,
        staggerLines = axisConf.staggerLines, bottomSpace = tedendHeight, isXYPlot = false,
        widthToAdd, padWidth;

        if (axisObj.title && axisObj.title.text != BLANKSTRING) {
            lastUsedStyle = axisObj.title.style;
            SmartLabel.setStyle(lastUsedStyle);
            nameLineHeight = SmartLabel.getOriSize(testStr).height;
            //now get the title space
            axisObj.title.rotation = 0;
            titleText = SmartLabel.getSmartText(axisObj.title.text, width, maxHeight);
            titleHeightUsed = titleText.height;
        }

        if (hcJSON.chart.marginLeft != parseInt(fcJSON.chart.chartleftmargin, 10)) {
            leftModify = true;
        }
        if (hcJSON.chart.marginRight != parseInt(fcJSON.chart.chartrightmargin, 10)) {
            rightModify = true;
        }

        // if the chartmargin is to be changed to accomodate the first and last labels
        // then excessWidth is the limit upto which the total chartmargins can be changed.
        excessWidth = width - minCanWidth;

        switch (labelDisplay) {
            case 'none':
                isNone = true;
                noWrap = true;
                break;
            case 'rotate':
                if (slantLabels) {
                    rotation = 300;
                } else {
                    rotation = 270;
                }
                temp = labelHeight;
                labelHeight = minWidth;
                minWidth = temp;
                noWrap = true;
                break;
            case 'stagger':
                noWrap = true;
                isStagger = true;
                maxStaggerLines = Math.floor((maxHeight - nameLineHeight) / labelHeight);
                if (maxStaggerLines < staggerLines) {
                    staggerLines = maxStaggerLines;
                }
                break;
            default ://none

        }

        if (conf.isBar) {
            noWrap = true;
        }
        // if the chart is not scatter chart
        i = 0;
        plotLinesArr = axisObj.plotLines;

        if (typeof hcJSON._FCconf.isXYPlot === STRINGUNDEFINED && !conf.isBar) {

            // 1. segregate the grid plot lines from the non grid plot lines
            for (length = plotLinesArr.length; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj) {
                    if (plotObj.isGrid) {
                        gridLinesArr.push(plotObj);
                    } else if (plotObj.isTrend) {
                        nonGridLinesArr.push(plotObj);
                    }
                }
            }

            plotBandsArr = axisObj.plotBands;

            for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                plotObj = plotBandsArr[i];
                if (plotObj) {
                    nonGridLinesArr.push(plotObj);
                }
            }

            lastGridIndex = gridLinesArr.length - 1;
            gridLinesLen = gridLinesArr.length;

            if (isStagger) {
                if (staggerLines > gridLinesLen) {
                    staggerLines = gridLinesLen;
                } else if (staggerLines < 2) {
                    staggerLines = 2;
                }
            }

            if (gridLinesLen) {
                if (axisObj.scroll && axisObj.scroll.viewPortMin && axisObj.scroll.viewPortMax) {
                    axisMin = axisObj.scroll.viewPortMin;
                    axisMax = axisObj.scroll.viewPortMax;
                    leftModify = false;
                    rightModify = false;
                } else {
                    axisMin = axisObj.min;
                    axisMax = axisObj.max;
                }
                // 2. calculate width for each label

                chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                perCatWidth = chartPlotWidth / (catLen - 1);
                canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;

                if (labelDisplay === 'auto') {
                    if (perCatWidth < autoWrapLimit) {
                        if (slantLabels) {
                            rotation = 300;
                        } else {
                            rotation = 270;
                        }
                        temp = labelHeight;
                        labelHeight = minWidth;
                        minWidth = temp;
                        noWrap = true;
                    }
                } else if (labelDisplay === 'stagger') {
                    perCatWidth *= staggerLines;
                }

                // 4. calculate width for first label
                tempLabelWidth = (canvasLeftSpace + availableSpaceLeft) * 2;

                // if the distance b/w the first data point and min is greater than the distace between two adjacent data points
                labelObj = plotLinesArr[0].label;
                if (labelObj && labelObj.text) {
                    if (labelObj.style) {
                        SmartLabel.setStyle(labelObj.style);
                    }
                    labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                    // if the label doesnt fit in the given space
                    if (labelTextWidth > tempLabelWidth) {
                        firstDifference = (labelTextWidth - tempLabelWidth) / 2;
                    }
                }

                // 5. calculate width for the last label
                tempLabelWidth = (canvasRightSpace + availableSpaceRight) * 2;

                // if the distance b/w the first data point and min is greater than the distace between two adjacent data points
                labelObj = plotLinesArr[lastGridIndex].label;
                if (labelObj && labelObj.text) {
                    if (labelObj.style) {
                        SmartLabel.setStyle(labelObj.style);
                    }
                    labelTextWidth = Math.min(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                    // if the label doesnt fit in the given space
                    if (labelTextWidth > tempLabelWidth) {
                        lastDifference = (labelTextWidth - tempLabelWidth) / 2;
                    }
                }

                // 6. do we need to change chart margin or canvas padding?
                totalDifference = firstDifference + lastDifference;
                if (totalDifference > 0) {
                    if (excessWidth > totalDifference) { // change the chart margins
                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                        hcJSON.chart.marginRight += reductionFactor;
                        width -= reductionFactor;

                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                        hcJSON.chart.marginLeft += reductionFactor;
                        width -= reductionFactor;

                        unitWidth = width / (axisObj.max - axisObj.min);
                    } else { //change the padding
                        if (firstDifference < lastDifference) {
                            // try and remove the greater of the two from chart margin
                            if ((excessWidth >= lastDifference) && rightModify) {
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);

                            } else if (leftModify) {
                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);
                            }
                        } else {
                            if ((excessWidth >= firstDifference) && leftModify) {
                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);

                            } else if (rightModify) {
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;
                                unitWidth = width / (axisObj.max - axisObj.min);
                            }
                        }
                    }
                    chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                    perCatWidth = chartPlotWidth / (catLen - 1);
                }

                if (!isStagger && !isNone) {
                    stepValue = Math.ceil(minWidth / perCatWidth);
                    if (isStepped) {
                        perCatWidth *= isStepped;
                        stepValue = Math.ceil(minWidth / perCatWidth);
                    }
                    perCatWidth *= stepValue;
                }

                // start setting the label dimensions
                for(index = 0; index < gridLinesLen; index += 1) {

                    plotObj = gridLinesArr[index];

                    if (index % stepValue && plotObj.label) {
                        plotObj.label.text = BLANKSTRING;
                        continue;
                    }

                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (!isNone) {
                            if (rotation || isStagger) {
                                textObj = SmartLabel.getOriSize(labelObj.text);
                            }
                            else {//wrap
                                textObj = SmartLabel.getSmartText(labelObj.text, (perCatWidth - labelTextPadding), // 4px is removed for label padding
                                    maxHeight, noWrap);
                            }
                            labelSize.w = mathMax(labelSize.w, textObj.width + labelTextPadding);
                            labelSize.h = mathMax(labelSize.h, textObj.height);
                        }
                    }
                }
            }

            for(index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                plotObj = nonGridLinesArr[index];

                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    textObj = SmartLabel.getOriSize(labelObj.text);
                    if (labelObj.verticalAlign === POSITION_BOTTOM) {
                        tedendHeight= mathMax(tedendHeight, textObj.height);
                    } else {
                        oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                    }
                }
            }

            if (axisObj.scroll && axisObj.scroll.enabled && !rotation && !isNone) {
                widthToAdd = labelSize.w / 2;
                if (hcJSON.chart.marginLeft < widthToAdd) {
                    padWidth = widthToAdd - hcJSON.chart.marginLeft;
                    if (excessWidth > padWidth) {
                        width -= padWidth;
                        excessWidth -= padWidth;
                        hcJSON.chart.marginLeft += padWidth;
                    }
                }
                if (hcJSON.chart.marginRight < widthToAdd) {
                    padWidth = widthToAdd - hcJSON.chart.marginRight;
                    if (excessWidth > padWidth) {
                        width -= padWidth;
                        excessWidth -= padWidth;
                        hcJSON.chart.marginRight += padWidth;
                    }
                }
            }
        } else {

            // Variables for scatter and bar charts
            var catLinesArr = {}, lowerThreshold, upperThreshold, newObj,
            leadingEdge = 0, trailingEdge = 0, nextItem, rem, firstCat = null, lastCat = null, nextCat, prevCat,
            plotPx, len, reductionFactor, gridLineObj, lineIndex,
            prevCatMap = {}, prevGrid, leftSpace, rightSpace, nextGrid, lastEdge,
            nextEdge, labelWidth;

            isXYPlot = true;

            unitWidth = width / (axisObj.max - axisObj.min);

            var setSuccessiveCategoryWidths = function (categoryObj1, categoryObj2, isStrict) {

                var px1, le1, te2, px2, labelWidth1, labelWidth2,
                edgeDiff, plotDiff, plotObj1, plotObj2;

                plotObj1 = categoryObj1.plotObj;
                labelWidth1 = categoryObj1.labelTextWidth;

                if (!labelWidth1) { // first label;
                    labelObj = plotObj1.label;
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    labelWidth1 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                    categoryObj1.oriWidth = labelWidth1;

                    if (labelWidth1 > lowerThreshold) {
                        labelWidth1 = lowerThreshold;
                    }

                    categoryObj1.labelTextWidth = labelWidth1;
                    categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                    categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);

                    if (isStrict) {
                        labelWidth1 = Math.min(labelWidth1, 2 * ((plotObj.value - axisObj.min) * unitWidth) + hcJSON.chart.marginLeft);
                        categoryObj1.labelTextWidth = labelWidth1;
                    }
                }

                if (typeof categoryObj2 !== STRINGUNDEFINED) {

                    plotObj2 = categoryObj2.plotObj;

                    labelObj = plotObj2.label;

                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    if (categoryObj2.oriWidth) {
                        labelWidth2 = categoryObj2.oriWidth;
                    } else {
                        labelWidth2 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                        categoryObj2.oriWidth = labelWidth2;
                    }

                    if (labelWidth2 > lowerThreshold) {
                        labelWidth2 = lowerThreshold;
                    }

                    categoryObj2.labelTextWidth = labelWidth2;
                    categoryObj2.leftEdge = (plotObj2.value * unitWidth) - (labelWidth2 / 2);
                    categoryObj2.rightEdge = (plotObj2.value * unitWidth) + (labelWidth2 / 2);

                    px1 = plotObj1.value * unitWidth;
                    le1 = px1 + (labelWidth1 / 2);

                    px2 = plotObj2.value * unitWidth;
                    te2 = px2 - (labelWidth2 / 2);

                    if (te2 < le1) {
                        if ((px1 + minWidth) < ( px2 - minWidth)) {
                            edgeDiff = le1 - te2;
                            plotDiff = px2 - px1;
                            if (edgeDiff > plotDiff) {
                                categoryObj1.labelTextWidth = Math.min(labelWidth1, plotDiff);
                            } else {
                                categoryObj1.labelTextWidth = Math.max(minWidth, (labelWidth1 - (edgeDiff / 2)));
                            }
                            categoryObj2.labelTextWidth = 2 * (plotDiff - (categoryObj1.labelTextWidth / 2));

                            categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (categoryObj1.labelTextWidth / 2);
                            categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (categoryObj1.labelTextWidth / 2);

                            categoryObj2.leftEdge = (plotObj2.value * unitWidth) - (categoryObj2.labelTextWidth / 2);
                            categoryObj2.rightEdge = (plotObj2.value * unitWidth) + (categoryObj2.labelTextWidth / 2);

                        } else {
                            categoryObj2.labelTextWidth = 0;
                            plotObj2.label.text = BLANKSTRING;
                            return false;
                        }
                    }
                } else if (isStrict){ // is lastLabel
                    labelWidth1 = Math.min(labelWidth1, 2 * ((axisObj.max - plotObj.value) * unitWidth) + hcJSON.chart.marginRight);
                    categoryObj1.labelTextWidth = labelWidth1;
                    categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                    categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);
                }

                categoryObj1.nextCat = categoryObj2;
                return true;
            };

            // wrap or stagger
            if (isStagger) {
                if (staggerLines > gridLinesLen) {
                    staggerLines = gridLinesLen;
                } else if (staggerLines < 2) {
                    staggerLines = 2;
                }
            } else {
                staggerLines = 1;
            }

            for (length = plotLinesArr.length; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj && plotObj.label && (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                    if (plotObj.isGrid) {
                        newObj = {
                            plotObj: plotObj
                        };
                        if (plotObj.isCat) {
                            rem = i % staggerLines;
                            if (!catLinesArr[rem]) {
                                catLinesArr[rem] = [];
                            }
                            if (!firstCat) {
                                firstCat = newObj;
                                lastCat = newObj; // in case there is only one category label first and last are the same.
                                catLinesArr[rem].push(firstCat);
                            } else {
                                lastCat = newObj;
                                catLinesArr[rem].push(lastCat);
                            }
                        }
                        gridLinesArr.push(newObj);
                    } else if (plotObj.isTrend) {
                        nonGridLinesArr.push({
                            plotObj: plotObj
                        });
                    }
                }
            }

            plotBandsArr = axisObj.plotBands;
            for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                plotObj = plotBandsArr[i];
                if (plotObj && plotObj.isTrend && plotObj.label && (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                    nonGridLinesArr.push({
                        plotObj: plotObj
                    });
                }
            }

            if (gridLinesArr.length) {
                if (!isNone && !rotation) {
                    if (conf.distributedColumns) {
                        var plotRight, plotLeft;

                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            lineIndex = i % staggerLines;

                            plotObj = gridLineObj.plotObj;
                            if (!plotObj.label) {
                                continue;
                            }

                            if (plotObj.isCat) {
                                if (i - staggerLines >= 0) {
                                    prevCat = gridLinesArr[i - staggerLines];
                                    lastEdge = prevCat.plotObj.value * unitWidth + prevCat.plotObj._weight * unitWidth / 2;
                                } else {
                                    prevCat = null;
                                    lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                }

                                if (i + staggerLines < length) {
                                    nextCat = gridLinesArr[i + staggerLines];
                                    nextEdge = nextCat.plotObj.value * unitWidth - nextCat.plotObj._weight * unitWidth / 2;
                                } else {
                                    nextCat = null;
                                    nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                }

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }

                                plotPx = plotObj.value * unitWidth;
                                plotLeft = plotPx - plotObj._weight * unitWidth / 2;
                                plotRight = plotPx + plotObj._weight * unitWidth / 2;

                                if (staggerLines > 1) {
                                    leftSpace = plotLeft - lastEdge;
                                    rightSpace = plotRight + nextEdge;
                                    labelWidth  = plotRight - plotLeft + Math.min(leftSpace, rightSpace);
                                } else {
                                    labelWidth = plotRight - plotLeft;
                                }

                                labelObj = plotObj.label;

                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                if (labelWidth < minWidth && minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                    plotObj.label.text = BLANKSTRING;
                                    gridLineObj.labelTextWidth = 0;
                                    continue;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding), maxHeight, noWrap);
                                labelWidth = textObj.width + labelTextPadding;

                                gridLineObj.labelTextWidth = labelWidth;
                                labelSize.h = Math.max(labelSize.h, textObj.height);
                            }
                        }
                    } else {
                        gridLinesLen = gridLinesArr.length;
                        lastGridIndex = gridLinesArr.length - 1;

                        chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value - gridLinesArr[0].plotObj.value) * unitWidth;
                        if (chartPlotWidth) {
                            lowerThreshold = chartPlotWidth * 0.1;
                            upperThreshold = Math.max(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                        } else { // there is only one grid label.
                            lowerThreshold = width;
                            upperThreshold = width;
                        }
                        //1. start calulating the widths of the category labels as they have higher priority
                        for (index in catLinesArr) {
                            i = 0;
                            len = catLinesArr[index].length;

                            while (i < len) {
                                nextItem = i + 1;
                                while (!setSuccessiveCategoryWidths(catLinesArr[index][i], catLinesArr[index][nextItem])) {
                                    nextItem += 1;
                                }
                                i = nextItem;
                            }
                        }

                        //2. find the trailing edge of first category label.
                        if (firstCat) {
                            trailingEdge = ((firstCat.plotObj.value - axisObj.min) * unitWidth) + availableSpaceLeft - (firstCat.labelTextWidth / 2);
                        }

                        //3. if the first grid label is not a category, find trailing edge of first grid label
                        plotObj = gridLinesArr[0].plotObj;
                        if (!firstCat || plotObj !== firstCat.plotObj) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                            plotPx = ((plotObj.value - axisObj.min) * unitWidth) + availableSpaceLeft;

                            if (firstCat) {
                                difference = trailingEdge - plotPx;
                                if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                    labelTextWidth = difference * 2;
                                } else {
                                    labelTextWidth = 0;
                                }
                            }
                            gridLinesArr[0].labelTextWidth = labelTextWidth;

                            if (labelTextWidth > 0) {
                                temp = plotPx - (labelTextWidth / 2);
                            }

                            if (temp < trailingEdge) {
                                trailingEdge = temp;
                            }
                        }

                        //3. find the leading edge of last category label.
                        if (lastCat) {
                            labelTextWidth = lastCat.labelTextWidth;
                            leadingEdge = ((axisObj.max - lastCat.plotObj.value) * unitWidth) + availableSpaceRight - (labelTextWidth / 2);
                        }

                        //4. if the last grid label is not a category, find leading edge of last grid label
                        plotObj = gridLinesArr[lastGridIndex].plotObj;
                        if (!lastCat || plotObj !== lastCat.plotObj) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }

                            labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                            plotPx = ((axisObj.max - plotObj.value) * unitWidth) + availableSpaceRight;

                            if (lastCat) {
                                difference = plotPx - leadingEdge;
                                if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                    labelTextWidth = difference *  2;
                                } else {
                                    labelTextWidth = 0;
                                }
                            }

                            gridLinesArr[lastGridIndex].labelTextWidth = labelTextWidth;

                            if (labelTextWidth > 0) {
                                temp = plotPx - (labelTextWidth / 2);
                            }

                            if (temp < leadingEdge) {
                                leadingEdge = temp;
                            }
                        }

                        if (trailingEdge < 0) {
                            firstDifference = - trailingEdge;
                        } else {
                            firstDifference = 0
                        }

                        if (leadingEdge < 0) {
                            lastDifference = - leadingEdge;
                        } else {
                            lastDifference = 0;
                        }

                        // 6. do we need to change chart margin or canvas padding?
                        totalDifference = firstDifference + lastDifference;

                        if (totalDifference > 0) {
                            if (excessWidth > totalDifference) { // change the chart margins
                                reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginRight += reductionFactor;
                                width -= reductionFactor;

                                reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                hcJSON.chart.marginLeft += reductionFactor;
                                width -= reductionFactor;

                                unitWidth = width / (axisObj.max - axisObj.min);
                            } else { //change the padding
                                if (firstDifference < lastDifference) {
                                    // try and remove the greater of the two from chart margin
                                    if ((excessWidth >= lastDifference) && rightModify) {
                                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginRight += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);

                                    } else if (leftModify) {
                                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginLeft += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);
                                    }
                                } else {
                                    if ((excessWidth >= firstDifference) && leftModify) {
                                        reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginLeft += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);

                                    } else if (rightModify) {
                                        reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                        reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                        hcJSON.chart.marginRight += reductionFactor;
                                        width -= reductionFactor;
                                        unitWidth = width / (axisObj.max - axisObj.min);
                                    }
                                }
                            }
                            availableSpaceRight = hcJSON.chart.marginRight;
                            availableSpaceLeft = hcJSON.chart.marginLeft;
                            chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value - gridLinesArr[0].plotObj.value) * unitWidth;
                            lowerThreshold = chartPlotWidth * 0.1;
                            upperThreshold = Math.max(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                            for(index in catLinesArr) {
                                i = 0;
                                len = catLinesArr[index].length;

                                while (i < len) {
                                    nextItem = i + 1;

                                    while (!setSuccessiveCategoryWidths(catLinesArr[index][i], catLinesArr[index][nextItem], true)) {
                                        nextItem += 1;
                                    }
                                    i = nextItem;
                                }
                                index += 1;
                            }
                        }


                        // setting the grid labels between the category labels that are currently occupying at most lowerThreshold width.
                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            lineIndex = i % staggerLines;

                            plotObj = gridLineObj.plotObj;
                            if (!plotObj.label) {
                                continue;
                            }

                            if (plotObj.isCat) {
                                if (gridLineObj.labelTextWidth) {
                                    prevCatMap[lineIndex] = gridLineObj;
                                }
                            } else {

                                prevCat = prevCatMap[lineIndex];
                                if (prevCat) {
                                    nextCat = prevCat.nextCat;
                                } else if (catLinesArr[lineIndex]) {
                                    nextCat = catLinesArr[lineIndex][0];
                                } else {
                                    nextCat = null;
                                }

                                prevGrid = null;

                                // get the previous visible label
                                if (i >= staggerLines) {
                                    prevIdx = i - staggerLines;
                                    prevGrid = gridLinesArr[prevIdx];
                                    while (!prevGrid.labelTextWidth) {
                                        if (prevIdx >= staggerLines) {
                                            prevIdx -= staggerLines;
                                            prevGrid = gridLinesArr[prevIdx];
                                        } else {
                                            prevGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (prevGrid) {
                                    lastEdge = prevGrid.rightEdge;
                                } else {
                                    lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                }

                                if (nextCat) {
                                    nextEdge = nextCat.leftEdge;
                                } else {
                                    nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                }

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }

                                labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                                labelEdge = (plotObj.value * unitWidth) - (labelTextWidth / 2);

                                if (conf.isBar && (i == length - 1) && prevGrid) {
                                    if (lastEdge > labelEdge) {
                                        prevGrid.plotObj.label.text = BLANKSTRING;
                                        prevGrid.labelTextWidth = 0;
                                        lastEdge = prevGrid.leftEdge;
                                    }
                                } else {
                                    if ((lastEdge > labelEdge) || (nextEdge < (labelEdge + labelTextWidth))) {
                                        plotObj.label.text = BLANKSTRING;
                                        gridLineObj.labelTextWidth = 0;
                                        continue;
                                    }
                                }

                                lastEdge = Math.max(lastEdge, labelEdge);

                                plotPx = plotObj.value * unitWidth;
                                labelWidth = 2 * Math.min((plotPx - lastEdge), (nextEdge - plotPx));

                                labelObj = plotObj.label;

                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                if (labelWidth < minWidth && minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                    plotObj.label.text = BLANKSTRING;
                                    gridLineObj.labelTextWidth = 0;
                                    continue;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding), maxHeight, noWrap);
                                labelWidth = textObj.width + labelTextPadding;

                                gridLineObj.labelTextWidth = labelWidth;
                                gridLineObj.leftEdge = plotPx - (labelWidth / 2);
                                gridLineObj.rightEdge = plotPx + (labelWidth / 2);

                                labelSize.h = Math.max(labelSize.h, textObj.height);
                            }
                        }

                        // after setting the grid labels we expand the category labels to occupying upto upperThreshold width.
                        var nextIdx = null, prevIdx = null;
                        nextGrid = null, prevGrid = null;
                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                            gridLineObj = gridLinesArr[i];
                            plotObj = gridLineObj.plotObj;
                            lineIndex = i % staggerLines;

                            if (plotObj.isCat && gridLineObj.labelTextWidth) {
                                nextGrid = null, prevGrid = null;
                                plotPx = plotObj.value * unitWidth;
                                // get the previous visible label
                                if (i >= staggerLines) {
                                    prevIdx = i - staggerLines;
                                    prevGrid = gridLinesArr[prevIdx];
                                    while (!prevGrid.labelTextWidth) {
                                        if (prevIdx > staggerLines) {
                                            prevIdx -= staggerLines;
                                            prevGrid = gridLinesArr[prevIdx];
                                        } else {
                                            prevGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (prevGrid) {
                                    leftSpace = plotPx - prevGrid.rightEdge;
                                } else {
                                    leftSpace = plotPx - (axisObj.min * unitWidth) + hcJSON.chart.marginLeft;
                                }

                                // get the next visible label
                                if ((i + staggerLines) < length) {
                                    nextIdx = i + staggerLines;
                                    nextGrid = gridLinesArr[nextIdx];
                                    while (!nextGrid.labelTextWidth) {
                                        if ((nextIdx + staggerLines) < (length - 1)) {
                                            nextIdx += staggerLines;
                                            nextGrid = gridLinesArr[nextIdx];
                                        } else {
                                            nextGrid = null;
                                            break;
                                        }
                                    }
                                }

                                if (nextGrid) {
                                    rightSpace = nextGrid.leftEdge - plotPx;
                                } else {
                                    rightSpace = (axisObj.max * unitWidth) + hcJSON.chart.marginRight - plotPx;
                                }


                                labelWidth = Math.min(leftSpace, rightSpace) * 2;

                                if (labelWidth > upperThreshold) {
                                    labelWidth = upperThreshold;
                                }

                                if (labelWidth > gridLineObj.oriWidth) {
                                    labelWidth = gridLineObj.oriWidth;
                                }

                                gridLineObj.labelTextWidth = labelWidth;

                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    SmartLabel.setStyle(labelObj.style);
                                }

                                textObj = SmartLabel.getSmartText(labelObj.text, labelWidth - labelTextPadding, maxHeight, noWrap);
                                gridLineObj.labelTextWidth = textObj.width + labelTextPadding;
                                labelSize.h = Math.max(labelSize.h, textObj.height);

                                gridLineObj.rightEdge = plotPx + (gridLineObj.labelTextWidth / 2);
                            }
                        }
                    }

                // setting the widths of non grid labels.
                } else if (rotation) {
                    for (i = 0, length = gridLinesArr.length; i < length; i += 1) {
                        plotObj = gridLinesArr[i].plotObj;
                        if (plotObj && plotObj.label && plotObj.label.text) {
                            labelObj = plotObj.label;
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            index = 1;
                            if ((i + index) < length) {
                                var nextPlot = gridLinesArr[index + i].plotObj;
                                while (nextPlot && ((nextPlot.value - plotObj.value) * unitWidth) < minWidth) {
                                    if (plotObj.isCat) {
                                        if (nextPlot.label) {
                                            nextPlot.label.text = BLANKSTRING;
                                            index += 1;
                                            if ((index + i) >= (length - 1)) {
                                                break;
                                            }
                                            nextPlot = plotLinesArr[index + i].plotObj;
                                        }
                                    } else if (nextPlot.isCat) {
                                        plotObj.label.text = BLANKSTRING;
                                        plotObj = nextPlot;
                                        i += (index - 1);
                                        labelObj = plotObj.label;
                                        //if the style not implemented then implement it
                                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                            lastUsedStyle = labelObj.style;
                                            SmartLabel.setStyle(lastUsedStyle);
                                        }
                                        break;
                                    }
                                }
                            }
                            labelSize.w = Math.max(labelSize.w, (SmartLabel.getOriSize(labelObj.text).width + labelTextPadding));
                        }
                    }
                }
            }

            for (index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                plotObj = nonGridLinesArr[index].plotObj;

                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    textObj = SmartLabel.getOriSize(labelObj.text);
                    if (labelObj.verticalAlign === POSITION_BOTTOM) {
                        tedendHeight = mathMax(tedendHeight, textObj.height);
                    } else {
                        oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                    }
                }
            }
        }

        //now calculate the required space height
        if (isNone) {
            labelSpace = labelHeight;
        }
        else if (rotation) {
            labelSpace = labelSize.w;
        } else if (isStagger){
            labelSpace = staggerLines * labelHeight;
        } else {
            labelSpace = labelSize.h;
        }

        if (labelSpace > 0) {
            bottomSpace += labelPadding + labelSpace;
        }

        if (titleHeightUsed > 0) {
            bottomSpace += titleHeightUsed + xAxisNamePadding;
        }

        var difference, totalSpace = oppTrendHeight + bottomSpace + 2; 
        temp = 0;

        /// Reduce the element size if required
        if (totalSpace > maxHeight) {
            difference = totalSpace - maxHeight;
            if (xAxisNamePadding > difference) {
                xAxisNamePadding -= difference;
                difference = 0;
            } else {
                difference -= xAxisNamePadding;
                xAxisNamePadding = 0;
                if (labelPadding > difference) {
                    labelPadding -= difference;
                    difference = 0;
                } else {
                    difference -= labelPadding;
                    labelPadding = 0;
                }
            }

            // reduce the opposite side text or canvas text
            if (oppTrendHeight > difference) {
                oppTrendHeight -= difference;
                difference = 0;
            } else {
                if (oppTrendHeight > 0) {
                    difference -= oppTrendHeight;
                    oppTrendHeight = 0;
                }
                if (difference > 0) {
                    if (tedendHeight > difference) {
                        tedendHeight -= difference;
                        difference = 0;
                    }
                    else {
                        if (tedendHeight > 0) {
                            difference -= tedendHeight;
                            tedendHeight = 0;
                        }
                        if (difference > 0) {
                            if ((temp = titleHeightUsed - nameLineHeight) > difference) {
                                titleHeightUsed -= difference;
                                difference = 0
                            }
                            else {
                                difference -= temp;
                                titleHeightUsed = nameLineHeight;
                                if (difference > 0) {
                                    if ((temp = labelSpace - labelHeight) > difference) {
                                        labelSpace -= difference;
                                        difference = 0
                                    }
                                    else {
                                        difference -= temp;
                                        labelSpace = labelHeight;
                                        if (difference > 0) {
                                            difference -= titleHeightUsed + xAxisNamePadding;
                                            titleHeightUsed = 0;
                                            if (difference > 0) {
                                                difference -= labelSpace
                                                labelSpace = 0
                                                if (difference > 0) {
                                                    labelPadding -= difference;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Place the elements
        //add extraspace if any
        labelPadding += marginBottomExtraSpace;

        var labelX = conf.is3d ? - hcJSON.chart.xDepth : 0, trendTextY = labelSpace + labelPadding,
        textAlign, yShipment, perLabelH, perLabelW, xShipment = labelX, adjustedPx = labelHeight * 0.5;
        labelY = labelHeight + labelPadding, length = gridLinesArr.length;
        catCount = 0;

        if (!isXYPlot) {
            if (rotation) {
                perLabelH = perCatWidth;
                perLabelW = labelSpace - labelTextPadding;
                textAlign = POSITION_RIGHT;
                if (slantLabels) {
                    yShipment = labelPadding + 8; // in case of slant labels an extra charaters width has to be added to the yShipment
                } else {
                    yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                }
            }
            else if (isStagger) {
                perLabelH = labelHeight;
                perLabelW = (perCatWidth * staggerLines) - labelTextPadding;
                textAlign = POSITION_CENTER;

            }
            else {
                perLabelH = labelSpace;
                perLabelW = perCatWidth - labelTextPadding;
                //xShipment += 0;
                textAlign = POSITION_CENTER;
                yShipment = labelY;//4px to looks poper like FC as there has a padding
            }

            for(index = 0; index < length; index += stepValue) {
                plotObj = gridLinesArr[index];
                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }

                    if (!isNone) {
                        textObj = SmartLabel.getSmartText(labelObj.text, perLabelW, perLabelH, noWrap);
                        labelObj.text = textObj.text;
                        if (isStagger) {
                            yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                        }
                        if (rotation) {
                            //px adjustment to looks same as FC
                            xShipment = labelX + (adjustedPx / 2);
                        }

                    }
                    labelObj.y = yShipment;
                    labelObj.x = xShipment;
                    labelObj.rotation = rotation;
                    labelObj.textAlign = textAlign;
                    catCount += 1
                }
            }
        } else {
            // for scatter and bar charts
            if (rotation) {

                textAlign = POSITION_RIGHT;
                if (slantLabels) {
                    yShipment = labelPadding + 8; // in case of slant labels an extra charaters width has to be added to the yShipment
                } else {
                    yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                }

                length = gridLinesArr.length;
                for(index = 0; index < length; index += 1) {
                    plotObj = gridLinesArr[index].plotObj;
                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        i = 1;
                        textObj = SmartLabel.getSmartText(labelObj.text, labelSpace - 4, minWidth, noWrap);
                        labelObj.text = textObj.text;
                        //px adjustment to looks same as FC
                        xShipment = labelX + (adjustedPx / 2);

                        labelObj.y = yShipment;
                        labelObj.x = xShipment;
                        labelObj.rotation = rotation;
                        labelObj.textAlign = textAlign;
                        catCount += 1
                    }
                }
            } else {
                perLabelH = labelSpace;
                textAlign = POSITION_CENTER;
                yShipment = labelY;

                for(index = 0; index < length; index += stepValue) {
                    plotObj = gridLinesArr[index].plotObj;
                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (!isNone) {
                            textObj = SmartLabel.getSmartText(labelObj.text, gridLinesArr[index].labelTextWidth - 4, perLabelH, noWrap);
                            labelObj.text = textObj.text;
                            if (isStagger) {
                                yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                            }
                        }
                        labelObj.y = yShipment;
                        labelObj.x = xShipment;
                        labelObj.rotation = rotation;
                        labelObj.textAlign = textAlign;
                        catCount += 1
                    }
                }
            }
        }

        length = nonGridLinesArr.length;
        var aoppTrendHeight = 0, atedendHeight = 0;
        for(index = 0; index < length; index += 1) {
            plotObj = nonGridLinesArr[index].plotObj ? nonGridLinesArr[index].plotObj : nonGridLinesArr[index];
            if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                labelObj = plotObj.label;
                //if the style not implemented then implement it
                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                    lastUsedStyle = labelObj.style;
                    SmartLabel.setStyle(lastUsedStyle);
                }
                if (labelObj.verticalAlign === POSITION_BOTTOM) {
                    textObj = SmartLabel.getSmartText(labelObj.text, width, tedendHeight, true);
                    atedendHeight = Math.max(atedendHeight, textObj.height);
                    labelObj.text = textObj.text;
                    labelObj.y = trendTextY + SmartLabel.getOriSize(testStr).height;
                    labelObj.x = xShipment;
                } else {
                    textObj = SmartLabel.getSmartText(labelObj.text, width, oppTrendHeight, true);
                    aoppTrendHeight = Math.max(aoppTrendHeight, textObj.height);
                    labelObj.text = textObj.text;
                    labelObj.y = - ((oppTrendHeight - SmartLabel.getOriSize(testStr).height) + labelPadding + 2); 
                }
            }
        }

        if (titleHeightUsed > 0) {
            SmartLabel.setStyle(axisObj.title.style);
            //now get the title space
            titleText = SmartLabel.getSmartText(axisObj.title.text, width, titleHeightUsed);
            axisObj.title.text = titleText.text;
            axisObj.title.margin = trendTextY + atedendHeight + xAxisNamePadding;
        }

        bottomSpace = atedendHeight;

        if (labelSpace > 0) {
            conf.horizontalAxisHeight = labelPadding + labelSpace - marginBottomExtraSpace;
            ;
            bottomSpace += conf.horizontalAxisHeight;
        }

        if (titleHeightUsed > 0) {
            bottomSpace += titleHeightUsed + xAxisNamePadding;
        }
        //
        hcJSON.chart.marginBottom += bottomSpace;

        if (aoppTrendHeight > 0) {
            hcJSON.chart.marginTop += aoppTrendHeight;
            bottomSpace += aoppTrendHeight;
        }

        return bottomSpace;
    },


    configureLegendOptions = function (hcJSON, fcJSONChartObj, isONRight, isPointItem, availableWidth) {
        var legendObj = hcJSON.legend,
        hcJSONChart = hcJSON.chart,
        paletteIndex = hcJSONChart.paletteIndex,
        is3d = hcJSONChart.is3D,
        borderColor, palleteString = is3d ? chartPaletteStr.chart3D :
        chartPaletteStr.chart2D,
        interactiveLegend,
        borderAlpha,
        backgroundAlpha,
        roundEdges = hcJSONChart.useRoundEdges,
        padding = 4,
        legendHeight,
        padding2 = 2 * padding,
        legendScale = pluckNumber(fcJSONChartObj.legendiconscale, 1),
        frontHeight = parseInt(legendObj.itemStyle.fontSize, 10) || 10,
        symbolWidthSpace = frontHeight - 1,
        symbolPadding = 3;

        if (legendScale <= 0 || legendScale > 5) {
            legendScale = 1;
        }

        legendObj.padding = padding;


        if (symbolWidthSpace <= 0) {
            symbolWidthSpace = 1;
        }
        availableWidth -= padding2;

        symbolWidthSpace *= legendScale;
        symbolPadding *= legendScale;
        symbolWidthSpace = Math.min(symbolWidthSpace, availableWidth);

        if (symbolWidthSpace <= 0) {
            symbolPadding = symbolWidthSpace = 0;
        }
        legendObj.symbolWidth = symbolWidthSpace;

        legendObj.symbolPadding = symbolPadding;
        legendObj.textPadding = 4;
        legendObj.legendHeight = legendHeight = symbolWidthSpace + (2 * symbolPadding);
        legendObj.rowHeight = Math.max(parseInt(legendObj.itemStyle.lineHeight, 10) || 12, legendHeight);

        if (isONRight) {//else pert is the default options
            //basic configuration for the legend box to show in right
            legendObj.align = POSITION_RIGHT;
            legendObj.verticalAlign = 'middle';
            legendObj.layout = 'vertical';
        }
        else {
            legendObj.x = (hcJSONChart.marginLeft - hcJSONChart.spacingLeft - hcJSONChart.marginRight + hcJSONChart.spacingRight) / 2;

        }




        borderColor = pluck(fcJSONChartObj.legendbordercolor,
            defaultPaletteOptions[palleteString.legendBorderColor][paletteIndex]);
        borderAlpha = pluckNumber(fcJSONChartObj.legendborderalpha, 100);
        backgroundAlpha = pluckNumber(fcJSONChartObj.legendbgalpha, 100);

        legendObj.backgroundColor  = convertColor(pluck(fcJSONChartObj.legendbgcolor,
            defaultPaletteOptions[palleteString.legendBgColor][paletteIndex]),
        backgroundAlpha);

        legendObj.borderColor = convertColor(borderColor, borderAlpha);
        legendObj.borderWidth = pluckNumber(fcJSONChartObj.legendborderthickness,
            !roundEdges || fcJSONChartObj.legendbordercolor ? 1 : 0);
        legendObj.shadow = Boolean(pluckNumber(fcJSONChartObj.legendshadow, 1));
        if (legendObj.shadow) {
            legendObj.shadow = {
                enabled: legendObj.shadow,
                opacity: mathMax(borderAlpha, backgroundAlpha) / 100
            };
        }
        legendObj.reversed = Boolean(pluckNumber(fcJSONChartObj.reverselegend, 0));
        //ispointItem means it is a pie or doughnut
        //then the data is alreadi reversed
        if (isPointItem) {
            legendObj.reversed = !legendObj.reversed;
        }
        legendObj.style = {
            padding : padding
        };
        // legendObj.floating = true;
        interactiveLegend = Boolean(pluckNumber(fcJSONChartObj.interactivelegend, 1));
        if (!interactiveLegend) {
            hcJSON.plotOptions.series.events.legendItemClick = falseFN;
            legendObj.itemStyle.cursor = 'default';
            legendObj.itemHoverStyle = {
                cursor : 'inherit'
            }
        }
        else {
            legendObj.symbolStyle = {
                '_cursor': 'hand',
                'cursor': 'pointer'
            };
        }

        legendObj.borderRadius = roundEdges ? 3 : 0;

        //extra attr on hc JSON added for fc attr support
        legendObj.legendAllowDrag = Boolean(pluckNumber(fcJSONChartObj.legendallowdrag, 0));
        legendObj.title.text = parseUnsafeString(getFirstValue(fcJSONChartObj.legendcaption, BLANKSTRING));
        legendObj.legendScrollBgColor = getFirstColor(pluck(fcJSONChartObj.legendscrollbgcolor,
            defaultPaletteOptions.altHGridColor[hcJSON.chart.paletteIndex]));
        legendObj.legendScrollBarColor = pluck(fcJSONChartObj.legendscrollbarcolor, borderColor);
        legendObj.legendScrollBtnColor = pluck(fcJSONChartObj.legendscrollbtncolor, borderColor);
        legendObj.title.style = extend2({
            fontWeight:"bold"
        }, legendObj.itemStyle);


    },

    /**
     *  Used to compute the space required to place the legend block when the
     *  legend block display is turned on.
     *
     *  @param hcJSON {Object}, is the JSON that is to be
     *
     */

    //Note: no text are allowed to be more in height then allowed (availableHeight) then there will be ellipses
    placeLegendBlockRight = lib.placeLegendBlockRight = function (hcJSON, fcJSON,
        availableWidth, availableHeight, isPointItem) {

        // configure LegendOptions
        configureLegendOptions(hcJSON, fcJSON.chart, true, isPointItem, availableWidth);

        var i = 0, itemArr = hcJSON.series, len, item,
        SmartLabel = hcJSON[FC_CONFIG_STRING].smartLabel,
        legendObj =  hcJSON.legend,  smartText, textWidth,
        textPadding = legendObj.textPadding,
        captionPadding = legendObj.title.padding,
        captionWidth,
        symbolWidthSpace = legendObj.symbolWidth,
        symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
        legendHeight = symbolWidthSpace + (2 * symbolPadding),
        allowedMaxHeight = availableHeight * 2,
        legendPadding = 2,
        textWidthUsed = 0,
        usedWidth = pluckNumber(fcJSON.chart.legendpadding, 7),
        padding = legendObj.padding,
        padding2 = 2 * padding,
        blockDimensions = {
            width: padding2,
            height: padding2
        };

        availableWidth -= padding2;//5 pixel padding from canvas border

        if (isPointItem) {
            itemArr = itemArr && itemArr[0] && itemArr[0].data
        }

        //return incase of no series
        if (typeof itemArr === STRINGUNDEFINED || typeof itemArr.length === STRINGUNDEFINED) {
            return 0;
        } else {
            len = itemArr.length;
        }

        textWidth = availableWidth - legendHeight - legendPadding - textPadding;
        if (textWidth < 0) {
            textWidth = 0;
        }
        //blockDimensions.width = Math.max(legendHeight, blockDimensions.width);
        SmartLabel.setStyle(legendObj.itemStyle);
        for (; i < len; i += 1) {
            item = itemArr[i];
            if (item.showInLegend !== false) {
                if (textWidth === 0) {
                    blockDimensions.height += legendHeight;
                    item.name = BLANKSTRING;
                }
                else {
                    smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                    item.name = smartText.text;
                    blockDimensions.height += Math.max(smartText.height, legendHeight);
                    textWidthUsed = Math.max(smartText.width, textWidthUsed);
                }
            }
        }
        legendObj.width = textWidthUsed  + legendHeight + legendPadding +
        textPadding + padding2;
        if (legendObj.title.text !== BLANKSTRING) {
            SmartLabel.setStyle(legendObj.title.style);
            smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
            legendObj.title.text = smartText.text;
            captionWidth = smartText.width + padding2;
            //if the caption width has gretter width
            if (legendObj.width < captionWidth) {
                legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                legendObj.width = captionWidth;
            }
            blockDimensions.height += smartText.height + captionPadding ;
        }

        legendObj.height = legendObj.totalHeight = blockDimensions.height;

        if (legendObj.height > availableHeight) {
            legendObj.height = availableHeight;
            legendObj.scroll.enabled = true;
            legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
        }


        usedWidth = Math.min(legendObj.width + usedWidth, availableWidth);
        hcJSON.chart.marginRight +=  usedWidth;
        return usedWidth;
    },

    //Note: no text are allowed to be more in height then 2 * allowed (availableHeight) then there will be ellipses
    placeLegendBlockBottom = lib.placeLegendBlockBottom = function (hcJSON, fcJSON,
        availableWidth, availableHeight, isPointItem) {

        //configure LegendOptions
        configureLegendOptions(hcJSON, fcJSON.chart, false, isPointItem, availableWidth);


        var i = 0, itemArr = hcJSON.series, len, item,
        SmartLabel = hcJSON[FC_CONFIG_STRING].smartLabel,
        legendObj =  hcJSON.legend,  smartText, textWidth,
        textPadding = legendObj.textPadding,
        captionPadding = legendObj.title.padding,
        captionWidth,
        symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
        legendHeight = legendObj.legendHeight,
        fcJSONChart = fcJSON.chart,
        legendCaptionHeight = 0,
        allowedMaxHeight = availableHeight * 2,
        legendPadding = 2,
        rowHeight = legendObj.rowHeight,
        tempTableStructure = [],
        minimiseWrappingInLegend = pluckNumber(fcJSONChart.minimisewrappinginlegend, 0),
        legendNumColumns = pluckNumber(parseInt(fcJSONChart.legendnumcolumns, 10), 0),
        maxWidth = 0, totalWidth = 0, totalNumber = 0, averageWidth = 0, perItemWidth = 0,
        padding = legendObj.padding,
        padding2 = 2 * padding,
        usedHeight = pluckNumber(fcJSON.chart.legendpadding, 7),
        blockDimensions = {
            width: padding2,
            height: padding2
        };

        if (legendNumColumns < 0) {
            legendNumColumns = 0;
        }

        availableWidth -= padding2;//deduct the legend Box padding 2 * 6Px

        SmartLabel.setStyle(legendObj.itemStyle);
        var legendLineHeight = SmartLabel.getSmartText(TESTSTR).height;
        usedHeight = Math.min(usedHeight, availableHeight - legendLineHeight - 8); // 8px padding for the legend text.
        availableHeight -= usedHeight;

        if (isPointItem) {
            itemArr = itemArr && itemArr[0] && itemArr[0].data
        }

        //return incase of no series
        if (typeof itemArr === STRINGUNDEFINED || typeof itemArr.length === STRINGUNDEFINED) {
            return 0;
        } else {
            len = itemArr.length;
        }


        //set the legend text style
        SmartLabel.setStyle(legendObj.itemStyle);
        //retrive average and total width
        for ( ;i < len; i += 1) {
            if (itemArr[i].showInLegend !== false) {
                smartText = SmartLabel.getOriSize(itemArr[i].name);
                maxWidth = Math.max(maxWidth, smartText.width);
                totalWidth += smartText.width;
                totalNumber += 1;
            }
        }
        averageWidth = totalWidth / totalNumber;

        averageWidth += legendHeight + legendPadding + textPadding;
        maxWidth += legendHeight + legendPadding + textPadding;

        if (legendNumColumns > 0 && totalNumber < legendNumColumns) {
            legendNumColumns = totalNumber;
        }

        //if valid numcolumn[there has enough item for legendNumColumns, every item getting minimum space]
        if (legendNumColumns > 0 && (perItemWidth = availableWidth / legendNumColumns) > averageWidth) {
            if(perItemWidth > maxWidth){
                perItemWidth = maxWidth;
            }
        }
        else if (availableWidth > maxWidth && (minimiseWrappingInLegend || averageWidth * 1.5 > maxWidth)) {
            legendNumColumns = Math.floor(availableWidth / maxWidth);
            if (totalNumber < legendNumColumns) {
                legendNumColumns = totalNumber;
            }
            perItemWidth = maxWidth;

        }
        else if(availableWidth >= 2 * averageWidth){
            //The number of columns each of width as the averageWidth
            legendNumColumns = Math.floor(availableWidth / averageWidth);

            if (totalNumber < legendNumColumns) {
                legendNumColumns = totalNumber;
            }


            //Provide best width space, which is greater than average width, generally (for numColumns is found above via Math.floor())
            perItemWidth = Math.floor(availableWidth / legendNumColumns);

            if(perItemWidth > maxWidth){
                perItemWidth = maxWidth;
            }
        } else {
            legendNumColumns = 1;
            perItemWidth = availableWidth;
        }


        legendObj.itemWidth = perItemWidth;

        textWidth = perItemWidth - legendHeight - legendPadding - textPadding;
        if (textWidth < 0) {
            symbolPadding = textWidth = textPadding = 0;
        }
        legendObj.symbolPadding = symbolPadding;
        legendObj.textPadding = textPadding;


        legendObj.width = (perItemWidth * legendNumColumns) + padding2;

        if (legendObj.title.text !== BLANKSTRING) {
            SmartLabel.setStyle(legendObj.title.style);
            smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
            legendObj.title.text = smartText.text;
            captionWidth = smartText.width + padding2;
            //if the caption width has gretter width
            if (legendObj.width < captionWidth) {
                legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                legendObj.width = captionWidth;
            }
            legendCaptionHeight = smartText.height + captionPadding ;
        }

        SmartLabel.setStyle(legendObj.itemStyle);
        var numRows, numberOfCell, j, current = 0, tempCurrent;
        if (legendObj.reversed) {
            //blockDimensions.width = Math.max(legendHeight, blockDimensions.width);
            for (i = len - 1 ;i >= 0; i -= 1) {
                item = itemArr[i];
                if (item.showInLegend !== false) {
                    if (textWidth === 0) {
                        tempTableStructure[current] = true;
                        item.name = BLANKSTRING;
                    }
                    else {
                        smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                        item.name = smartText.text;
                        while (tempTableStructure[current] === true) {
                            current += 1;
                        }
                        numberOfCell = smartText.height / rowHeight;
                        tempCurrent = current;
                        for (j = 0; j < numberOfCell; j += 1, tempCurrent += legendNumColumns) {
                            tempTableStructure[tempCurrent] = true;
                        }
                    }
                    current += 1;
                }
            }
        }
        else {
            //blockDimensions.width = Math.max(legendHeight, blockDimensions.width);
            for (i = 0 ;i < len; i += 1) {
                item = itemArr[i];
                if (item.showInLegend !== false) {
                    if (textWidth === 0) {
                        tempTableStructure[current] = true;
                        item.name = BLANKSTRING;
                    }
                    else {
                        smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                        item.name = smartText.text;
                        while (tempTableStructure[current] === true) {
                            current += 1;
                        }
                        numberOfCell = smartText.height / rowHeight;
                        tempCurrent = current;
                        for (j = 0; j < numberOfCell; j += 1, tempCurrent += legendNumColumns) {
                            tempTableStructure[tempCurrent] = true;
                        }
                    }
                    current += 1;
                }
            }
        }
        numRows = Math.ceil(tempTableStructure.length / legendNumColumns);
        blockDimensions.height += (numRows * rowHeight) + legendCaptionHeight;
        legendObj.height = legendObj.totalHeight = blockDimensions.height;
        legendObj.rowHeight = rowHeight;
        legendObj.legendNumColumns = legendNumColumns;

        if (legendObj.height > availableHeight) { // for padding
            legendObj.height = availableHeight;
            legendObj.scroll.enabled = true;
            legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
        }

        usedHeight += legendObj.height;
        hcJSON.chart.marginBottom += usedHeight;
        return usedHeight;
    },





    /*
     *This Function set the x axis min max to prodice space for canvasPadding
     */
    plotLineSortFN = function(a,b)
    {
        return a.value - b.value;
    },
    xAxisMinMaxSetter = function (hcJSON, fcJSON, canvasWidth) {
        var conf = hcJSON[FC_CONFIG_STRING], xAxisConf = conf.x,
        
        // no catCount is requierd.
        FCchartObj = fcJSON.chart,
        min = xAxisConf.min = pluckNumber(xAxisConf.min, 0),
        max = xAxisConf.max = pluckNumber(xAxisConf.max, xAxisConf.catCount - 1),
        rightPixelPad,
        leftValuePad = 0, rightValuePad = 0, valuePixelRatio, defaultSeries = hcJSON.chart.defaultSeriesType,
        isColumnType = /^(column|column3d|bar|bar3d|floatedcolumn)$/.test(defaultSeries),
        isLineType = /^(line|area|spline|areaspline)$/.test(defaultSeries),
        isXYPlot = /^(scatter|bubble|candlestick)$/.test(defaultSeries),
        xAxis = hcJSON.xAxis,
        scrollOptions = xAxis.scroll,
        leftPixelPad = rightPixelPad = Math.min(pluckNumber(FCchartObj.canvaspadding, 0),
            (canvasWidth / 2) - 10);//plot area will not be less then 10 px

        //if scatter or bubble the calculate the min max
        //NOTE: this flag is added in cat adder of scatter
        if (xAxisConf.adjustMinMax) {
            var setadaptiveXmin = pluckNumber(FCchartObj.setadaptivexmin, 1),
            stopMaxAtZero,
            setMinAsZero = stopMaxAtZero = !setadaptiveXmin,
            numVDivLines = pluckNumber(this.numVDivLines, FCchartObj.numvdivlines, 4),
            adjustVDiv = FCchartObj.adjustvdiv !== ZEROSTRING,
            showXAxisValues = pluckNumber(FCchartObj.showxaxisvalues, FCchartObj.showxaxisvalue, 1),
            showVLimits = pluckNumber(FCchartObj.showvlimits, showXAxisValues),
            showVDivLineValues = pluckNumber(FCchartObj.showvdivlinevalue, FCchartObj.showvdivlinevalues,
                showXAxisValues);

            //////////////////////calculate the axis min max and the div interval for x axis ///////////////////
            axisMinMaxSetter (xAxis, xAxisConf, FCchartObj.xaxismaxvalue, FCchartObj.xaxisminvalue, stopMaxAtZero,
                setMinAsZero, numVDivLines, adjustVDiv);
            //add this new min max in the local variable for proper code flow
            min = xAxis.min;
            max = xAxis.max;
            //if auto numeric calculation requared
            if (xAxisConf.requaredAutoNumeicLabels) {
                var xaxisvaluesstep = pluckNumber(parseInt(FCchartObj.xaxisvaluesstep, 10), 1);
                xaxisvaluesstep = xaxisvaluesstep < 1 ? 1 : xaxisvaluesstep;
                configureAxis (FCchartObj, hcJSON, xAxis, xAxisConf, showVLimits,
                    showVDivLineValues, xaxisvaluesstep, conf.numberFormatter, false, true);
            }
            //now sort the grid lines so that we can determine the space during space management
            xAxis.plotLines.sort(plotLineSortFN);
        }
        //remove all grid related conf
        xAxis.labels.enabled = false;
        xAxis.gridLineWidth = INT_ZERO;
        xAxis.alternateGridColor = COLOR_TRANSPARENT;


        // We add some spacing to start and end of column plot.
        // The spacing is not equal at bothe ends and is again different for
        // horizontal charts. Perhaps due to some HighCharts drawing abberation.
        if ((isColumnType || conf.isScroll) && !conf.hasNoColumn) {
            if (conf.isBar) {
                leftValuePad = 0.55;
                rightValuePad = 0.55;
            }
            else {
                leftValuePad = 0.5;
                rightValuePad = 0.5;
            }
        }

        if (conf.is3d) {
            leftPixelPad += pluckNumber(hcJSON.chart.xDepth, 0);
        }

        valuePixelRatio = (canvasWidth - (leftPixelPad + rightPixelPad)) / ((max - min) +
            (leftValuePad + rightValuePad));
        xAxis.min = min - (leftValuePad + (leftPixelPad / valuePixelRatio));
        xAxis.max = max + (rightValuePad + (rightPixelPad / valuePixelRatio));

        // Special checking for scroll charts
        if (scrollOptions && scrollOptions.enabled) {
            var vxLength = scrollOptions.vxLength,
            scrollStartPercent = scrollOptions.startPercent,
            scrollableLength = xAxis.max - xAxis.min;

            scrollOptions.viewPortMin = xAxis.min;
            scrollOptions.viewPortMax = xAxis.max;
            scrollOptions.scrollRatio = vxLength / scrollableLength;
            //set the new min max
            xAxis.min += (scrollableLength - vxLength) * scrollStartPercent;
            xAxis.max = xAxis.min + vxLength;
        }


        ///////////Trend-lines /////////////////
        if (isXYPlot && fcJSON.vtrendlines) {
            createTrendLine(fcJSON.vtrendlines, xAxis, conf, false, true, true);
        }

    },

    /*
     * Function to manage the space for a single X and single Y type normal type charts
     */
    nonBarXYSpaceManager = function (hcJSON, fcJSON, width, height) {
        var conf = hcJSON[FC_CONFIG_STRING], axisConf, axisObj, isOnRight = true,
        titleHeight = 0, usedWidth = 0, canvasWidth, fcJSONChart = fcJSON.chart,
        isDual = false, yAxisNamePadding, yAxisValuesPadding, rotateYAxisName,

        marginLeftExtraSpace = conf.marginLeftExtraSpace,
        marginTopExtraSpace = conf.marginTopExtraSpace,
        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        marginRightExtraSpace = conf.marginRightExtraSpace,
        workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
            hcJSON.chart.marginRight + hcJSON.chart.marginLeft),
        workingHeight = height - (marginBottomExtraSpace + hcJSON.chart.marginBottom +
            hcJSON.chart.marginTop),

        //calculate the min width, height for canvas
        
        minCanWidth = workingWidth * 0.3,
        minCanHeight = workingHeight * 0.3,

        // calculate the space remaining
        avaiableWidth = workingWidth - minCanWidth,
        avaiableHeight = workingHeight - minCanHeight,

        //if the legend is at the right then place it and deduct the width
        //if at bottom calculate the space for legend after the vertical axis placed

        legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase();

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            avaiableWidth -= placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
        }




        /*
         * place the vertical axis
         */
        //add all axis margin pading
        yAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
        yAxisValuesPadding = pluckNumber(fcJSONChart.yaxisvaluespadding, 2);
        rotateYAxisName = fcJSONChart.rotateyaxisname !== ZEROSTRING;
        if (conf.isDual) {
            isDual = true;
            axisConf = conf[1];
            axisConf.verticalAxisNamePadding = yAxisNamePadding;
            axisConf.verticalAxisValuesPadding = yAxisValuesPadding;
            axisConf.rotateVerticalAxisName = rotateYAxisName;
            axisConf.verticalAxisNameWidth = pluckNumber(fcJSONChart.syaxisnamewidth);
            //now configure the axis
            
            isOnRight = hcJSON.yAxis[1].opposite;
            avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[1], axisConf, hcJSON,
                fcJSON, workingHeight, avaiableWidth / 2, isOnRight, isDual);
        }


        axisConf = conf[0];
        axisConf.verticalAxisNamePadding = yAxisNamePadding;
        axisConf.verticalAxisValuesPadding = yAxisValuesPadding;
        axisConf.rotateVerticalAxisName = rotateYAxisName;
        axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pyaxisnamewidth :
            fcJSONChart.yaxisnamewidth);
        //now configure the axis
        avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[0], axisConf, hcJSON, fcJSON,
            workingHeight, avaiableWidth, !isOnRight, isDual);

        // adjust left and right canvas margins
        avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth, hcJSON.yAxis[0], hcJSON.yAxis[1]);

        

        //now thw canvas width is fixed(no element to reduce the width
        canvasWidth = avaiableWidth + minCanWidth;

        if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
            avaiableHeight -= placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);
        }

        /*
         * Now place the Title
         */
        //allowed height may

        avaiableHeight -= titleHeight = titleSpaceManager(hcJSON, fcJSON, canvasWidth,
            avaiableHeight/2);

        /*
         * Now place the horizontal axis
         */
        //add all axis margin pading
        axisConf = conf.x;
        axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        axisConf.horizontalLabelPadding = pluckNumber(fcJSONChart.labelpadding, 2);
        axisConf.labelDisplay = (fcJSONChart.rotatelabels == "1") ? "rotate" :
        pluck(fcJSONChart.labeldisplay, "auto").toLowerCase();
        axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
        axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, fcJSONChart.slantlabel, 0);

        //set x axis min max
        this.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth);

        avaiableHeight -= this.placeHorizontalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
            canvasWidth, avaiableHeight, minCanWidth);

        // adjust top and bottom the canvas margins here
        avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.xAxis);

        // checking after the finalizing of the canvas height whether, and to what extent should we
        // step them.
        if (isDual) {
            stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[1], conf[1].lYLblIdx);
            adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[1].title, avaiableHeight);
        }
        stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[0], conf[0].lYLblIdx);
        adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[0].title, avaiableHeight);

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            var legendObj = hcJSON.legend, extraWidth,
            maxHeight = minCanHeight + avaiableHeight;

            if (legendObj.height > maxHeight) {
                legendObj.height = maxHeight;
                legendObj.scroll.enabled = true;
                extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                legendObj.width += extraWidth;
                hcJSON.chart.marginRight += extraWidth;
            }
            legendObj.y = 20;
        }

        var xc = ((hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0)) - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0))) / 2,
        xl = hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0),
        xr = - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0));
        switch (hcJSON.title.align) {
            case 'left' :
                hcJSON.title.x = xl;
                break;
            case 'right':
                hcJSON.title.x = xr;
                break;
            default:
                hcJSON.title.x = xc;
        }
        switch (hcJSON.subtitle.align) {
            case 'left' :
                hcJSON.subtitle.x = xl;
                break;
            case 'right':
                hcJSON.subtitle.x = xr;
                break;
            default:
                hcJSON.subtitle.x = xc;
        }

        /*
         * if the titles requared space and there has avaleble space the re-alocatethe title space
         */
        //this logic is not implemented in Flash so let is as TODO:

        


        hcJSON.chart.marginLeft += marginLeftExtraSpace;
        hcJSON.chart.marginTop += marginTopExtraSpace;
        hcJSON.chart.marginBottom += marginBottomExtraSpace;
        hcJSON.chart.marginRight += marginRightExtraSpace;
    },

    /*
     * Bar chart spage management
     */
    barXYSpaceManager = function (hcJSON, fcJSON, width, height) {
        var conf = hcJSON[FC_CONFIG_STRING], avaiableWidth, avaiableHeight, axisConf, axisObj,
        titleHeight = 0, usedWidth = 0, canvasWidth, fcJSONChart = fcJSON.chart, legendPos,
        isDual = false, verticalAxisNamePadding, verticalAxisValuesPadding, rotateVerticalAxisName,

        marginLeftExtraSpace = conf.marginLeftExtraSpace,
        marginTopExtraSpace = conf.marginTopExtraSpace,
        marginBottomExtraSpace = conf.marginBottomExtraSpace,
        marginRightExtraSpace = conf.marginRightExtraSpace,
        workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
            hcJSON.chart.marginRight + hcJSON.chart.marginLeft),
        workingHeight = height - (marginBottomExtraSpace + hcJSON.chart.marginBottom +
            hcJSON.chart.marginTop),

        //calculate the min width, height for canvas
        
        minCanWidth = workingWidth * 0.3,
        minCanHeight = workingHeight * 0.3;

        // calculate the space remaining
        avaiableWidth = workingWidth - minCanWidth;
        avaiableHeight = workingHeight - minCanHeight;

        
        legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase();

        //if the legend is at the right then place it and deduct the width
        //if at bottom calculate the space for legend after the vertical axis placed
        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            avaiableWidth -= placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
        }
        /*
         * place the vertical axis
         */
        //add all axis margin pading
        //yAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        verticalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
        //yAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 2);
        verticalAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 2);
        //rotateYAxisName = fcJSONChart.rotatexaxisname !== ZEROSTRING;
        rotateVerticalAxisName = fcJSONChart.rotatexaxisname !== ZEROSTRING;

        axisConf = conf.x;
        axisConf.verticalAxisNamePadding = verticalAxisNamePadding;
        axisConf.verticalAxisValuesPadding = verticalAxisValuesPadding;
        axisConf.rotateVerticalAxisName = rotateVerticalAxisName;
        axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pxaxisnamewidth :
            fcJSONChart.xaxisnamewidth);
        //now configure the axis
        avaiableWidth -= placeVerticalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
            workingHeight, avaiableWidth, false, false, workingWidth);

        // adjust left and right canvas margins
        avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth, hcJSON.xAxis);

        //now thw canvas width is fixed(no element to reduce the width
        canvasWidth = avaiableWidth + minCanWidth;

        if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
            avaiableHeight -= placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);
        }

        /*
         * Now place the Title
         */
        //allowed height may

        avaiableHeight -= titleHeight = titleSpaceManager(hcJSON, fcJSON, canvasWidth,
            avaiableHeight/2);

        /*
         * Now place the horizontal axis
         */
        //add all axis margin pading
        axisConf = conf[0];
        axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
        axisConf.horizontalLabelPadding = pluckNumber(fcJSONChart.yaxisvaluespadding, 2);
        // Set the labelDisplay as auto for bar charts
        axisConf.labelDisplay = "auto";
        axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
        axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, 0);

        //set x axis min max
        this.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth);

        // function (axisObj, axisConf, hcJSON, fcJSON, width, maxHeight)
        avaiableHeight -= this.placeHorizontalAxis(hcJSON.yAxis[0], axisConf, hcJSON,
            fcJSON, canvasWidth, avaiableHeight, minCanWidth);

        // adjust top and bottom the canvas margins here
        avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.yAxis[0]);

        stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.xAxis, conf.x.lYLblIdx, true);
        adjustVerticalAxisTitle(hcJSON, hcJSON.xAxis.title, avaiableHeight);

        if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
            var legendObj = hcJSON.legend, extraWidth,
            maxHeight = minCanHeight + avaiableHeight;

            if (legendObj.height > maxHeight) {
                legendObj.height = maxHeight;
                legendObj.scroll.enabled = true;
                extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                legendObj.width += extraWidth;
                hcJSON.chart.marginRight += extraWidth;
            }
            legendObj.y = 20;
        }

        var xc = ((hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0)) - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0))) / 2,
        xl = hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0),
        xr = - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0));
        switch (hcJSON.title.align) {
            case 'left' :
                hcJSON.title.x = xl;
                break;
            case 'right':
                hcJSON.title.x = xr;
                break;
            default:
                hcJSON.title.x = xc;
        }
        switch (hcJSON.subtitle.align) {
            case 'left' :
                hcJSON.subtitle.x = xl;
                break;
            case 'right':
                hcJSON.subtitle.x = xr;
                break;
            default:
                hcJSON.subtitle.x = xc;
        }

        /*
         * if the titles requared space and there has avaleble space the re-alocatethe title space
         */
        //this logic is not implemented in Flash so let is as TODO:

        

        hcJSON.chart.marginLeft += marginLeftExtraSpace;
        hcJSON.chart.marginTop += marginTopExtraSpace;
        hcJSON.chart.marginBottom += marginBottomExtraSpace;
        hcJSON.chart.marginRight += marginRightExtraSpace;
    },

    adjustVerticalAxisTitle = lib.adjustVerticalAxisTitle = function (hcJSON, titleObj, availableHeight) {
        if (!titleObj || !titleObj.text) {
            return;
        }

        var titleText = titleObj.text, conf = hcJSON[FC_CONFIG_STRING], SmartLabel = conf.smartLabel, smartTitle,
        heightMax = 2 * Math.min(hcJSON.chart.marginTop, hcJSON.chart.marginBottom) + availableHeight,
        totalHeight = availableHeight + hcJSON.chart.marginTop + hcJSON.chart.marginBottom;

        if (titleObj.style) {
            SmartLabel.setStyle(titleObj.style)
        }

        smartTitle = SmartLabel.getOriSize(titleText);

        if (titleObj.rotation == "0") {
            if (smartTitle.height > heightMax) {
                titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop)) / 2;
            }
        } else if (smartTitle.width > heightMax) {
            titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop));
        }
    },

    adjustVerticalCanvasMargin = lib.adjustVerticalCanvasMargin = function (hcJSON, fcJSON, avaiableHeight, xAxis) {

        var fcJSONChart = fcJSON.chart, extraMargin = 0, topChange = 0, bottomChange = 0,
        canvasTopMargin = pluckNumber(fcJSONChart.canvastopmargin, 0),
        canvasBottomMargin = pluckNumber(fcJSONChart.canvasbottommargin, 0),
        totalVerticalMargin = canvasTopMargin + canvasBottomMargin,
        topMarginPercent = canvasTopMargin / totalVerticalMargin,
        bottomMarginPercent = 1 - topMarginPercent,
        actualTopMargin = hcJSON.chart.marginTop,
        actualBottomMargin = hcJSON.chart.marginBottom;

        if (canvasBottomMargin > actualBottomMargin) {
            extraMargin += (canvasBottomMargin - actualBottomMargin);
        }
        if (canvasTopMargin > actualTopMargin) {
            extraMargin += (canvasTopMargin - actualTopMargin);
        }
        if (extraMargin > avaiableHeight) {
            if (canvasTopMargin > actualTopMargin && canvasBottomMargin > actualBottomMargin) {
                topChange = (avaiableHeight * topMarginPercent);
                bottomChange = (avaiableHeight * bottomMarginPercent);
            } else {
                if (canvasTopMargin > actualTopMargin) {
                    topChange = avaiableHeight;
                } else {
                    bottomChange = avaiableHeight;
                }
            }
        } else if (extraMargin > 0) {
            if (canvasBottomMargin > actualBottomMargin) {
                bottomChange = (canvasBottomMargin - actualBottomMargin);
            }
            if (canvasTopMargin > actualTopMargin) {
                topChange = (canvasTopMargin - actualTopMargin);
            }
        }

        if (topChange) {
            hcJSON.chart.marginTop += topChange;
        }

        if (bottomChange) {
            hcJSON.chart.marginBottom += bottomChange;
            if (xAxis && xAxis.title) {
                xAxis.title.margin += bottomChange;
            }
        }

        return (topChange + bottomChange);
    },

    adjustHorizontalCanvasMargin = lib.adjustHorizontalCanvasMargin = function (hcJSON, fcJSON, avaiableWidth,
        leftYAxis, rightYAxis) {

        var fcJSONChart = fcJSON.chart,
        canvasLeftMargin = pluckNumber(fcJSONChart.canvasleftmargin, 0),
        canvasRightMargin = pluckNumber(fcJSONChart.canvasrightmargin, 0),
        totalHorizontalMargin = canvasLeftMargin + canvasRightMargin,
        leftMarginPercent = canvasLeftMargin / totalHorizontalMargin,
        rightMarginPercent = 1 - leftMarginPercent, extraMargin = 0,
        actualLeftMargin = hcJSON.chart.marginLeft, actualRightMargin = hcJSON.chart.marginRight,
        leftChange = 0, rightChange = 0;

        if (canvasLeftMargin > actualLeftMargin) {
            extraMargin += (canvasLeftMargin - actualLeftMargin);
        }
        if (canvasRightMargin > actualRightMargin) {
            extraMargin += (canvasRightMargin - actualRightMargin);
        }
        if (extraMargin > avaiableWidth) {
            if (canvasLeftMargin > actualLeftMargin && canvasRightMargin > actualRightMargin) {
                leftChange = (avaiableWidth * leftMarginPercent);
                rightChange = (avaiableWidth * rightMarginPercent);
            } else {
                if (canvasRightMargin > actualRightMargin) {
                    rightChange = avaiableWidth
                } else {
                    leftChange = avaiableWidth;
                }
            }
        } else if (extraMargin > 0) {
            if (canvasLeftMargin > actualLeftMargin) {
                leftChange = (canvasLeftMargin - actualLeftMargin);
            }

            if (canvasRightMargin > actualRightMargin) {
                rightChange = (canvasRightMargin - actualRightMargin);
            }
        }

        if (leftChange) {
            hcJSON.chart.marginLeft += leftChange;
            if (leftYAxis && leftYAxis.title) {
                leftYAxis.title.margin += leftChange;
            }
        }

        if (rightChange) {
            hcJSON.chart.marginRight += rightChange;
            if (rightYAxis && rightYAxis.title) {
                rightYAxis.title.margin += rightChange;
            }
        }

        return (rightChange + leftChange);
    },

    //post Series Adition Function
    postSeriesAddition = function (hcObj, fcObj, width, height) {
        var conf = hcObj[FC_CONFIG_STRING],
        isBar = conf.isBar,
        is3d = conf.is3d,
        rotateValues = hcObj.chart.rotateValues && !isBar ? 270 : 0;

        //show the stack total if requared
        if (this.isStacked && conf.showStackTotal) {
            var plotSpacePercent = conf.plotSpacePercent,
            seriesType,
            totalStacks,
            axisConfStack,
            groupWidthPercent = 1 - plotSpacePercent,
            perStackWidth,
            stackIndex,
            startStackIndex,
            position,
            length,
            catPosition,
            stackArr,
            stack,
            value,
            labelPosition,
            style = extend2({}, hcObj.plotOptions.series.dataLabels.style),
            labelFontSize = parseFloat(style.fontSize),
            labeloffsetScale,
            //for the first y axis
            axisStack = conf[0],
            labelInsidePlot = !axisStack.stacking100Percent;
            style.color = hcObj.plotOptions.series.dataLabels.color;

            axisConfStack = axisStack.stack;

            for (seriesType in axisConfStack) {
                totalStacks = axisConfStack[seriesType].length;
                perStackWidth = groupWidthPercent / totalStacks;
                startStackIndex = - (groupWidthPercent - perStackWidth) / 2;

                for (stackIndex = 0; stackIndex < totalStacks; stackIndex += 1,
                    startStackIndex += perStackWidth) {
                    stackArr = axisConfStack[seriesType][stackIndex];
                    for (catPosition = 0, length = stackArr.length; catPosition < length; catPosition += 1) {
                        stack = stackArr[catPosition];
                        position = catPosition;
                        labelPosition = position + startStackIndex;
                        value = (stack.n || 0) + (stack.p || 0);
                        labeloffsetScale = value < 0 ? stack.n : stack.p;

                        //add the total value
                        hcObj.xAxis.plotLines.push({
                            value : labelPosition,
                            width : 0,
                            isVline: labelInsidePlot,
                            isTrend : !labelInsidePlot,
                            zIndex: 4,
                            label : {
                                align : POSITION_CENTER,
                                textAlign : !is3d && rotateValues === 270 ? (value < 0 ?
                                    POSITION_RIGHT : POSITION_LEFT) : POSITION_CENTER,
                                offsetScale: labelInsidePlot ? labeloffsetScale : undefined,
                                offsetScaleIndex : 0,
                                rotation : rotateValues,
                                style : style,
                                verticalAlign : POSITION_TOP,
                                y : isBar ? 0 : (value < 0 ?
                                    (rotateValues === 270 ? 4 : labelFontSize) : -4),
                                x : 0,
                                text : conf.numberFormatter.yAxis(value)
                            }
                        });
                    }
                }

            }
        }



    };


    //// add the base
    chartAPI('base', {

        draw: function (options, callback) {

            return new Highcharts.Chart(options, callback);
        },

        init: function (container, dataObj, chartObj) {

            //clone FC data so that any modiffication on it will not effect the original
            this.dataObj = dataObj = extend2({}, dataObj);

            //clone the chart obj from graph or blank object
            dataObj.chart = dataObj.chart || dataObj.graph || {};
            delete dataObj.graph;

            this.containerElement = container;
            this.config = {};

            this.smartLabel = new SmartLabelManager(chartObj.id, document.getElementsByTagName('body')[0] || container,
                pluckNumber(dataObj.chart.useellipseswhenoverflow, dataObj.chart.useellipsewhenoverflow, 1));

            if (!this.standaloneInit) {
                return new lib.createDialog(container, chartObj.jsVars.msgStore.ChartNotSupported);
            }

            //call the chart conf function
            return this.chart(container, this.name, dataObj,
                container.offsetWidth || parseFloat(container.style.width),
                container.offsetHeight || parseFloat(container.style.height), chartObj);
        },


        chart: defaultChartFN,
        defaultSeriesType: BLANKSTRING,
        paletteIndex: 1,
        creditLabel: creditLabel,

        // Space Management Routines
        placeTitle: titleSpaceManager,
        placeLegendBottom: placeLegendBlockBottom,
        placeLegendRight: placeLegendBlockRight,
        placeHorizontalAxis: placeHorizontalAxis,
        placeVerticalAxis: placeVerticalAxis,
        placeHorizontalCanvasMarginAdjustment: adjustHorizontalCanvasMargin,
        placeVerticalCanvasMarginAdjustment: adjustVerticalCanvasMargin,
        placeHorizontalXYSpaceManager: barXYSpaceManager,
        placeVerticalXYSpaceManager: nonBarXYSpaceManager,
		placeVerticalAxisTitle: adjustVerticalAxisTitle,

        spaceManager : function () {
            return this.placeVerticalXYSpaceManager.apply(this, arguments);
        },

        xAxisMinMaxSetter: xAxisMinMaxSetter,
        postSeriesAddition: postSeriesAddition,

        dispose: function () {
            this.smartLabel && this.smartLabel.dispose();
        }

    });

    chartAPI('stub', {
        standaloneInit: true
    }, chartAPI.base);

    chartAPI('barbase', {
        spaceManager: function () {
            return this.placeHorizontalXYSpaceManager.apply(this, arguments);
        }
    }, chartAPI.base);

    //// add the singleseries
    chartAPI('singleseries', {
        series : function (FCObj, HCObj, chartName, width, height) {
            if (FCObj.data && FCObj.data.length > 0) {
                var series = {
                    data : [],
                    // for single series the color will be added point by point from palette
                    colorByPoint: true
                }, seriesArr;

                /////////if any SPECIAL settings needed for single series chart

                //disable the legend (special case for pie)
                HCObj.legend.enabled = false;


                //add data using chart speciffic function
                seriesArr = this.point(chartName, series, FCObj.data, FCObj.chart, HCObj);
                //if the returned series is an array of series (case: pareto)
                if (seriesArr instanceof Array) {
                    HCObj.series = HCObj.series.concat(seriesArr)
                }
                //all other case there will be only1 series
                else {
                    HCObj.series.push(seriesArr);
                }

                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                if (FCObj.trendlines) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, HCObj[FC_CONFIG_STRING],
                        false, this.isBar);
                }

            }
        },
        defaultSeriesType : BLANKSTRING,
        configureAxis : yxAxisConfigurer,
        pointValueWatcher : pointValueWatcher,

        // Function to create tooltext for individual data points
        getPointStub: function (setObj, value, label, HCObj) {
            var toolText, displayValue, dataLink, HCConfig = HCObj[FC_CONFIG_STRING],
            formatedVal = value === null ? value : HCConfig.numberFormatter.dataLabels(value),
            setTooltext = getValidValue(parseUnsafeString(setObj.tooltext)),
            setDisplayValue = getValidValue(parseUnsafeString(setObj.displayvalue));

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = BLANKSTRING;
            }
            else if (setTooltext !== undefined) {
                toolText = setTooltext;
            }
            else {//determine the dispalay value then
                toolText = formatedVal === null ? false :
                (label !== BLANKSTRING) ? label + HCConfig.tooltipSepChar + formatedVal : formatedVal;
            }
            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, HCConfig.showValues)) {
                displayValue = BLANKSTRING;
            }
            else if (setDisplayValue !== undefined) {
                displayValue = setDisplayValue;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            dataLink = pluck(setObj.link);
            return {
                displayValue : displayValue,
                toolText : toolText,
                link: dataLink
            };
        }
    }, chartAPI.base);


    //// add the multyseries
    chartAPI('multiseries', {
        series : function (FCObj, HCObj, chartName) {
            var index, length, conf = HCObj[FC_CONFIG_STRING],
            series, seriesArr;

            //enable the legend
            HCObj.legend.enabled = Boolean(pluckNumber(FCObj.chart.showlegend, 1));

            if (FCObj.dataset && FCObj.dataset.length > 0) {
                // add category
                this.categoryAdder(FCObj, HCObj);
                //add data series
                for (index = 0, length = FCObj.dataset.length; index < length; index += 1) {
                    series = {
                        data : []
                    };
                    //add data to the series
                    seriesArr = this.point(chartName, series,
                        FCObj.dataset[index], FCObj.chart, HCObj, conf.oriCatTmp.length,
                        index);


                    //if the returned series is an array of series (case: pareto)
                    if (seriesArr instanceof Array) {
                        HCObj.series = HCObj.series.concat(seriesArr)
                    }
                    //all other case there will be only1 series
                    else {
                        HCObj.series.push(seriesArr);
                    }
                }
                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                //for log it will be done in configureAxis
                if (FCObj.trendlines && !this.isLog) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, conf,
                        false, this.isBar);
                }

            }
        },
        categoryAdder : function(FCObj, HCObj) {
            var index, countCat = 0, fontSize, conf = HCObj[FC_CONFIG_STRING],
            axisGridManager = conf.axisGridManager, FCChartObj = FCObj.chart,
            xAxisObj = HCObj.xAxis, dataLabel, axisConf = conf.x, showLabels;
            if (FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                //update the font relate attr in HC cat
                if (FCObj.categories[0].font) {
                    HCObj.xAxis.labels.style.fontFamily  = FCObj.categories[0].font;
                }
                if ((fontSize = pluckNumber(FCObj.categories[0].fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }
                if (FCObj.categories[0].fontcolor) {
                    HCObj.xAxis.labels.style.color  = FCObj.categories[0].fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, "#");
                }
                //temp object for cat text in data tooltext
                var oriCatTmp = HCObj[FC_CONFIG_STRING].oriCatTmp,
                categories = FCObj.categories[0].category;
                for (index = 0; index < categories.length; index += 1) {
                    if (!categories[index].vline) {
                        showLabels = pluckNumber(categories[index].showlabel, FCChartObj.showlabels, 1);
                        dataLabel = showLabels ? parseUnsafeString(getFirstValue(FCObj.categories[0].category[index].label,
                            FCObj.categories[0].category[index].name)) : BLANKSTRING;
                        axisGridManager.addXaxisCat(xAxisObj, countCat, countCat, dataLabel);
                        oriCatTmp[countCat] = getFirstValue(parseUnsafeString(
                            FCObj.categories[0].category[index].tooltext), dataLabel);
                        countCat += 1;
                    }
                    else {
                        axisGridManager.addVline(xAxisObj, categories[index], countCat, HCObj);
                    }
                }
            }
            axisConf.catCount = countCat;
        },

        // Function to create tooltext for individual data points
        getPointStub: function (setObj, value, label, HCObj, dataset, datasetShowValues, yAxisIndex) {
            var toolText, displayValue, dataLink, HCConfig = HCObj[FC_CONFIG_STRING],
            showPercentValuesRequared, showPercentInToolTipRequared,
            isSY = yAxisIndex === 1 ? true : false,
            formatedVal = value === null ? value : HCConfig.numberFormatter.dataLabels(value, isSY),
            seriesname, setTooltext = getValidValue(parseUnsafeString(setObj.tooltext)),
            tooltipSepChar = HCConfig.tooltipSepChar;

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = false;
            }
            // if tooltext is given in data object
            else if (setTooltext !== undefined) {
                toolText = setTooltext;
            }
            else {//determine the tooltext then
                if (formatedVal === null) {
                    toolText = false;
                } else {
                    if (HCConfig.seriesNameInToolTip) {
                        seriesname = getFirstValue(dataset && dataset.seriesname);
                    }
                    toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;
                    toolText += label ? label + tooltipSepChar : BLANKSTRING;
                    if (HCConfig.showPercentInToolTip){
                        showPercentInToolTipRequared = true;
                    }
                    else {
                        toolText += formatedVal;
                    }
                }
            }

            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, datasetShowValues)) {
                displayValue = BLANKSTRING;
            }
            else if (getValidValue(setObj.displayvalue) !== undefined) {
                displayValue = setObj.displayvalue
            }
            else if (HCConfig.showPercentValues){
                showPercentValuesRequared = true;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            dataLink = pluck(setObj.link);

            return {
                displayValue : displayValue,
                toolText : toolText,
                link: dataLink,
                showPercentValues : showPercentValuesRequared,
                showPercentInToolTip : showPercentInToolTipRequared
            };
        }
    }, chartAPI.singleseries);
    //// add the multyseries
    var sortFN = function (a, b) {
        return a - b;
    }

    chartAPI('xybase', {
        hideRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.hide) {
                regrationLineSeries.hide();
            }
        },
        showRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.show) {
                regrationLineSeries.show();
            }
        },
        getRegressionLineSeries : function (regrationObj, showYOnX, dataLength) {
            var data, xMin, xMax, yMin, yMax, slopeB, firstY, secondY, firstX, secondX,
            sumXY = regrationObj.sumXY,
            sumX = regrationObj.sumX,
            sumY = regrationObj.sumY,
            xValues = regrationObj.xValues,
            sumXsqure = regrationObj.sumXsqure,
            yValues = regrationObj.yValues,
            sumYsqure = regrationObj.sumYsqure;
            if(showYOnX){
                //Short the array
                xValues.sort(sortFN);
                //Store X minimum and maximum no
                xMin = xValues[0];
                xMax = xValues[xValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumXsqure - Math.pow(sumX, 2));
                firstY = (!isNaN(slopeB))? (slopeB * (xMin - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;
                secondY = (!isNaN(slopeB))? (slopeB * (xMax - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;

                data = [{
                    x : xMin,
                    y : firstY
                }, {
                    x : xMax,
                    y : secondY
                }];
            } else {
                //Short the array
                yValues.sort(sortFN);
                //Store Y minimum and maximum no
                yMin = yValues[0];
                yMax = yValues[yValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumYsqure - Math.pow(sumY, 2));
                firstX = (!isNaN(slopeB))? (slopeB * (yMin - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;
                secondX = (!isNaN(slopeB))? (slopeB * (yMax - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;

                data = [{
                    x : firstX,
                    y : yMin
                }, {
                    x : secondX,
                    y : yMax
                }];
            }
            return data;
        },
        pointValueWatcher: function (HCObj, valueY, valueX, regressionObj) {
            var obj, FCconf = HCObj[FC_CONFIG_STRING], objX;
            if (valueY !== null) {
                obj = FCconf[0];
                obj.max = obj.max > valueY ? obj.max : valueY;
                obj.min = obj.min < valueY ? obj.min : valueY;
            }
            if (valueX !== null) {
                objX = FCconf.x;
                objX.max = objX.max > valueX ? objX.max : valueX;
                objX.min = objX.min < valueX ? objX.min : valueX;
            }
            //code for regration line
            if (regressionObj) {
                var itemValueX = valueX || 0,
                itemValueY = valueY || 0;
                //Calculating the summation of X.
                regressionObj.sumX += itemValueX;
                //Calculating the summation of Y.
                regressionObj.sumY += itemValueY;
                //Calculating the summation of XY.
                regressionObj.sumXY += itemValueX * itemValueY;
                //Calculating the summation of X
                regressionObj.sumXsqure += Math.pow(itemValueX, 2);
                //Push all the x values
                regressionObj.xValues.push(itemValueX);
                //Calculating the summation of Y
                regressionObj.sumYsqure += Math.pow(itemValueY, 2);
                //Push all the y values
                regressionObj.yValues.push(itemValueY);

            }
        }

    }, chartAPI.multiseries);

    chartAPI('scrollbase', {
        
        postSeriesAddition: function (HCObj, FCObj) {

            //add the scroll Flag at chart so taht the cliprect works properluy
            HCObj.chart.hasScroll = true;

            var xAxis = HCObj.xAxis,
            scollOptions = xAxis.scroll,
            config = HCObj[FC_CONFIG_STRING],
            width = config.width,
            catCount = config.x.catCount,
            FCChart = FCObj.chart;
            config.isScroll = true;
            if (this.isStacked) {
                numberOfColumnSeries = 1;
            }
            else {
                var numberOfColumnSeries = 0, i = 0, length, seriesArr = HCObj.series,
                type, columnStr = 'column', defaultseries = HCObj.chart.defaultSeriesType;
                for (length = seriesArr.length; i < length; i ++) {
                    type = pluck(seriesArr[i].type, defaultseries);
                    if (type === columnStr) {
                        numberOfColumnSeries += 1;
                    }
                }
                if (numberOfColumnSeries < 1) {
                    numberOfColumnSeries = 1;
                }

            }

            var totalNumPoint = catCount * numberOfColumnSeries,
            numVisiblePlot = pluckNumber(FCChart.numvisibleplot, Math.floor(width / this.avgScrollPointWidth));

            // Validate numVisiblePlot and then enable the scroll.
            if (scollOptions && numVisiblePlot >= 2 && numVisiblePlot < totalNumPoint) {
                scollOptions.enabled = true;
                scollOptions.vxLength = numVisiblePlot / numberOfColumnSeries;
                scollOptions.startPercent = FCChart.scrolltoend === ONESTRING ?
                1 : 0;

                scollOptions.padding = pluckNumber(FCChart.scrollpadding,
                    HCObj.chart.plotBorderWidth / 2);
                scollOptions.height = pluckNumber(FCChart.scrollheight, 16);
                scollOptions.buttonWidth = pluckNumber(FCChart.scrollbtnwidth,
                    FCChart.scrollheight, 16);
                scollOptions.buttonPadding = pluckNumber(FCChart.scrollbtnpadding, 0);
                scollOptions.color = getFirstColor(pluck(FCChart.scrollcolor,
                    defaultPaletteOptions.altHGridColor[HCObj.chart.paletteIndex]));

                //add the space for scroller
                config.marginBottomExtraSpace +=
                scollOptions.padding + scollOptions.height;

            }



        }
    }, chartAPI.multiseries);



    //////// COMMOM Charts to be use as charts as well as PowerCharts   //////////////




    /////////////////  column2d //////////////
    var singleSeriesAPI = chartAPI.singleseries,
    multiSeriesAPI = chartAPI.multiseries;

    //add the charts
    //only the point and default series will differ from singleSeriesAPI
    chartAPI('column2dbase', {
        point : function (chartName, series, data, FCChartObj, HCObj) {

            var
            itemValue, index, countPoint, dataLabel, setColor, setAlpha,
            setRatio, colorArr, dataObj, setAngle, showLabel, pointShadow,
            // length of the data
            length = data.length,
            // HighCharts configuration
            conf = HCObj[FC_CONFIG_STRING],
            // axisGridManager to manage the axis
            // it contains addVline, addXaxisCat, addAxisAltGrid and
            // addAxisGridLine function
            axisGridManager = conf.axisGridManager,
            // HighCharts xAxis obj
            xAxisObj = HCObj.xAxis,
            // palette of the chart
            paletteIndex = HCObj.chart.paletteIndex,
            // xAxis configuration it contains configuration of xAxis like
            // catCount, horizontalAxisNamePadding, horizontalLabelPadding,
            // labelDisplay, slantLabels, staggerLines
            xAxisConf = conf.x,
            // Array of default colors (paletteColors)
            // We use it to specify the individual data point color
            defaultColors = HCObj.colors,
            // Length of the default colors
            defaultColLen = HCObj.colors.length,
            // is3d and isBar helps to get the column color by getColumnColor function
            // whether the chart is a 3D or Bar
            is3d = /3d$/.test(HCObj.chart.defaultSeriesType),
            isBar = this.isBar,
            // dataplot border width
            // Managing for 3D too
            showPlotBorder = pluck(FCChartObj.showplotborder,
                (is3d ? ZEROSTRING : ONESTRING) ) === ONESTRING,
            // 3D column chart doesn't show the plotborder by default until we set showplotborder true
            setBorderWidth = showPlotBorder ?
            (is3d ? 1 : pluckNumber(FCChartObj.plotborderthickness, 1)) : 0,
            // whether to use round edges or not in the column
            isRoundEdges = HCObj.chart.useRoundEdges,
            // dataplot border alpha
            setPlotBorderAlpha = pluckNumber(FCChartObj.plotborderalpha, FCChartObj.plotfillalpha, 100),
            // dataplot border color
            setPlotBorderColor = pluck(FCChartObj.plotbordercolor,
                defaultPaletteOptions.plotBorderColor[paletteIndex]).split(COMMASTRING)[0],
            // Original index of the data inside the loop
            catIndex = 0,
            // use3DLighting to show gredient color effect in 3D Column charts
            use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting, 1)),
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
            // Calculate the dashStyle per point
            pointDashStyle,
            seriesDashStyle = pluckNumber(FCChartObj.plotborderdashed, 0),
            // length of the dash
            seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5),
            // distance between dash
            seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4);

            // Iterate through all level data
            // We are managing the data value labels and other cosmetics inside this loop
            for (index = 0, countPoint = 0; index < length; index += 1) {

                // individual data obj
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function, that creates vline
                // and we stop execution here and continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex, HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and return
                // the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);
                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel, FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using label as well as name too
                // we give priority to label if label is not there, we check the name attribute
                dataLabel = parseUnsafeString(!showLabel ? BLANKSTRING : getFirstValue(dataObj.label, dataObj.name));
                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex, dataLabel);
                catIndex += 1;

                // <set> cosmetics
                // Color of the particular data
                setColor = pluck(dataObj.color, defaultColors[countPoint % defaultColLen]) +
                COMMASTRING + getDefinedColor(FCChartObj.plotgradientcolor, defaultPaletteOptions.plotGradientColor[paletteIndex]);
                // Alpha of the data
                setAlpha = pluck(dataObj.alpha, FCChartObj.plotfillalpha, HUNDREDSTRING);
                // Fill ratio of the data
                setRatio = pluck(dataObj.ratio, FCChartObj.plotfillratio);
                // defaultAngle depend upon item value
                setAngle = pluck(360 - FCChartObj.plotfillangle, 90);
                if (itemValue < 0) {
                    setAngle = 360 - setAngle;
                }

                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: setAlpha / 100,
                    inverted: isBar
                };

                // calculate the color object for the column
                colorArr = getColumnColor (setColor, setAlpha, setRatio,
                    setAngle, isRoundEdges, setPlotBorderColor,
                    pluck(dataObj.alpha, setPlotBorderAlpha) + BLANKSTRING, isBar, is3d);

                // get per-point dash-style
                pointDashStyle = pluckNumber(dataObj.dashed, seriesDashStyle) ?
                getDashStyle(pluck(dataObj.dashlen, seriesDashLen),
                    pluck(dataObj.dashgap, seriesDashGap), setBorderWidth) : undefined;

                // Finally add the data
                // we call getPointStub function that manage displayValue, toolText and link
                series.data.push( extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj), {
                        y: itemValue,
                        shadow: pointShadow,
                        color: colorArr[0],
                        borderColor: colorArr[1],
                        borderWidth: setBorderWidth,
                        use3DLighting: use3DLighting,
                        dashStyle: pointDashStyle
                    })
                );
                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            // set the xAxisConf catCount for further use
            xAxisConf.catCount = catIndex;

            return series;
        },
        defaultSeriesType : 'column'
    }, singleSeriesAPI);




    /////////////// Line ///////////
    chartAPI('linebase', {
        defaultSeriesType : 'line',
        hasVDivLine : true,
        defaultPlotShadow: 1,

        point : function (chartName, series, data, FCChartObj, HCObj) {
            var itemValue, index, dataLabel, dataObj,
            countPoint, showLabel, dashStyle, pointShadow,
            lineDashLen, lineDashGap, lineColor, lineAlpha, lineThickness,
            lineDashed, drawAnchors, lineColorDef, lineAlphaDef,
            pointAnchorEnabled,
            // set attributes
            setAnchorSides, setAnchorBorderThickness, setAnchorBorderColor,
            setAnchorRadius, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha,
            // length of the data
            length = data.length,
            // HighCharts xAxis obj
            xAxisObj = HCObj.xAxis,
            // HighCharts configuration
            conf = HCObj[FC_CONFIG_STRING],
            // axisGridManager to manage the axis
            // it contains addVline, addXaxisCat, addAxisAltGrid and
            // addAxisGridLine function
            axisGridManager = conf.axisGridManager,
            catIndex = 0,
            xAxisConf = conf.x,
            paletteIndex = HCObj.chart.paletteIndex,
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

            // Managing line series cosmetics
            // Color of the line
            lineColorDef = getFirstColor(pluck(FCChartObj.linecolor,
                FCChartObj.palettecolors,
                defaultPaletteOptions.plotFillColor[paletteIndex]));
            // alpha
            lineAlphaDef = pluck(FCChartObj.linealpha, HUNDREDSTRING);
            // thickness
            lineThickness = pluckNumber(FCChartObj.linethickness, 4);
            // to use dash line
            lineDashed = Boolean(pluckNumber(FCChartObj.linedashed, 0));
            // length of the dash
            lineDashLen = pluckNumber(FCChartObj.linedashlen, 5);
            // distance between dash
            lineDashGap = pluckNumber(FCChartObj.linedashgap, 4);

            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.color = {
                FCcolor: {
                    color: lineColorDef,
                    alpha: lineAlphaDef
                }
            };

            // set the line thickness (line width)
            series.lineWidth = lineThickness;

            // IF its a step line chart
            series.step = this.stepLine;
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(FCChartObj.drawverticaljoins, 1));

            // IF its a Kagi chart chart
            series.kagi = this.isKagi;

            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors);

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {
                // individual data obj
                // for further manipulation
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function, that creates vline
                // and we stop execution here and continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex, HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and return
                // the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel, FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using label as well as name too
                // we give priority to label if label is not there, we check the name attribute
                dataLabel = parseUnsafeString(!showLabel ? BLANKSTRING : getFirstValue(dataObj.label, dataObj.name));

                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex, dataLabel);
                catIndex += 1;

                // Managing line series cosmetics
                // Color of the line
                lineColor = getFirstColor(pluck( dataObj.color, lineColorDef));
                // alpha
                lineAlpha = pluck(dataObj.alpha, lineAlphaDef);

                // create line dash
                // using dashStyle of HC
                dashStyle = pluck(dataObj.dashed, lineDashed) ? getDashStyle(lineDashLen,
                    lineDashGap, lineThickness) : undefined;

                pointShadow = {
                    opacity: lineAlpha / 100
                };

                // Anchor cosmetics in data points
                // Getting anchor cosmetics for the data points or its default values
                // The default value is different from flash in order to render a
                // perfect circle when no anchorside is provided.
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);

                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef));
                setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[paletteIndex]));
                setAnchorAlpha = pluck(dataObj.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);
                pointAnchorEnabled = drawAnchors === undefined ?
                lineAlpha != 0 : !!drawAnchors;

                // Finally add the data
                // we call getPointStub function that manage displayValue, toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        color: {
                            FCcolor: {
                                color: lineColor,
                                alpha: lineAlpha
                            }
                        },
                        shadow: pointShadow,
                        dashStyle: dashStyle,
                        marker : {
                            enabled: !!pointAnchorEnabled,
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            symbol: mapSymbolName(setAnchorSides)
                        }
                    }));

                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;
            //return series
            return series;
        }
    }, singleSeriesAPI);


    /////////////// Area ///////////
    chartAPI('area2dbase', {
        defaultSeriesType : 'area',
        hasVDivLine : true,

        point :
        function (chartName, series, data, FCChartObj, HCObj) {
            var itemValue, index, dataLabel,  showLabel,
            seriesFillColor, seriesFillAlpha, seriesFillAngle, seriesFillRatio,
            seriesLineColor, seriesLineAlpha, seriesLineAngle, seriesLineRatio,
            setAnchorSides, setAnchorRadius, setAnchorBorderColor, dataObj,
            setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha, drawAnchors,
            seriesDashed, seriesDashLen, seriesDashGap, seriesLineThickness,
            setAnchorBorderThickness, countPoint, setColor, setAlpha,
            seriesGradientColor, pointShadow, seriesFill, pointFillColor,
            // Data array in dataset object
            length = data.length,
            // HighCharts xAxis obj
            xAxisObj = HCObj.xAxis,
            // HighChart configuration object
            conf = HCObj[FC_CONFIG_STRING],
            // Index of the palette to be use for charts palette cosmetics
            paletteIndex = HCObj.chart.paletteIndex,
            // axisGridManager to manage the axis
            // it contains addVline, addXaxisCat, addAxisAltGrid and
            // addAxisGridLine function
            axisGridManager = conf.axisGridManager,
            xAxisConf = conf.x,
            catIndex = 0,
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

            // Managing Area cosmetics
            // Color of the area
            seriesFillColor = pluck(FCChartObj.plotfillcolor, FCChartObj.areabgcolor,
                (getValidValue(FCChartObj.palettecolors) ? HCObj.colors[0] :
                    defaultPaletteOptions.plotFillColor[paletteIndex])).split(COMMASTRING)[0];
            // GradientColor of the area fill
            seriesGradientColor = COMMASTRING + getDefinedColor(FCChartObj.plotgradientcolor, defaultPaletteOptions.plotGradientColor[paletteIndex]);

            seriesFillAlpha = pluck(FCChartObj.plotfillalpha, FCChartObj.areaalpha, '90');
            seriesFillAngle = pluckNumber(FCChartObj.plotfillangle , 270);

            // Managing line series cosmetics
            // Color of the line
            seriesLineColor = pluck(FCChartObj.plotbordercolor,
                FCChartObj.areabordercolor,
                (getValidValue(FCChartObj.palettecolors) ?
                    HCObj.colors[0] : defaultPaletteOptions.plotBorderColor[paletteIndex])).split(COMMASTRING)[0];

            // Plot border alpha
            seriesLineAlpha = FCChartObj.showplotborder == ZEROSTRING ?
            ZEROSTRING : pluck(FCChartObj.plotborderalpha,
                FCChartObj.plotfillalpha, FCChartObj.areaalpha,
                HUNDREDSTRING);
            seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270);
            seriesLineRatio = HUNDREDSTRING;
            seriesDashed = Boolean(pluckNumber(FCChartObj.plotborderdashed, 0));
            seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5);
            seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4);
            // Plot border thickness
            seriesLineThickness = pluckNumber(FCChartObj.plotborderthickness,
                FCChartObj.areaborderthickness, 1);
            // Set the area fill color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            seriesFill = series.fillColor = {
                FCcolor: {
                    color: seriesFillColor + seriesGradientColor,
                    alpha: seriesFillAlpha,
                    ratio: BGRATIOSTRING,
                    angle: seriesFillAngle
                }
            };

            series.lineWidth = seriesLineThickness;
            series.dashStyle  = seriesDashed ? getDashStyle(seriesDashLen,
                seriesDashGap, seriesLineThickness) : undefined;
            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.lineColor = {
                FCcolor: {
                    color: seriesLineColor,
                    alpha: seriesLineAlpha,
                    ratio: seriesLineRatio,
                    angle: seriesLineAngle
                }
            };

            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = Boolean(pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors , 1));

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {

                dataObj = data[index];

                // vLine
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex, HCObj);
                    continue;
                }

                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                showLabel = pluckNumber(dataObj.showlabel, FCChartObj.showlabels, 1);
                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using label as well as name too
                // we give priority to label if label is not there, we check the name attribute
                dataLabel = parseUnsafeString(!showLabel ? BLANKSTRING : getFirstValue(dataObj.label, dataObj.name));
                // Put label in Highcharts xAxis categories
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex, dataLabel);
                catIndex += 1;

                // Taking default anchor cosmetics form dataset obj or Chart obj or default
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                    FCChartObj.anchorbordercolor, seriesLineColor));
                setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[paletteIndex]));
                setAnchorAlpha = pluck(dataObj.anchoralpha, FCChartObj.anchoralpha, this.anchorAlpha, ZEROSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);


                // Managing line series cosmetics
                // Color of the line
                
                setColor = getValidValue(dataObj.color);
                // alpha
                setAlpha = pluckNumber(dataObj.alpha);

                if (setColor !== undefined || setAlpha !== undefined) {
                    pointFillColor = {
                        FCcolor: {
                            color: setColor ? getFirstColor(setColor) + seriesGradientColor : seriesFillColor,
                            alpha: undefined === setAlpha ? getFirstAlpha(setAlpha) + BLANKSTRING : seriesFillAlpha,
                            ratio: BGRATIOSTRING,
                            angle: seriesFillAngle
                        }
                    }
                }
                else {
                    pointFillColor = seriesFill;
                }


                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: Math.max(setAlpha, seriesLineAlpha) / 100,
                    inverted: true
                };

                // Finally add the data
                // we call getPointStub function that manage displayValue, toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        shadow: pointShadow,
                        color: pointFillColor,
                        marker : {
                            enabled: drawAnchors,
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            symbol: mapSymbolName(setAnchorSides)
                        }
                    }));

                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;

            //return series
            return series;
        }
    }, singleSeriesAPI);



    /////////////// mscolumn2d ///////////
    chartAPI('mscolumn2dbase', {
        /*
         *  Function for MSColumn2D chart
         *  @param {string} chartName name of the chart eg: column2d
         *  @param {object} series HighChart series object where the point will be added
         *  @param {object} dataset corresponding FusionCharts dataset object
         *  @param {object} FCChartObj FusionCharts JSON of chart tag
         *  @param {object} HCObj HighChart JSON object
         *  @param {number} catLength total number of categories
         *  @param {number} seriesIndex index position of that series
         *  @param {number} MSStackIndex stack index of that series (only for MSStacked)
         */
        point : function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex, MSStackIndex) {
            var hasValidPoint = false;
            // We proceed if there is data inside dataset object
            if (dataset.data) {
                var itemValue, index, setColor, setAlpha, dataObj,
                setRatio, setAngle, setBorderWidth, isRoundEdges, isBar, is3d,
                setPlotBorderColor, setPlotBorderAlpha, colorArr, dataLabel,
                pointShadow, plotBorderAlpha,
                data = dataset.data,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = HCObj.plotOptions[seriesType] && HCObj.plotOptions[seriesType].stacking,
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                // showValues attribute in individual dataset
                datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                seriesYAxis = pluckNumber(series.yAxis, 0),
                // use3DLighting to show gradient color effect in 3D Column charts
                use3DLighting = pluckNumber(FCChartObj.use3dlighting, 1),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                paletteIndex = HCObj.chart.paletteIndex,
                // Calculate the dashStyle per point
                pointDashStyle,
                seriesDashStyle = pluckNumber(dataset.dashed, FCChartObj.plotborderdashed, 0),
                // length of the dash
                seriesDashLen = pluckNumber(dataset.dashlen, FCChartObj.plotborderdashlen, 5),
                // distance between dash
                seriesDashGap = pluckNumber(dataset.dashgap, FCChartObj.plotborderdashgap, 4);

                // Dataset seriesname
                series.name = getValidValue(dataset.seriesname);

                // If includeInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 || series.name === undefined) {
                    series.showInLegend = false;
                }

                // Color of the individual series
                series.color = pluck(dataset.color, HCObj.colors[seriesIndex % HCObj.colors.length]).split(COMMASTRING)[0].replace(/^#?/g, "#");
                // Column border thickness
                setBorderWidth = pluck(FCChartObj.plotborderthickness , ONESTRING);
                // whether to use round edges or not in the column
                isRoundEdges = HCObj.chart.useRoundEdges;
                // is3d and isBar helps to get the column color by getColumnColor function
                // whether the chart is a 3D or Bar
                isBar = this.isBar;
                is3d = /3d$/.test(HCObj.chart.defaultSeriesType);

                // dataplot border color
                setPlotBorderColor = pluck(FCChartObj.plotbordercolor,
                    defaultPaletteOptions.plotBorderColor[paletteIndex]).split(COMMASTRING)[0];
                // dataplot border alpha
                setPlotBorderAlpha = FCChartObj.showplotborder == ZEROSTRING  ?
                ZEROSTRING : pluck(FCChartObj.plotborderalpha, HUNDREDSTRING);

                // Managing plot border color for 3D column chart
                // 3D column chart doesn't show the plotborder by default until we set showplotborder true
                setPlotBorderAlpha = is3d ? (FCChartObj.showplotborder ?
                    setPlotBorderAlpha : ZEROSTRING) : setPlotBorderAlpha;

                // Default  plotBorderColor  is FFFFFF for this 3d chart
                setPlotBorderColor = is3d ? pluck(FCChartObj.plotbordercolor, "#FFFFFF") : setPlotBorderColor;

                // Iterate through all level data
                // We are managing the data value labels and other cosmetics inside this loop
                for (index = 0; index < catLength; index += 1) {
                    // Individual data object
                    dataObj = data[index];
                    if (dataObj) {
                        // get the valid value
                        itemValue = NumberFormatter.getCleanValue(dataObj.value, isValueAbs);
                        if (itemValue === null) {
                            // add the data
                            series.data.push({
                                y : null
                            });
                            continue;
                        }

                        hasValidPoint = true;
                        // Label of the data
                        // We take the label from HighCharts configuration object
                        dataLabel = conf.oriCatTmp[index];
                        // Individual data point color
                        setColor = pluck(dataObj.color, dataset.color, HCObj.colors[seriesIndex % HCObj.colors.length]) +
                        COMMASTRING + getDefinedColor(FCChartObj.plotgradientcolor, defaultPaletteOptions.plotGradientColor[paletteIndex]);
                        // Alpha of the data point
                        setAlpha = pluck(dataObj.alpha, dataset.alpha, FCChartObj.plotfillalpha, HUNDREDSTRING);
                        setRatio = pluck(dataObj.ratio, dataset.ratio, FCChartObj.plotfillratio);
                        // defaultAngle depend upon item value
                        setAngle = pluck(360 - FCChartObj.plotfillangle, 90);
                        if (itemValue < 0) {
                            setAngle = 360 - setAngle;
                        }
                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: setAlpha / 100
                        };
                        plotBorderAlpha = Math.min(setAlpha, setPlotBorderAlpha) + BLANKSTRING;

                        // calculate the color object for the set
                        colorArr = getColumnColor (setColor, setAlpha, setRatio,
                            setAngle, isRoundEdges, setPlotBorderColor, plotBorderAlpha, isBar, is3d);

                        // get per-point dash-style
                        pointDashStyle = pluckNumber(dataObj.dashed, seriesDashStyle) ?
                        getDashStyle(pluck(dataObj.dashlen, seriesDashLen),
                            pluck(dataObj.dashgap, seriesDashGap), setBorderWidth) : undefined;

                        // add the data
                        series.data.push(extend2(this.getPointStub(dataObj, itemValue, dataLabel, HCObj, dataset, datasetShowValues, seriesYAxis), {
                            y : itemValue,
                            shadow: pointShadow,
                            color: colorArr[0],
                            borderColor: colorArr[1],
                            borderWidth: setBorderWidth,
                            use3DLighting : use3DLighting,
                            dashStyle: pointDashStyle
                        }));

                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                        this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                            isStacked, index, MSStackIndex, seriesType);

                    }
                    else {
                        // add the data
                        series.data.push({
                            y : null
                        });
                    }
                }


            }

            if (!hasValidPoint) {
                series.showInLegend = false
            }

            return series;
        },
        defaultSeriesType : 'column'
    }, multiSeriesAPI);




    /////////////// msline ///////////
    chartAPI('mslinebase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
            var hasValidPoint = false;
            if (dataset.data) {
                var itemValue, index, lineColor, lineAlpha, lineThickness, lineDashed,
                lineDashLen, lineDashGap, drawAnchors, setAnchorAlpha, setAnchorBgAlpha,
                setAnchorBgColor, setAnchorBorderColor, setAnchorBorderThickness,
                setAnchorRadius, setAnchorSides, dataLabel, dataObj, pointShadow,
                setAnchorSidesDef, setAnchorRadiusDef, setAnchorBorderColorDef,
                setAnchorBorderThicknessDef, setAnchorBgColorDef, setAnchorAlphaDef,
                setAnchorBgAlphaDef, lineAlphaDef, lineColorDef,
                pointAnchorEnabled, dashStyle,
                // Data array in dataset object
                data = dataset.data,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = HCObj.plotOptions[seriesType] && HCObj.plotOptions[seriesType].stacking,
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                // showValues attribute in individual dataset
                datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = conf.numberFormatter;

                // Dataset seriesname
                series.name = getValidValue(dataset.seriesname);

                // Line cosmetics attributes
                // Color of the line series
                lineColorDef = getFirstColor(pluck(dataset.color, FCChartObj.linecolor, HCObj.colors[seriesIndex % HCObj.colors.length]));
                // Alpha of the line
                lineAlphaDef = pluck(dataset.alpha, FCChartObj.linealpha, HUNDREDSTRING);
                // Line Thickness
                lineThickness = pluckNumber(dataset.linethickness, FCChartObj.linethickness, 2);
                // Whether to use dashline
                lineDashed = Boolean(pluckNumber(dataset.dashed, FCChartObj.linedashed, 0));

                // line dash attrs
                lineDashLen = pluckNumber(dataset.linedashlen, FCChartObj.linedashlen, 5);
                lineDashGap = pluckNumber(dataset.linedashgap, FCChartObj.linedashgap, 4);

                // Set the line color and alpha to
                // HC seris obj with FusionCharts color format using FCcolor obj
                series.color = {
                    FCcolor: {
                        color: lineColorDef,
                        alpha: lineAlphaDef
                    }
                };

                // IF its a step line chart
                series.step = this.stepLine;
                // Special attribute for StepLine (drawVerticalJoins)
                series.drawVerticalJoins = Boolean(pluckNumber(FCChartObj.drawverticaljoins, 1));

                // Set the line thickness (line width)
                series.lineWidth = lineThickness;
                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = pluckNumber(dataset.drawanchors, dataset.showanchors , FCChartObj.drawanchors, FCChartObj.showanchors);

                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColorDef = getFirstColor(pluck(dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef));
                setAnchorBorderThicknessDef = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[HCObj.chart.paletteIndex]));
                setAnchorAlphaDef = pluck(dataset.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                setAnchorBgAlphaDef = pluck(dataset.anchorbgalpha, FCChartObj.anchorbgalpha,
                    setAnchorAlphaDef);

                // If includeInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 ||
                    series.name === undefined || (lineAlphaDef == 0 &&
                        drawAnchors !== 1)) {
                    series.showInLegend = false;
                }

                //set the marker attr at series
                series.marker = {
                    fillColor: {
                        FCcolor: {
                            color: setAnchorBgColorDef,
                            alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) / 100) + BLANKSTRING
                        }
                    },
                    lineColor: {
                        FCcolor: {
                            color: setAnchorBorderColorDef,
                            alpha: setAnchorAlphaDef + BLANKSTRING
                        }
                    },
                    lineWidth: setAnchorBorderThicknessDef,
                    radius: setAnchorRadiusDef,
                    symbol: mapSymbolName(setAnchorSidesDef)
                };


                // Iterate through all level data
                for (index = 0; index < catLength; index += 1) {
                    // Individual data obj
                    // for further manipulation
                    dataObj = data[index];
                    if (dataObj) {
                        itemValue = NumberFormatter.getCleanValue(dataObj.value, isValueAbs);

                        if (itemValue === null) {
                            // add the data
                            series.data.push({
                                y : null
                            });
                            continue;
                        }

                        hasValidPoint = true;

                        // Anchor cosmetics in data points
                        // Getting anchor cosmetics for the data points or its default values
                        setAnchorSides = pluckNumber(dataObj.anchorsides, setAnchorSidesDef);
                        setAnchorRadius = pluckNumber(dataObj.anchorradius, setAnchorRadiusDef);
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor, setAnchorBorderColorDef));
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness, setAnchorBorderThicknessDef);
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor, setAnchorBgColorDef));
                        setAnchorAlpha = pluck(dataObj.anchoralpha, setAnchorAlphaDef);
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, setAnchorBgAlphaDef);

                        // Managing line series cosmetics
                        // Color of the line
                        lineColor = getFirstColor(pluck(dataObj.color, lineColorDef));

                        // alpha
                        lineAlpha = pluck(dataObj.alpha, lineAlphaDef);

                        // Create line dash
                        // Using dashStyle of HC
                        dashStyle = pluckNumber(dataObj.dashed, lineDashed) ?
                        getDashStyle(lineDashLen, lineDashGap, lineThickness) : undefined;

                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: lineAlpha / 100
                        };
                        pointAnchorEnabled = drawAnchors === undefined ?
                        lineAlpha != 0 : !!drawAnchors;

                        // Label of the data
                        dataLabel = conf.oriCatTmp[index];

                        // Finally add the data
                        // we call getPointStub function that manage displayValue, toolText and link
                        series.data.push(extend2(this.getPointStub(dataObj, itemValue, dataLabel, HCObj, dataset, datasetShowValues, seriesYAxis), {
                            y : itemValue,
                            shadow: pointShadow,
                            dashStyle: dashStyle,
                            color: {
                                FCcolor: {
                                    color: lineColor,
                                    alpha: lineAlpha
                                }
                            },
                            marker : {
                                enabled: pointAnchorEnabled,
                                fillColor: {
                                    FCcolor: {
                                        color: setAnchorBgColor,
                                        alpha: (setAnchorBgAlpha * setAnchorAlpha / 100) + BLANKSTRING
                                    }
                                },
                                lineColor: {
                                    FCcolor: {
                                        color: setAnchorBorderColor,
                                        alpha: setAnchorAlpha
                                    }
                                },
                                lineWidth: setAnchorBorderThickness,
                                radius: setAnchorRadius,
                                symbol: mapSymbolName(setAnchorSides)
                            }
                        }));

                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                        this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                            isStacked, index, 0, seriesType);
                    }
                    else {
                        // add the data
                        series.data.push({
                            y : null
                        });
                    }
                }
            }

            if (!hasValidPoint) {
                series.showInLegend = false
            }

            //return series
            return series;
        },
        defaultSeriesType : 'line',
        defaultPlotShadow: 1
    }, multiSeriesAPI);



    ////// msarea ////////
    chartAPI('msareabase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
            var hasValidPoint = false;
            if (dataset.data) {
                var itemValue, index, dataLabel, dataObj,
                seriesFillColor, seriesFillAlpha, seriesFillAngle, seriesFillRatio,
                seriesLineColor, seriesLineAlpha, seriesLineAngle, seriesLineRatio,
                setAnchorSides, setAnchorRadius, setAnchorBorderColor, setAnchorBorderThickness,
                setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha, drawAnchors, seriesDashed,
                seriesDashLen, seriesDashGap, seriesLineThickness,
                setAnchorSidesDef, setAnchorRadiusDef, setAnchorBorderColorDef,
                setAnchorBorderThicknessDef, setAnchorBgColorDef, setAnchorAlphaDef,
                setAnchorBgAlphaDef, setColor, setAlpha, pointShadow,
                // Data array in dataset object
                data = dataset.data,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = HCObj.plotOptions[seriesType] && HCObj.plotOptions[seriesType].stacking,
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),

                getLink = HCObj['_FCconf'].linkClickFN,
                // Index of the palette to be use for charts palette cosmetics
                paletteIndex = HCObj.chart.paletteIndex,
                // showValues attribute in individual dataset
                datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                // Whether to use yAxis or not
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

                // Dataset seriesname
                series.name = pluck(dataset.seriesname, BLANKSTRING);
                // If includeInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 || series.name === undefined) {
                    series.showInLegend = false;
                }

                // Area fill color
                seriesFillColor = pluck(dataset.color, HCObj.colors[seriesIndex % HCObj.colors.length]).
                split(COMMASTRING)[0].replace(/^#?/g, "#").split(COMMASTRING)[0];
                if (!this.isRadar) {
                    seriesFillColor += COMMASTRING + getDefinedColor(
                        FCChartObj.plotgradientcolor, defaultPaletteOptions.plotGradientColor[paletteIndex]);
                }
                // Alpha of the area fill
                seriesFillAlpha = pluck(dataset.alpha, FCChartObj.plotfillalpha,
                    FCChartObj.areaalpha, this.isRadar ? '50' : '70');
                // Angle of the area fill
                seriesFillAngle = pluckNumber(FCChartObj.plotfillangle, 270);
                // Angle of the fill ratio
                seriesFillRatio = BGRATIOSTRING;

                // Area line cosmetics
                seriesLineColor = pluck(dataset.plotbordercolor, FCChartObj.plotbordercolor, FCChartObj.areabordercolor,
                    this.isRadar ? HCObj.colors[seriesIndex % HCObj.colors.length] :
                    defaultPaletteOptions.plotFillColor[HCObj.chart.paletteIndex]).split(COMMASTRING)[0];


                // Area border cosmetics
                // alpha
                seriesLineAlpha = pluck(dataset.showplotborder, FCChartObj.showplotborder) == ZEROSTRING  ?
                ZEROSTRING : pluck(dataset.plotborderalpha, FCChartObj.plotborderalpha, dataset.plotfillalpha, FCChartObj.plotfillalpha, '95'),

                seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270);
                seriesLineRatio = HUNDREDSTRING;
                // to use dash line
                seriesDashed = Boolean(pluckNumber(dataset.dashed, FCChartObj.plotborderdashed, 0));
                // length of the dash
                seriesDashLen = pluckNumber(dataset.dashlen, FCChartObj.plotborderdashlen, 5);
                // distance between dash
                seriesDashGap = pluckNumber(dataset.dashgap, FCChartObj.plotborderdashgap, 4);
                // thickness
                seriesLineThickness = pluck(dataset.plotborderthickness, FCChartObj.plotborderthickness, 1);

                // Set the area fill color and alpha to
                // HC seris obj with FusionCharts color format using FCcolor obj
                series.fillColor = {
                    FCcolor: {
                        color: seriesFillColor,
                        alpha: seriesFillAlpha,
                        ratio: seriesFillRatio,
                        angle: seriesFillAngle
                    }
                };

                // To set the color of the legend icon, we need to set the series color
                series.color = seriesFillColor;

                // set the line color and alpha to
                // HC seris obj with FusionCharts color format using FCcolor obj
                series.lineColor = {
                    FCcolor: {
                        color: seriesLineColor,
                        alpha: seriesLineAlpha,
                        ratio: seriesLineRatio,
                        angle: seriesLineAngle
                    }
                };
                // set the line thickness (line width)
                series.lineWidth = seriesLineThickness;
                // create line dash
                // using dashStyle of HC
                series.dashStyle  = seriesDashed ? getDashStyle(seriesDashLen, seriesDashGap, seriesLineThickness) : undefined;

                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = Boolean(pluckNumber(FCChartObj.drawanchors , FCChartObj.showanchors , 1));
                // Taking default anchor cosmetics form dataset obj or Chart obj or default
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColorDef = getFirstColor(pluck(dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, seriesFillColor));
                setAnchorBorderThicknessDef = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[paletteIndex]));
                setAnchorAlphaDef = pluckNumber(dataset.anchoralpha,
                    FCChartObj.anchoralpha, this.anchorAlpha, 0);
                setAnchorBgAlphaDef = pluckNumber(dataset.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlphaDef);

                //set the marker attr at series
                series.marker = {
                    fillColor: {
                        FCcolor: {
                            color: setAnchorBgColorDef,
                            alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) / 100) + BLANKSTRING
                        }
                    },
                    lineColor: {
                        FCcolor: {
                            color: setAnchorBorderColorDef,
                            alpha: setAnchorAlphaDef + BLANKSTRING
                        }
                    },
                    lineWidth: setAnchorBorderThicknessDef,
                    radius: setAnchorRadiusDef,
                    symbol: mapSymbolName(setAnchorSidesDef)
                };




                // Iterate through all level data
                for (index = 0; index < catLength; index += 1) {
                    // individual data obj
                    // for further manipulation
                    dataObj = data[index];
                    if (dataObj) {
                        // get the valid value
                        // parsePointValue check the its a value value of not and return
                        // the valid value
                        itemValue = dataObj ? NumberFormatter.getCleanValue(dataObj.value, isValueAbs) : null;
                        if (itemValue === null) {
                            // add the data
                            series.data.push({
                                y : null
                            });
                            continue;
                        }

                        hasValidPoint = true;
                        // Label of the data
                        dataLabel = conf.oriCatTmp[index];


                        // Anchor cosmetics in data points
                        // Getting anchor cosmetics for the data points
                        // or its default values as we calculated
                        setAnchorSides = pluckNumber(dataObj.anchorsides, setAnchorSidesDef);
                        setAnchorRadius = pluckNumber(dataObj.anchorradius, setAnchorRadiusDef);
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor, setAnchorBorderColorDef));
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness, setAnchorBorderThicknessDef);
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor, setAnchorBgColorDef));
                        setAnchorAlpha = pluck(dataObj.anchoralpha, setAnchorAlphaDef);
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, setAnchorBgAlphaDef);

                        setColor = pluck(dataObj.color, seriesFillColor);
                        setAlpha = pluck(dataObj.alpha, seriesFillAlpha);
                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: Math.max(setAlpha, seriesLineAlpha) / 100,
                            inverted: true
                        };

                        // Finally add the data
                        // we call getPointStub function that manage displayValue, toolText and link
                        series.data.push(extend2(this.getPointStub(dataObj, itemValue, dataLabel, HCObj, dataset, datasetShowValues, seriesYAxis), {
                            y : itemValue,
                            shadow: pointShadow,
                            color: {
                                FCcolor: {
                                    color: setColor,
                                    alpha: setAlpha
                                }
                            },
                            marker : {
                                enabled: drawAnchors,
                                fillColor: {
                                    FCcolor: {
                                        color: setAnchorBgColor,
                                        alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                    }
                                },
                                lineColor: {
                                    FCcolor: {
                                        color: setAnchorBorderColor,
                                        alpha: setAnchorAlpha + BLANKSTRING
                                    }
                                },
                                lineWidth: setAnchorBorderThickness,
                                radius: setAnchorRadius,
                                symbol: mapSymbolName(setAnchorSides)
                            },
                            events: {
                                click: getLink
                            }
                        }));


                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                        this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                            isStacked, index, 0, seriesType);
                    }
                    else {
                        // add the data
                        series.data.push({
                            y : null
                        });
                    }
                }
            }

            if (!hasValidPoint) {
                series.showInLegend = false
            }
            return series;
        },
        defaultSeriesType : 'area',
        defaultPlotShadow: 0
    }, multiSeriesAPI);

    //////scatter base ////////
    chartAPI('scatterbase', {
        showValues : 0,
        defaultPlotShadow: 0,
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
            if (dataset.data) {
                var itemValueY, index, lineColor, lineAlpha, lineThickness, lineDashed,
                lineDashLen, lineDashGap, drawAnchors, dataLabel, dataObj, pointShadow,
                seriesAnchorSides, seriesAnchorRadius, seriesAnchorBorderColor,
                seriesAnchorBorderThickness, seriesAnchorBgColor, seriesAnchorAlpha,
                seriesAnchorBgAlpha, setAnchorSides, setAnchorRadius, setAnchorBorderColor,
                setAnchorBorderThickness, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha,
                itemValueX, hasValidPoint = false,
                pointStub, chartNameAPI = chartAPI[chartName],
                // Whether to draw scatter line
                drawLine = pluckNumber(dataset.drawline, 0),
                drawProgressionCurve = pluckNumber(dataset.drawprogressioncurve, 0),
                conf = HCObj[FC_CONFIG_STRING],
                // Data array in dataset object
                data = dataset.data,
                regressionData,
                dataLength = data.length,
                // showValues attribute in individual dataset
                datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                NumberFormatter = conf.numberFormatter,

                //Regratation line
                showRegressionLine = pluckNumber(dataset.showregressionline,
                    FCChartObj.showregressionline, 0);

                //add z index so that the regration line set at the back of the series
                series.zIndex = 1;

                // Dataset seriesname
                series.name = getValidValue(dataset.seriesname);
                // If showInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 || series.name === undefined) {
                    series.showInLegend = false;
                }

                if (drawLine || drawProgressionCurve) {
                    if (drawProgressionCurve) {
                        series.type = 'spline';
                    }
                    // Line cosmetics attributes
                    // Color of the line series
                    lineColor = getFirstColor(pluck(dataset.color, FCChartObj.linecolor, HCObj.colors[seriesIndex % HCObj.colors.length]));
                    // Alpha of the line
                    lineAlpha = pluck(dataset.alpha, FCChartObj.linealpha, HUNDREDSTRING);
                    // Line Thickness
                    lineThickness = pluckNumber(dataset.linethickness, FCChartObj.linethickness, 2);
                    // Whether to use dashline
                    lineDashed = Boolean(pluckNumber(dataset.dashed, FCChartObj.linedashed, 0));

                    // line dash attrs
                    lineDashLen = pluckNumber(dataset.linedashlen, FCChartObj.linedashlen, 5);
                    lineDashGap = pluckNumber(dataset.linedashgap, FCChartObj.linedashgap, 4);

                    // Set the line color and alpha to
                    // HC seris obj with FusionCharts color format using FCcolor obj
                    series.color = {
                        FCcolor: {
                            color: lineColor,
                            alpha: lineAlpha
                        }
                    };

                    // Set the line thickness (line width)
                    series.lineWidth = lineThickness;
                    // Create line dash
                    // Using dashStyle of HC
                    series.dashStyle = lineDashed ? getDashStyle(lineDashLen, lineDashGap, lineThickness) : undefined;
                }

                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = Boolean(pluckNumber(dataset.drawanchors, dataset.showanchors,
                    FCChartObj.drawanchors, FCChartObj.showanchors, 1));

                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                seriesAnchorSides = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, seriesIndex + 3);
                seriesAnchorRadius = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3);
                seriesAnchorBorderColor = getFirstColor(pluck(dataset.anchorbordercolor, dataset.color,
                    FCChartObj.anchorbordercolor, lineColor, HCObj.colors[seriesIndex % HCObj.colors.length]));
                seriesAnchorBorderThickness = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                seriesAnchorBgColor = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, defaultPaletteOptions.anchorBgColor[HCObj.chart.paletteIndex]));
                seriesAnchorAlpha = pluck(dataset.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                seriesAnchorBgAlpha = pluck(dataset.anchorbgalpha, FCChartObj.anchorbgalpha,
                    seriesAnchorAlpha);


                //set the marker attr at series
                series.marker = {
                    fillColor: this.getPointColor(seriesAnchorBgColor, HUNDREDSTRING),
                    lineColor: {
                        FCcolor: {
                            color: seriesAnchorBorderColor,
                            alpha: seriesAnchorAlpha + BLANKSTRING
                        }
                    },
                    lineWidth: seriesAnchorBorderThickness,
                    radius: seriesAnchorRadius,
                    symbol: mapSymbolName(seriesAnchorSides)
                };

                if (showRegressionLine) {
                    series.events = {
                        hide : this.hideRLine,
                        show : this.showRLine
                    };
                    //regration object used in XY chart
                    //create here to avoid checking always
                    var regressionObj = {
                        sumX : 0,
                        sumY : 0,
                        sumXY : 0,
                        sumXsqure : 0,
                        sumYsqure : 0,
                        xValues : [],
                        yValues : []
                    }, regSeries,
                    showYOnX = pluckNumber(dataset.showyonx, FCChartObj.showyonx, 1),
                    regressionLineColor = getFirstColor(pluck(dataset.regressionlinecolor,
                        FCChartObj.regressionlinecolor, seriesAnchorBorderColor)),
                    regressionLineThickness = pluckNumber(dataset.regressionlinethickness,
                        FCChartObj.regressionlinethickness, seriesAnchorBorderThickness),
                    regressionLineAlpha = getFirstAlpha(pluckNumber(dataset.regressionlinealpha,
                        FCChartObj.regressionlinealpha, seriesAnchorAlpha)),
                    regLineColor = convertColor(regressionLineColor, regressionLineAlpha);
                }

                // Iterate through all level data
                for (index = 0; index < dataLength; index += 1) {
                    // Individual data obj
                    // for further manipulation
                    dataObj = data[index];
                    if (dataObj) {
                        itemValueY = NumberFormatter.getCleanValue(dataObj.y);
                        itemValueX = NumberFormatter.getCleanValue(dataObj.x);

                        if (itemValueY === null) {
                            series.data.push({
                                y: null,
                                x: itemValueX
                            });
                            continue;
                        }

                        hasValidPoint = true;

                        pointStub = chartNameAPI
                        .getPointStub(dataObj, itemValueY, NumberFormatter.xAxis(itemValueX), HCObj, dataset, datasetShowValues);


                        // Anchor cosmetics
                        // We first look into dataset then chart obj and then default value.
                        setAnchorSides = pluckNumber(dataObj.anchorsides, seriesAnchorSides);
                        setAnchorRadius = pluckNumber(dataObj.anchorradius, seriesAnchorRadius);
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor, seriesAnchorBorderColor));
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness, seriesAnchorBorderThickness);
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor, seriesAnchorBgColor));
                        setAnchorAlpha = pluck(dataObj.anchoralpha, seriesAnchorAlpha);
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, seriesAnchorBgAlpha);

                        // Finally add the data
                        // we call getPointStub function that manage displayValue, toolText and link
                        series.data.push({
                            y: itemValueY,
                            x: itemValueX,
                            displayValue : pointStub.displayValue,
                            toolText : pointStub.toolText,
                            link: pointStub.link,
                            marker: {
                                enabled: drawAnchors,
                                fillColor: {
                                    FCcolor: {
                                        color: setAnchorBgColor,
                                        alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                    }
                                },
                                lineColor: {
                                    FCcolor: {
                                        color: setAnchorBorderColor,
                                        alpha: setAnchorAlpha
                                    }
                                },
                                lineWidth: setAnchorBorderThickness,
                                radius: setAnchorRadius,
                                symbol: mapSymbolName(setAnchorSides)
                            }
                        });

                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                        this.pointValueWatcher(HCObj, itemValueY, itemValueX, showRegressionLine && regressionObj);
                    }
                    else {
                        // add the data
                        series.data.push({
                            y : null
                        });
                    }
                }

                if (showRegressionLine) {
                    regressionData = this.getRegressionLineSeries(regressionObj,
                        showYOnX, dataLength);

                    this.pointValueWatcher(HCObj, regressionData[0].y,
                        regressionData[0].x);
                    this.pointValueWatcher(HCObj, regressionData[1].y,
                        regressionData[1].x);

                    regSeries = {
                        type : 'line',
                        color : regLineColor,
                        showInLegend: false,
                        lineWidth : regressionLineThickness,
                        enableMouseTracking : false,
                        marker : {
                            enabled : false
                        },
                        data: regressionData,
                        zIndex : 0
                    };
                    series = [series, regSeries];
                }
            }
            // If all the values in current dataset is null
            // we will not show its legend
            if (!hasValidPoint) {
                series.showInLegend = false
            }
            return series;
        },

        categoryAdder : function(FCObj, HCObj) {
            var index, countCat = 0, fontSize, conf = HCObj[FC_CONFIG_STRING],
            xAxisConf = conf.x, catXValue,
            xAxisObj = HCObj.xAxis, dataLabel, categories,
            FCchartObj = FCObj.chart,
            labelStep = parseInt(FCchartObj.labelstep, 10),
            showLabels = pluckNumber(FCchartObj.showlabels, 1),
            xAxisLabelMode = pluck(FCchartObj.xaxislabelmode, 'categories').toLowerCase(),
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter;

            // NOTE: adding isXYPlot as the placeHorizontalAxis function needs this info.
            HCObj._FCconf.isXYPlot = true;

            labelStep = labelStep > 1 ? labelStep : 1;
            //track category occupied values
            //so that auto values will not work for that value
            xAxisConf.catOccupied = {};

            if (xAxisLabelMode !== 'auto' && FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                categories = FCObj.categories[0];
                //update the font relate attr in HC cat
                if (categories.font) {
                    HCObj.xAxis.labels.style.fontFamily  = categories.font;
                }
                if ((fontSize = pluckNumber(categories.fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }

                if (categories.fontcolor) {
                    HCObj.xAxis.labels.style.color  = categories.fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, "#");
                }
                var verticalLineColor = pluck(categories.verticallinecolor ,
                    defaultPaletteOptions.divLineColor[HCObj.chart.paletteIndex]),
                verticalLineThickness = pluckNumber(categories.verticallinethickness, 1),
                verticalLineAlpha = pluckNumber(categories.verticallinealpha,
                    defaultPaletteOptions.divLineAlpha[HCObj.chart.paletteIndex]),
                verticalLineDashed = pluckNumber(categories.verticallinedashed, 0),
                verticalLineDashLen = pluckNumber(categories.verticallinedashlen, 4),
                verticalLineDashGap = pluckNumber(categories.verticallinedashgap, 2),
                verticalLineColorRGB = convertColor(verticalLineColor, verticalLineAlpha),
                category,
                catShowVerticalLine,
                catLineDashed,
                catShowLabel;



                for (index = 0; index < categories.category.length; index += 1) {
                    category = categories.category[index];
                    catXValue = NumberFormatter.getCleanValue(category.x);
                    if (catXValue !== null && !category.vline) {
                        //store the cat occupied values
                        xAxisConf.catOccupied[catXValue] = true;

                        catShowLabel = pluckNumber(category.showlabel, category.showname,
                            showLabels);
                        catShowVerticalLine = pluckNumber(category.showverticalline, category.showline, category.sl, 0);
                        catLineDashed = pluckNumber(category.linedashed, verticalLineDashed);
                        dataLabel = (catShowLabel === 0 || countCat % labelStep !== 0) ? BLANKSTRING : parseUnsafeString(getFirstValue(category.label,
                            category.name));
                        xAxisObj.plotLines.push({
                            isGrid : true,
                            isCat : true,
                            width: catShowVerticalLine ? verticalLineThickness : 0,
                            color  : verticalLineColorRGB,
                            dashStyle  : getDashStyle(verticalLineDashLen, verticalLineDashGap, verticalLineThickness, catLineDashed),
                            value: catXValue,
                            label : {
                                text : dataLabel,
                                style : xAxisObj.labels.style,
                                align: POSITION_CENTER,
                                verticalAlign: POSITION_BOTTOM,
                                textAlign: POSITION_CENTER,
                                rotation : 0,
                                x : 0,
                                y : 0
                            }
                        });

                        //watch the value for min max of x
                        this.pointValueWatcher(HCObj, null, catXValue);
                        countCat += 1;
                    }
                }
                //if it is in mix mode then set the flag for requaredAutoNumeicLabels
                if (xAxisLabelMode === 'mixed') {
                    // Fix for hide the min and max for the xAxis of the CandleStick Chart
                    xAxisConf.requaredAutoNumeicLabels = pluckNumber(this.requaredAutoNumeicLabels, 1);
                }
            }
            else {
                // Fix for hide the min and max for the xAxis of the CandleStick Chart
                xAxisConf.requaredAutoNumeicLabels = pluckNumber(this.requaredAutoNumeicLabels, 1);
            }
            xAxisConf.adjustMinMax = true;
        },

        // Function that produce the point color
        getPointColor : function (color, alpha) {
            var colorObj, innerColor, outerColor;
            color = getFirstColor(color);
            alpha = getFirstAlpha(alpha);
            innerColor = getLightColor(color, 70);
            outerColor = getDarkColor(color, 50);
            colorObj = {
                FCcolor : {
                    gradientUnits : 'objectBoundingBox',
                    cx: 0.4,
                    cy: 0.4,
                    r: '100%',
                    color :  innerColor + COMMASTRING + outerColor,
                    alpha : alpha + COMMASTRING + alpha,
                    ratio : BGRATIOSTRING,
                    radialGradient : true
                }
            };

            return colorObj;
        },
        defaultSeriesType: 'scatter'
    }, chartAPI.xybase);


})();
